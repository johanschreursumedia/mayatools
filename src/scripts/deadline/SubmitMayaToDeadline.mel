// ===============================================================================================================
// Submit a Maya job to the deadline system.
// Install this in the Deadline Repository.
//
// Copyright (c) Thinkbox Software Inc
// All rights reserved.
// ===============================================================================================================

// ===============================================================================================================
// Adds Thinkbox shelf and button to Maya UI if necessary.
// ===============================================================================================================

// Only update the Maya UI if we're not in batch mode.

global proc string GetMayaRepoPath()
{
	global string $MayaRepoPath;

	if( $MayaRepoPath == "" )
	{
		$MayaRepoPath = CheckSlashes( SafeDeadlineCommand( "-getrepositorypath submission/Maya/Main/" ) );
	}

	return $MayaRepoPath;
}

// umedia
// we don't want to install any shelf in maya
// deadline is avaiable through the umedia menu
int $batchMode = 1;
//int $batchMode = `about -batch`;
if( !$batchMode )
{
	string $newName = "Deadline";
	string $newButtonName = "DeadlineButton";
	string $fileName = ( `internalVar -userShelfDir` + "shelf_" + $newName + ".mel" );

	int $addShelf = true;
	if( `file -q -exists $fileName` )
		$addShelf = false;
	else
	{
		// Check for existing shelves in optionVars.
		string $shelfName;
		int $shelfCount = `optionVar -q numShelves`;
		for( $i = 1; $i <= $shelfCount; $i++ )
		{
			$varName = "shelfName" + $i;
			$shelfName = `optionVar -q $varName`;
			if( $shelfName == $newName )
			{
				$addShelf = false;
				break;
			}
		}

		// Add the shelf if necessary.
		if( $addShelf )
			addNewShelfTab $newName;
	}

	int $addButton = true;
	string $buttonArray[] = `shelfLayout -q -childArray $newName`;
	for( $cnt = 0; $cnt < size( $buttonArray ); $cnt++ )
	{
		$buttonAnnotation = `shelfButton -q -annotation $buttonArray[$cnt]`;
		if( $buttonAnnotation == "Submit To Deadline" )
		{
			$addButton = false;
			string $imagePath = CheckSlashes( GetMayaRepoPath() + "/Submit.png" );
			shelfButton -e -image1 $imagePath $buttonArray[$cnt];
			break;
		}
	}

	if( $addButton )
	{
		string $imagePath  = CheckSlashes( GetMayaRepoPath() + "/Submit.png" );
		shelfButton -parent $newName -annotation "Submit To Deadline" -image1 $imagePath -command ("SubmitJobToDeadline") $newButtonName;
	}
}

// ===============================================================================================================
// Globals
// ===============================================================================================================

global string $DeadlineSubmitterWindow;
global string $ProjectPathGrp;
global string $ImageOutputPathGrp;
global string $StartupScriptPathGrp;
global string $MentalRayFilenameGrp;
global string $VRayFilenameGrp;
global string $LimitGroupGrp;
global string $DependenciesGrp;
global string $MachineListGrp;
global string $JobNameGrp;

global string $MayaRenderOptionsRollout;
global string $MayaRenderOptionsArnoldRollout;
global string $MayaRenderOptionsMentalRayRollout;
global string $MayaRenderOptionsRedshiftRollout;
global string $MayaRenderOptionsIRayRollout;
global string $MayaRenderOptionsVRayRollout;
global string $MayaRenderOptionsTileRollout;
global string $MayaRenderOptionsJigsawRollout;
global string $MentalRayExportRollout;
global string $MentalRayExportRenderJobRollout;
global string $VrayExportRollout;
global string $VrayExportRenderJobRollout;
global string $VrayExportVrimgJobRollout;
global string $RendermanExportRollout;
global string $RendermanExportRenderJobRollout;
global string $ArnoldExportRollout;
global string $ArnoldExportRenderJobRollout;
global string $RedshiftExportRollout;
global string $RedshiftExportRenderJobRollout;

global string $OverrideLayerSettingsDialog;


global int $MayaRenderJobType = 1;
global int $MentalRayExportJobType = 2;
global int $VRayExportJobType = 3;
global int $RendermanExportJobType = 4;
global int $ArnoldExportJobType = 5;
global int $MaxwellExportJobType = 6;
global int $BifrostSimulationJobType = 7;
global int $AlembicExportJobType = 8;
global int $MayaScriptJobType = 9;
global int $FluidCachingJobType = 10;
global int $GeometryCachingJobType = 11;
global int $RedshiftExportJobType = 12;

global int $JigsawRegionRenderType = 1;
global int $TileRegionRenderType = 2;

global int $BlankImageCompType = 1;
global int $PreviousImageCompType = 2;
global int $SelectedImageCompType = 3;

//Vray
global string $VrayLimitGroupGrp;
global string $VrayMachineListGrp;

//Mental Ray
global string $MentalLimitGroupGrp;
global string $MentalMachineListGrp;

//Renderman
global string $RendermanLimitGroupGrp;
global string $RendermanMachineListGrp;

//Arnold
global string $ArnoldLimitGroupGrp;
global string $ArnoldMachineListGrp;

//Maxwell
global string $MaxwellLimitGroupGrp;
global string $MaxwellMachineListGrp;
global string $MaxwellOutputScriptListGrp;

//Repository Paths
global string $MayaRepoPath = "";

//=================================================================
// SHOTGUN / FTRACK / NIM / Draft

global string $IntegrationInfoKeys[];
global string $IntegrationInfoValues[];

//=================================================================

//--------------------------------------------------------
// Browsing functions that call Deadline command.
//--------------------------------------------------------

// Set the project directory in the text field.
global proc SetProjectDir()
{
	global string $ProjectPathGrp;
	string $newdir = CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $ProjectPathGrp` + "\"", false );
	if( $newdir != "" )
		textFieldButtonGrp -e -text $newdir $ProjectPathGrp;

	SavePersistentDeadlineOptions();
}

// Set the output image directory in the text field.
global proc SetImageDir()
{
	global string $ImageOutputPathGrp;
	string $newdir = CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $ImageOutputPathGrp` + "\"", false );
	if( $newdir != "" )
		textFieldButtonGrp -e -text $newdir $ImageOutputPathGrp;

	SavePersistentDeadlineOptions();
}

// Set the startup script path in the text field.
global proc SetStartupScriptPath()
{
	global string $StartupScriptPathGrp;
	string $newpath = CallDeadlineCommand( "-SelectFilenameLoad \"" + `textFieldButtonGrp -q -text $StartupScriptPathGrp` + "\" \"Melscript Files (*.mel);;Python Files (*.py);;All files (*)\"", false );
	if( $newpath != "" )
		textFieldButtonGrp -e -text $newpath $StartupScriptPathGrp;

	SavePersistentDeadlineOptions();
}

// Set the startup script path in the text field.
global proc SetCompositeOverPath()
{
	global string $CompositeNamePathGrp;
	string $newpath = CallDeadlineCommand( "-SelectFilenameLoad \"" + `textFieldButtonGrp -q -text $CompositeNamePathGrp` + "\" \"All files (*)\"", false );
	if( $newpath != "" )
		textFieldButtonGrp -e -text $newpath $CompositeNamePathGrp;

	SavePersistentDeadlineOptions();
}

// Set the mental ray export filename in the text field.
global proc SetMentalRayFilename()
{
	global string $MentalRayFilenameGrp;
	string $newFilename = CallDeadlineCommand( "-selectfilenamesave \"" + `textFieldButtonGrp -q -text $MentalRayFilenameGrp` + "\" \"Mental Ray Files (*.mi);;All Files (*)\"", false );
	if( $newFilename != "" )
		textFieldButtonGrp -e -text $newFilename $MentalRayFilenameGrp;

	SavePersistentDeadlineOptions();
}

global proc SetVRayFilename()
{
	global string $VRayFilenameGrp;
	string $newFilename = CallDeadlineCommand( "-selectfilenamesave \"" + `textFieldButtonGrp -q -text $VRayFilenameGrp` + "\" \"VRay Scene Files (*.vrscene);;All Files (*)\"", false );
	if( $newFilename != "" )
		textFieldButtonGrp -e -text $newFilename $VRayFilenameGrp;

	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetLimitGroups()
{
	global string $LimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $LimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $LimitGroupGrp;

	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetVrayLimitGroups()
{
	global string $VrayLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $VrayLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $VrayLimitGroupGrp;

	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetMentalLimitGroups()
{
	global string $MentalLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $MentalLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $MentalLimitGroupGrp;

	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetRendermanLimitGroups()
{
	global string $RendermanLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $RendermanLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $RendermanLimitGroupGrp;

	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetArnoldLimitGroups()
{
	global string $ArnoldLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $ArnoldLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $ArnoldLimitGroupGrp;

	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetMaxwellLimitGroups()
{
	global string $MaxwellLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $MaxwellLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $MaxwellLimitGroupGrp;

	SavePersistentDeadlineOptions();
}

// Set the startup script path in the text field.
global proc SetMaxwellOutputScript()
{
	global string $MaxwellOutputScriptListGrp;
	string $newpath = CallDeadlineCommand( "-SelectFilenameSave \"" + `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp` + "\" \"Maxwell Files (*.mxs)\"", false );
	if( $newpath != "" )
		textFieldButtonGrp -e -text $newpath $MaxwellOutputScriptListGrp;

	SavePersistentDeadlineOptions();
}

// Set the dependencies in the job dependency field.
global proc SetDependencies()
{
	global string $DependenciesGrp;
	string $newDependencies = CallDeadlineCommand( "-selectdependencies \"" + `textFieldButtonGrp -q -text $DependenciesGrp` + "\"", false );
	if( $newDependencies != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newDependencies $DependenciesGrp;

	SavePersistentDeadlineOptions();
}

// Set the machine list in the machine list field.
global proc SetMachineList()
{
	global string $MachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $MachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $MachineListGrp;

	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetVrayMachineList()
{
	global string $VrayMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $VrayMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $VrayMachineListGrp;

	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetMentalMachineList()
{
	global string $MentalMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $MentalMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $MentalMachineListGrp;

	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetRendermanMachineList()
{
	global string $RendermanMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $RendermanMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $RendermanMachineListGrp;

	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetArnoldMachineList()
{
	global string $ArnoldMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $ArnoldMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $ArnoldMachineListGrp;

	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetMaxwellMachineList()
{
	global string $MaxwellMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $MaxwellMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $MaxwellMachineListGrp;

	SavePersistentDeadlineOptions();
}

// Set the job name to be the scene name.
global proc SetJobName()
{
	global string $JobNameGrp;
	string $newJobName = GetStrippedSceneFileName();
	textFieldButtonGrp -e -text $newJobName $JobNameGrp;

	SavePersistentDeadlineOptions();
}

// Set the Maya script path in the text field
global proc SetMayaOutputScript()
{
	global string $MayaScriptButtonGrp;
	string $newpath = CallDeadlineCommand( "-SelectFilenameLoad \"" + `textFieldButtonGrp -q -text $MayaScriptButtonGrp` + "\" \"Melscript Files (*.mel);;Python FIles (*.py)\"", false );

	if( $newpath != "" )
		textFieldButtonGrp -e -text $newpath $MayaScriptButtonGrp;

	SavePersistentDeadlineOptions();
}

// Set the folder that BiFrost caches will be written to
global proc SetBifrostCacheDirectory()
{
	global string $BifrostDirectoryButtonGrp;

	//string $newdir = CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $ProjectPathGrp`            + "\"", false );
	//print(`textFieldButtonGrp -q -text $BifrostDirectoryButtonGrp`);
	string $newdir = CheckSlashes( CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $BifrostDirectoryButtonGrp` + "\"", false ) );

	if( $newdir != "" )
		textFieldButtonGrp -e -text $newdir $BifrostDirectoryButtonGrp;

	SavePersistentDeadlineOptions();
}

// Set the file that the Alembic cache will be written to
global proc SetAlembicCacheFile()
{
	global string $AlembicFileButtonGrp;

	string $newfile = CheckSlashes( CallDeadlineCommand( "-SelectFilenameSave \"" + `textFieldButtonGrp -q -text $AlembicFileButtonGrp` + "\" \"Alembic Files (*.abc)\"", false ) );

	if( $newfile != "" )
		textFieldButtonGrp -e -text $newfile $AlembicFileButtonGrp;

	SavePersistentDeadlineOptions();
}

// Set the output directory for the geometric cache
global proc SetGeometricCacheDirectory()
{
	global string $GeometryCachingDirButtonGrp;

	string $newfile =  CheckSlashes( CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $GeometryCachingDirButtonGrp` + "\"", false ) );

	if( $newfile != "" )
		textFieldButtonGrp -e -text $newfile $GeometryCachingDirButtonGrp;

	SavePersistentDeadlineOptions();
}

// Set the output directory for the fluid cache
global proc SetFluidCacheDirectory()
{
	global string $FluidCachingDirButtonGrp;

	string $newDir = CheckSlashes( CallDeadlineCommand( "-getDirectory \"" + `textFieldButtonGrp -q -text $FluidCachingDirButtonGrp` + "\"", false ) );

	if( $newDir != "" )
	{
		textFieldButtonGrp -e -text $newDir $FluidCachingDirButtonGrp;
	}

	SavePersistentDeadlineOptions();
}

//=================================================================

//---------------------------------------------------------
// Maya Helper Functions
//---------------------------------------------------------

// Returns the current version of Maya.
global proc float MayaVersion()
{
	float $version = getApplicationVersionAsFloat();
	if( $version < 2014 || $version == 2016 )
	{
		// Before 2014, getApplicationVersionAsFloat would parse `about -v`, which wouldn't include the .5 at the end of the Maya 2011.5 or 2013.5 releases.
		// This was fixed in 2014 by parsing `about -apiVersion`, so that's what we're doing here.
		int $apiVersion = `about -apiVersion`;
		$version = float($apiVersion) / 100.0;
	}
	return $version;
}

// Returns the current version of Maya as an integer.
global proc int IntMayaVersion()
{
	float $version = MayaVersion();
	return floor ( $version );
}

// Returns the current renderer.
global proc string GetCurrentRenderer()
{
	string $renderer = currentRenderer();
	if( $renderer == "_3delight" )
		$renderer = "3delight";
	return $renderer;
}

// Returns if we're using an older version of vray
global proc string IsOldVray()
{
	// This function contains 3 parameters in the new version, so if this eval
	// returns an error (ie: 1), then we know it's an old version of Vray.
	return catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\" )" ) );
}

// Returns the output prefix as is shown in the Render Globals, except that the frame
// number is replaced with '?' padding.
//global proc string GetOutputPrefix( int $replaceFrameNumber, int $newFrameNumber )
global proc string GetOutputPrefix( int $replaceFrameNumber, int $newFrameNumber, string $layerName, string $cameraName, string $renderElement )
{
	string $outputPrefix = "";
	string $paddingString = "";

	string $renderer = GetCurrentRenderer();

	string $renderableCameras[] = deadlineGetRenderableCameras( false );

	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );


	if( $renderer == "vray" )
	{
		// Need to special case vray, because they like to do things differently.
		global string $g_vrayImgExt[];

		string $ext = "";
		if (`optionMenuGrp -exists vrayImageFormatMenu`)
			$ext = `optionMenuGrp -q -v vrayImageFormatMenu`;
		else
			$ext = `getAttr vraySettings.imageFormatStr`;
			if ($ext == "")
				$ext = "png";//for some reason this happens if you have not changed the format

		// VRay can append this to the end of the render settings display, but we don't want it in the file name.
		int $isMultichannelExr = false;
		string $multichannel = " (multichannel)";
		if( endsWith( $ext, $multichannel ) )
		{
			$ext = substring( $ext, 1, size( $ext ) - size( $multichannel ) );
			$isMultichannelExr = true;
		}
		string $versionString = `vray version`;
		int $version = 2;
		int $minorVersion = 0;
		if( $versionString != ""  )
		{
			string $buffer[];

			tokenize($versionString, ".", $buffer);
			$version = (int)$buffer[0];
			$minorVersion = (int)$buffer[1];
		}


		// We need to use eval because the definition of vrayTransformFilename is different for
		// different versions of vray, and this is the only way to get around the "incorrect
		// number of arguments" error.
		string $prefix = `getAttr vraySettings.fileNamePrefix`;

		int $separateFolders = `getAttr "vraySettings.relements_separateFolders"`;

		int $separateRGBA = 0;
		if( !catchQuiet( `getAttr "vraySettings.relements_separateRGBA"` ) )
		{
			 $separateRGBA = `getAttr "vraySettings.relements_separateRGBA"`;
		}

		/*
		if( IsOldVray() )
			$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\" )" );
		else
			$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\", \"\" )" );
		*/

		if( $prefix == "" )
		{
			$prefix = GetStrippedSceneFileName();
		}

		if( $renderElement != "" && $separateFolders )
		{
			string $tempPrefix = `dirname($prefix)`;
			if( $tempPrefix != "" )
			{
				$tempPrefix = $tempPrefix+ "/";
			}
			$prefix = $tempPrefix + $renderElement + "/" + basename($prefix,"");
		}
		else if( $renderElement == "" && $separateFolders && $separateRGBA  )
		{
			string $tempPrefix = `dirname($prefix)`;
			if( $tempPrefix != "" )
			{
				$tempPrefix = $tempPrefix+ "/";
			}
			$prefix = $tempPrefix + "rgba/" + basename($prefix,"");
		}

		if( $multipleRenderableCams && ( `match "<Camera>" $prefix`== "" ) && ( `match "<camera>" $prefix`== "" ) && ( `match "%c" $prefix`== "" ) )
		{
			$prefix = "<Camera>/" + $prefix;
		}

		if( IsRenderLayersOn() && ( `match "<Layer>" $prefix`== "" ) && ( `match "<layer>" $prefix`== "" ) && ( `match "%l" $prefix`== "" ) )
		{
			$prefix = "<Layer>/" + $prefix;
		}


		// Don't transform if the prefix is blank, so we can just default to the scene file name.
		if( $prefix != "" )
		{
			if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\", 0, 0 )" ) ) )
			{
				// Vray strips off all extensions in the scene name when replacing the <Scene> tag.
				string $sceneName = GetStrippedSceneFileName();

				if( $version < 3 || ( $version == 3 && $minorVersion == 0 ) )
				{
					$sceneName = `basenameEx $sceneName`;
				}
				$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"" + $cameraName + "\", \"" + $sceneName + "\", 0, 0 )" );
			}
			else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\", 0 )" ) ) )
			{
				// Vray strips off all extensions in the scene name when replacing the <Scene> tag.
				string $sceneName = GetStrippedSceneFileName();
				if( $version < 3 || ( $version == 3 && $minorVersion == 0 ) )
				{
					$sceneName = `basenameEx $sceneName`;
				}
				$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"" + $cameraName + "\", \"" + $sceneName + "\", 0 )" );
			}
			else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\" )" ) ) )
				$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\", \"\" )" );
			else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\" )" ) ) )
				$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\" )" );
			else
				print( "Could not evaluate output path using vrayTransformFilename, please contact Deadline support and include the version of vray you are using\n" );
		}

		//if( catchQuiet( eval( "vrayTransformFilename( \"" + $prefix + "\", \"\", \"\" )" ) ) )
		//{
		//	if( catchQuiet( eval( "vrayTransformFilename( \"" + $prefix + "\", \"\" )" ) ) )
		//		$prefix = `getAttr vraySettings.fileNamePrefix`;
		//}

		//if( $prefix == "" )
		//	$prefix = GetStrippedSceneFileName();

		if( $renderElement != "" && $isMultichannelExr == 0 )
		{
			$prefix = $prefix + (`getAttr "vraySettings.fileNameRenderElementSeparator"`) + $renderElement;
		}
		else if ( $renderElement == "" && $separateFolders && $separateRGBA && $isMultichannelExr == 0 )
		{
			$prefix = $prefix + (`getAttr "vraySettings.fileNameRenderElementSeparator"`) + "rgba";
		}

		if( IsAnimatedOn() )
		{
			// Seems to be a bug where no matter what, VRay will use 4 digits for padding.
			// If ever fixed, try using the value from the vray settings.
			//int $padding = `getAttr vraySettings.fileNamePadding`;
			int $padding = 4;
			if($version >= 3)
				$padding = `getAttr vraySettings.fileNamePadding`;
			for( $i = 0; $i < $padding; $i ++ )
				$paddingString = $paddingString + "#";

			// When rendering to a non-raw format, vray places a period before the padding, even though it
			// doesn't show up in the render globals filename.
			if( $ext == "vrimg" || ($isMultichannelExr && $version < 3) )
				$outputPrefix = $prefix + $paddingString + "." + $ext;
			else
				$outputPrefix = $prefix + "." + $paddingString + "." + $ext;
		}
		else
		{
			// When rendering to a non-raw format, vray places a period before the padding, even though it
			// doesn't show up in the render globals filename.
			if( $ext == "vrimg" || ($isMultichannelExr && $version < 3) )
				$outputPrefix = $prefix + "." + $ext;
			else
				$outputPrefix = $prefix + "." + $ext;
		}
	}
	else
	{
		int $paddingFound = 0;

		// Get the first output prefix.
		string $prefixString = "";
		if( $renderer == "renderMan" || $renderer == "renderManRIS" )
		{
			//$prefixString = `rmanGetImageName 1`;
			if( $cameraName == "" )
			{
				string $pat = rmanGetImagenamePattern(1);
				string $ftext = rmanGetImageExt("");
				$prefixString= rman("assetref",
										"-cls", "Final",
										"-assetnmpat", $pat,
										"-ref", "$ASSETNAME",
										"-LAYER", $layerName,
										"-EXT", $ftext,
										"-DSPYID", "",
										"-DSPYCHAN", "");
			}
			else
			{
				string $cameraRelatives[] = `listRelatives -s $cameraName`;

				string $camera = $cameraRelatives[0];
				string $pat = rmanGetImagenamePattern(1);
				string $ftext = rmanGetImageExt("");
				$prefixString= rman("assetref",
										"-cls", "Final",
										"-assetnmpat", $pat,
										"-ref", "$ASSETNAME",
										"-LAYER", $layerName,
										"-CAMERA", $camera,
										"-EXT", $ftext,
										"-DSPYID", "",
										"-DSPYCHAN", "");
				}


		}
		else if($renderer == "MayaKrakatoa")
		{
			//string $prefixes[] = `renderSettings -fin`;
			string $prefixes[] = `renderSettings -fin -lyr $layerName -cam $cameraName`;
			$prefixString = $prefixes[0];

			int $forceEXROutput = `getAttr "MayaKrakatoaRenderSettings.forceEXROutput"`;
			if($forceEXROutput == 1)
			{
				string $tokens[];
				tokenize $prefixString "." $tokens;
				string $result = "";
				int $i;

				for($i = 0; $i<size($tokens)-1; $i++)
				{
					$result += $tokens[$i] + ".";
				}
				$prefixString = $result + "exr";
			}
		}
		else
		{
			string $currentPrefix = `getAttr defaultRenderGlobals.imageFilePrefix`;

			string $newPrefix = $currentPrefix;
			if( $newPrefix == "" )
			{
				$newPrefix = GetStrippedSceneFileName();
			}

			if( $renderer == "arnold" && `match "<RenderPass>" $newPrefix`== ""  )
			{
				$elements = getArnoldElementNames();

				if( $elements[0] != "" )
				{
					$newPrefix = "<RenderPass>/" + $newPrefix;
				}
			}

			if( $renderer == "mentalRay" && `match "<RenderPass>" $newPrefix`== ""  )
			{
				$elements = getMentalRayElementNames( $layerName );
				if( $elements[0] != "" )
				{
					$newPrefix = "<RenderPass>/" + $newPrefix;
				}
			}

			if( $multipleRenderableCams && ( `match "<Camera>" $newPrefix`== "" ) && ( `match "%c" $newPrefix`== "" ) )
			{
				$newPrefix = "<Camera>/" + $newPrefix;
			}

			if( IsRenderLayersOn() && ( `match "<RenderLayer>" $newPrefix`== "" ) && ( `match "<Layer>" $newPrefix`== "" ) && ( `match "%l" $newPrefix`== "" ) )
			{
				$newPrefix = "<RenderLayer>/" + $newPrefix;
			}
			setAttr "defaultRenderGlobals.imageFilePrefix" -type "string" $newPrefix;

			//string $prefixes[] = `renderSettings -fin`;
			string $prefixes[] = `renderSettings -fin -lyr $layerName -cam $cameraName -cts ("RenderPass=" + $renderElement )`;
			$prefixString = $prefixes[0];

			setAttr "defaultRenderGlobals.imageFilePrefix" -type "string" $currentPrefix;
		}

		// Go through each letter of the prefix and create a new prefix with each letter
		// separated by colons, ie: f:i:l:e:n:a:m:e:.:e:x:t:
		string $prefixWithColons = "";
		for( $i = 1; $i <= size( $prefixString ); $i++ )
			$prefixWithColons += substring( $prefixString, $i, $i ) + ":";

		// Now split up the new prefix into an array, which removes all the colons and
		// places one letter in each index. Then count backwards and replace the first
		// group of numbers with the padding characters.
		string $prefix[] = stringToStringArray( $prefixWithColons, ":" );

		if( IsAnimatedOn() )
		{
			for( $i = size( $prefix ); $i > 0; $i-- )
			{
				if( match( "[0-9]", $prefix[$i] ) != "" )
				{
					$prefix[$i] = "#";
					$paddingString = $paddingString + "#";
					$paddingFound = 1;
				}
				else if( $paddingFound )
				{
					if( $prefix[$i] == "-" )
					{
						$prefix[$i] = "#";
						$paddingString = $paddingString + "#";
					}
					break;
				}
			}
		}

		// Finally, convert the prefix array back to a string.
		$outputPrefix = stringArrayToString( $prefix, "" );

		if( $renderer == "maxwell" && $renderElement != "" )
		{
			string $prefixParts[] = stringToStringArray( $outputPrefix, "." );
			int $numParts = size( $prefixParts );
			int $mainPart = $numParts -2;
			if( IsAnimatedOn() )
				$mainPart -= 1;

			$prefixParts[ $mainPart ] = $prefixParts[ $mainPart ] + "_" + $renderElement;

			int $extNumber = 0;
			if( $renderElement == "zbuffer"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.depthChannelFormat`;
			}
			else if( $renderElement == "object"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.objIDChannelFormat`;
			}
			else if( $renderElement == "material"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.matIDChannelFormat`;
			}
			else if( $renderElement == "motion"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.motionVectorChannelFormat`;
			}
			else if ( startsWith($renderElement, "customAlpha_") )
			{
				$extNumber = `getAttr maxwellRenderOptions.customAlphaChannelFormat`;
			}
			else
			{
				$extNumber = `getAttr( "maxwellRenderOptions." + $renderElement + "ChannelFormat")`;
			}
			$prefixParts[ $numParts -1 ] = getMaxwellChannelExtension($extNumber, true);
			$outputPrefix = stringArrayToString($prefixParts, ".");
		}
		else if( $renderer == "maxwell")
		{
			int $format = `getAttr defaultRenderGlobals.imageFormat`;

			$outputPrefix = `substring $outputPrefix 1 (size($outputPrefix)-3)`;
			$outputPrefix =  $outputPrefix + getMaxwellChannelExtension($format, false);

		}

	}

	if( IsAnimatedOn() && $replaceFrameNumber )
	{
		string $paddedFrame = "" + $newFrameNumber;
		while( size($paddedFrame) < size($paddingString) )
			$paddedFrame = "0" + $paddedFrame;
		$outputPrefix = substituteAllString( $outputPrefix, $paddingString, $paddedFrame );
	}

	return $outputPrefix;
}

global proc string CreateArgumentsFile( string $argumentList[] )
{
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	// Submit the job to Deadline
	string $submissionCommandFile = CheckSlashes( $tempDir + "/maya_submission.txt" );
	$fileId = `fopen $submissionCommandFile "w"`;
	for($argument in $argumentList)
	{
		fprint $fileId ( $argument + "\n" );
	}

	fclose $fileId;

	return $submissionCommandFile;
}

global proc string GetJigsawOutputPrefix(string $outputPrefix, int $region, string $renderer)
{
	string $path = dirname( $outputPrefix );
	if( $path != "" )
		$path = $path + "/";

	string $base = basename( $outputPrefix, "" );

	string $tile = "region_"+$region+"_";
	if( $renderer != "renderMan" && $renderer != "renderManRIS" )
	{
		$tile = "_" + $tile;
	}
	return $path+$tile+$base;
}

// Creates a tile prefix from the given prefix by placing the tile part at the
// beginning of the filename. It's placed at the beginning to try and avoid as
// many conflicts as possible with Maya's prefix shortcuts.
global proc string GetTileOutputPrefix( string $outputPrefix, int $x, int $y, int $xCount, int $yCount, string $renderer )
{
	string $path = dirname( $outputPrefix );
	if( $path != "" )
		$path = $path + "/";

	string $base = basename( $outputPrefix, "" );
	string $tile = "tile_" + $x + "x" + $y + "_" + $xCount + "x" + $yCount + "_";
	if( $renderer != "renderMan" && $renderer != "renderManRIS" )
	{
		$tile = "_" + $tile;
	}
	return $path + $tile + $base;
}

global proc string GetMayaOutputPrefix( string $currCamera, string $layer )
{

	string $prefix = "";
	string $renderer = GetCurrentRenderer();

	// Source a CustomOutputPrefix.mel file, if it exists.
	string $outputPrefixPath = CheckSlashes( GetMayaRepoPath() + "CustomOutputPrefix.mel" );

	if( `file -q -exists $outputPrefixPath` )
	{
		print( "sourcing custom outputprefix file: " + $outputPrefixPath + "\n" );
		eval( "source \"" + $outputPrefixPath + "\";" );
		$prefix = GetCustomMayaOutputPrefix( $currCamera );
	}
	else
	{
		if( $renderer != "vray" )
			$prefix = `getAttr defaultRenderGlobals.imageFilePrefix`;
		else
			$prefix = `getAttr vraySettings.fileNamePrefix`;
	}

	if( $prefix == "" )
	{
		$prefix = GetStrippedSceneFileName();
	}

	if( $renderer == "arnold" && `match "<RenderPass>" $prefix`== ""  )
	{
		$elements = getArnoldElementNames();

		if( $elements[0] != "" )
		{
			$prefix = "<RenderPass>/" + $prefix;
		}
	}

	if( $renderer == "mentalRay" && `match "<RenderPass>" $prefix`== ""  )
	{
		$elements = getMentalRayElementNames( $layer );
		if( $elements[0] != "" )
		{
			$prefix = "<RenderPass>/" + $prefix;
		}
	}

	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	//Redshift does not work with multiple renderable cameras so we need to node add <camera>
	if( $multipleRenderableCams )
	{
		// vray accepts <camera> as a token, whereas no one else does
		if( ( `match "<Camera>" $prefix`== "" ) && ( `match "%c" $prefix`== "" ) && $renderer != "redshift" && ( $renderer != "vray" || `match "<camera>" $prefix`== "" ) )
		{
			$prefix = "<Camera>/" + $prefix;
		}
	}

	if( IsRenderLayersOn() )
	{
		if( $renderer == "vray" && ( `match "<Layer>" $prefix`== "" ) && ( `match "<layer>" $prefix`== "" ) && ( `match "%l" $prefix`== "" ) )
		{
			$prefix = "<Layer>/" + $prefix;
		}
		else if($renderer != "vray" && ( `match "<RenderLayer>" $prefix`== "" ) && ( `match "<Layer>" $prefix`== "" ) && ( `match "%l" $prefix`== "" ) )
		{
			$prefix = "<RenderLayer>/" + $prefix;
		}
	}

	return $prefix;
}

// Gets the image directory for Maya.
global proc string GetImageDirectory()
{
	string $imageDir = "";

	// The -renderType flag is obsolete in 2013 and later.
	if( IntMayaVersion() <= 2012 )
	{
		// Relative path, get the project's image directory.
		string $fileRules[] = `workspace -q -renderType`;

		for( $i = 0; $i < size( $fileRules ); $i += 2 )
		{
			if( $fileRules[$i] == "images" )
			{
				$imageDir = $fileRules[$i+1];
				break;
			}
		}
	}
	else
	{
		// Relative path, get the project's image directory.
		$imageDir = `workspace -q -fileRuleEntry "images"`;
	}

	string $path = `workspace -q -fullName`;
	if( substring( $path, size( $path ), size( $path ) ) != "\\" && substring( $path, size( $path ), size( $path ) ) != "/" )
		$path = $path + "/";

	if( $imageDir == "" )
		return $path;

	if( substring( $imageDir, size( $imageDir ), size( $imageDir ) ) != "\\" && substring( $imageDir, size( $imageDir ), size( $imageDir ) ) != "/" )
		$imageDir = $imageDir + "/";

	// Check for an absolute path in the image directory.
	if( substring( $imageDir, 1, 1 ) == "/" || substring( $imageDir, 1, 1 ) == "\\" || substring( $imageDir, 2, 2 ) == ":" )
		$path = $imageDir;
	else
		$path = $path + $imageDir;

	return $path;
}


// Returns frame range and by step count.
global proc int[] GetFrameRange()
{
	int	$range[3] = { 0, 0, 1 };

	if( IsAnimatedOn() )
	{
		//string $renderer = GetCurrentRenderer();
		//if( $renderer != "vray" )
		//{
			$range[0] = `getAttr defaultRenderGlobals.startFrame`;
			$range[1] = `getAttr defaultRenderGlobals.endFrame`;
			$range[2] = `getAttr defaultRenderGlobals.byFrameStep`;
		//}
		//else
		//{
		//	$range[0] = `getAttr vraySettings.startFrame`;
		//	$range[1] = `getAttr vraySettings.endFrame`;
		//	$range[2] = `getAttr vraySettings.frameStep`;
		//}
	}
	else
	{
		$range[0] = `currentTime -q`;
		$range[1] = `currentTime -q`;
		$range[2] = 1;
	}

	return $range;
}

// Returns global resolution.
global proc int[] GetGlobalsResolution()
{
	int	$res[2] = { 320, 240 };

	string $renderer = GetCurrentRenderer();
	if( $renderer != "vray" )
	{
		string $globals[] = `ls -renderGlobals`;
		if( size( $globals[0] ) > 0 )
		{
			string $connect[] = `listConnections ($globals[0] + ".resolution")`;
			if( size( $connect[0] ) > 0 )
			{
				$res[0] = `getAttr ( $connect[0] + ".width" )`;
				$res[1] = `getAttr ( $connect[0] + ".height" )`;
			}
		}
	}
	else
	{
		$res[0] = `getAttr vraySettings.width`;
		$res[1] = `getAttr vraySettings.height`;
	}

	return $res;
}

// Returns if animation is enabled.
global proc int IsAnimatedOn()
{
	string $renderer = GetCurrentRenderer();

	int $anim = false;
	/*
	if( $renderer == "vray" )
	{
		if( IsOldVray() )
			$anim = `getAttr vraySettings.animation`;
		else
			$anim = `getAttr defaultRenderGlobals.animation`;
	}
	else
	*/
		$anim = `getAttr defaultRenderGlobals.animation`;

	return $anim;
}

// Returns if motion blur is enabled.
global proc int GetMotionBlur()
{
	string $renderer = GetCurrentRenderer();

	int $mb = false;
	if( $renderer == "mentalRay" )
		$mb = `getAttr miDefaultOptions.motionBlur`;
	else if( $renderer == "mayaHardware" || $renderer == "mayaHardware2" )
		$mb = `getAttr hardwareRenderGlobals.enableMotionBlur`;
	else if( $renderer == "mayaVector" )
		$mb = false;
	else if( $renderer == "turtle" )
		$mb = `getAttr TurtleRenderOptions.motionBlur`;
	else if( $renderer == "renderMan" || $renderer == "renderManRIS" )
		$mb = `getAttr renderManGlobals.rman__torattr___motionBlur`;
	else if( $renderer == "finalRender" )
		$mb = `getAttr defaultFinalRenderSettings.motionBlur`;
	else if( $renderer == "vray" )
		$mb = `getAttr vraySettings.cam_mbOn`;
	else
		$mb = `getAttr defaultRenderGlobals.motionBlur`;

	return $mb;
}

// Returns if render layers is on.
global proc int IsRenderLayersOn()
{
	string $renderLayers[] = `listConnections renderLayerManager.renderLayerId`;
	return ( size($renderLayers) > 1);
}

global proc string[] getRenderableRenderLayers()
{
	string $renderLayerList[] = `listConnections renderLayerManager.renderLayerId`;
	// Loop through the render layer if the checkbox is on
	string $renderableLayers[] = {};

	for( $layer in $renderLayerList )
	{
		// Only get output if the renderable attribute is on
		int $renderable = `getAttr( $layer + ".renderable" )`;

		if( $renderable )
		{

			int $isReferenceLayer = `referenceQuery -inr $layer`;

			if( $isReferenceLayer )
			{
				string $buffer[];
				int $numTokens = tokenize($layer, $buffer);
				if ($buffer[ $numTokens - 1 ] != "defaultRenderLayer")
				{
					stringArrayInsertAtIndex(0, $renderableLayers, $layer );
				}

			}
			else
			{
				stringArrayInsertAtIndex(0, $renderableLayers, $layer );
			}
		}
	}

    return $renderableLayers;
}


global proc string[] deadlineGetRenderableCameras( int $ignoreDefaultCameras )
{
	string $cameraNames[] = `listTransforms -cameras`;
	string $renderableCameras[] = {};

	for( $cameraName in $cameraNames )
	{
		if( IsCameraRenderable( $cameraName ) )
		{
			string $relatives[] = `listRelatives -s $cameraName`;
			string $cameraShape = $relatives[0];
			// Only submit default cameras if the setting to ignore them is disabled.
			if( !$ignoreDefaultCameras || !IsDefaultCamera( $cameraShape ) )
			{

				stringArrayInsertAtIndex(0, $renderableCameras, $cameraName );
			}
		}
	}

	return $renderableCameras;
}

global proc int IsDefaultCamera( string $cameraName )
{
	if( $cameraName == "frontShape" || $cameraName == "perspShape" || $cameraName == "sideShape" || $cameraName == "topShape" )
		return true;
	else if( $cameraName == "front" || $cameraName == "persp" || $cameraName == "side" || $cameraName == "top" )
		return true;
	else
		return false;
}

global proc int IsCameraRenderable( string $cameraName )
{
	//print( "Checking if camera is renderable: " + $cameraName + "\n" );

	string $relatives[] = `listRelatives -s $cameraName`;
	string $cameraShape = $relatives[0];

	int $cameraRenderable = 0;

	// Getting the renderable attribute can throw an error if there are duplicate camera shape names.
	// The catch blocks are to prevent these erros so that the submission can continue.
	if( !catch(`attributeExists "renderable" $cameraShape`) )
		catch($cameraRenderable = `getAttr( $cameraShape + ".renderable" )`);

	return $cameraRenderable;
}

// Returns if the renderer supports region rendering.
global proc int SupportsRegionRendering( string $renderer )
{
	if( $renderer == "arnold" || $renderer == "mayaSoftware" ||  $renderer == "mentalRay" ||  $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "finalRender" || $renderer == "turtle" || $renderer == "vray"  || $renderer == "ifmIrayPhotoreal" || $renderer == "redshift" )
		return true;
	return false;
}

global proc int TilesAreCropped( string $renderer, string $imfType )
{
	if( $renderer == "mentalRay" || $renderer == "vray" || $renderer == "ifmIrayPhotoreal" || $renderer == "redshift" || ( ( $renderer == "arnold" || $renderer == "renderMan" || $renderer == "renderManRIS"  ) && ( $imfType == "exr" || $imfType == "deepexr" ) ) )
		return true;
	return false;
}

// Returns if the y-axis for region rendering is inverted for the given renderer.
global proc int IsRegionRenderingInverted( string $renderer )
{
	if( $renderer != "renderMan" && $renderer != "renderManRIS" && $renderer != "vray" && $renderer != "arnold" )
		return true;
	return false;
}

// Returns if the renderer supports the CPU option.
global proc int EnableCpuOption( string $renderer )
{
	if( IsRenderLayersOn() )
		return true;
	else
	{
		if( $renderer == "mayaSoftware" || $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "finalRender" || $renderer == "gelato" || $renderer == "maxwell" || $renderer == "vray" )
			return true;
	}

	return false;
}

// Returns the cpu count selected for the current render (if any).
global proc int GetCpuSetting( string $renderer )
{
	if( $renderer == "mayaSoftware" )
	{
		int $cpus = `getAttr defaultRenderGlobals.numCpusToUse`;
		if( $cpus > 0 )
			return $cpus;
	}
	else if( $renderer == "maxwell" )
	{
		int $cpus = `getAttr "maxwellRenderOptions.numThreads"`;
		if( $cpus > 0 )
			return $cpus;
	}
	else if( $renderer == "vray" )
	{
		int $cpus = `getAttr( "vraySettings.sys_max_threads" )`;
		if( $cpus > 0 )
			return $cpus;
	}

	return 0;
}

// Returns if the renderer supports half frame rendering.
global proc int ShowHalfFramesOption( string $renderer )
{
	if( !IsRenderLayersOn() )
	{
		if( $renderer == "renderman" || $renderer == "renderManRIS" || $renderer == "vray" )
			return false;
	}

	return true;
}

// Opens the mental ray export settings dialog.
global proc OpenExportSettings()
{
	fileOptions "ExportAll" "projectViewer ExportAll";
}

// Launches the Maya online help
global proc OnlineHelp()
{
	CallDeadlineCommand( "-startprocess http://www.thinkboxsoftware.com/support/", false );
}

//--------------------------------------------------------
// Utility Functions
// --------------------------------------------------------

// Waits for a fixed amount of time (in milliseconds)
global proc Wait( int $waitTime )
{
	$startTime = `timerX`;

	while (`timerX -startTime $startTime` * 1000 < $waitTime )
	{ /* Do nothing... weeeee! */ }
}

// Returns the filename with the path and extension stripped off.
global proc string StripPathAndExt( string $fullFileName )
{
	string $fileNameNoPath = match( "[^/\\]*$", $fullFileName );
	string $fileNameOnly = match( "[^\.]*", $fileNameNoPath );

	return $fileNameOnly;
}

global proc string GetStrippedSceneFileName()
{
	string $fileName =`file -q -sceneName`;
	$fileName = `basename $fileName ".mb"`;
	$fileName = `basename $fileName ".ma"`;

	return $fileName;
}

// Ensures that all slashes are consistent throughout the filename.
global proc string CheckSlashes( string $filename )
{
	//string $result = substituteAllString( $filename, "\\", "/" ); // switch from '\' to '/'
	//$result = substituteAllString( $result, "//", "/" ); // replace double '/' where paths may have been combined
	//if( startsWith( $result, "/" ) )
	//	$result = "/" + $result;
	//return $result;

	string $result = $filename;
	string $newResult;
	$newResult = `substitute "\\\\" $result "/"`;
	while( $newResult != $result )
	{
		$result = $newResult;
		$newResult = `substitute "\\\\" $result "/"`;
	}

	$result = $newResult;
	$newResult = `substitute "//" $result "/"`;
	while( $newResult != $result )
	{
		$result = $newResult;
		$newResult = `substitute "//" $result "/"`;
	}

	if( `about -ntOS` )
	{
		if( startsWith( $newResult, "/" ) )
			$newResult = "/" + $newResult;
	}

	return $newResult;
}

// Returns true if the path is on the c:, d:, or e:.
global proc int IsLocalDrive( string $path )
{
	if( size( $path ) > 0 )
	{
		if( ( substring( $path, 1, 1) == "C" || substring( $path, 1, 1) == "c" ) ||
			( substring( $path, 1, 1) == "D" || substring( $path, 1, 1) == "d" ) ||
			( substring( $path, 1, 1) == "E" || substring( $path, 1, 1) == "e" ) )
		{
			return true;
		}
	}

	return false;
}

global proc string getDeadlineCommand()
{
	string $deadlineBin = `getenv "DEADLINE_PATH"`;
	string $deadlineCommand = "";

	if( $deadlineBin == "" && `about -macOS`)
	{
		string $deadlineBinPath = "/Users/Shared/Thinkbox/DEADLINE_PATH";
		if( $deadlineBin == "" &&`filetest -f $deadlineBinPath` )
		{
			int $fileId = fopen( $deadlineBinPath, "r" );
			string $s;
			$deadlineBin = fread( $fileId, $s );
			fclose( $fileId );
		}

		$deadlineBin = strip( $deadlineBin );
	}

	if( $deadlineBin != "" )
	{
		$deadlineBin =  $deadlineBin +"/";
	}

	if( `about -nt` )
	{
		$deadlineCommand = $deadlineBin + "deadlinecommand.exe";
	}
	else
	{
		$deadlineCommand = $deadlineBin + "deadlinecommand";
	}

	return $deadlineCommand;
}

// Calls deadlinecommand and returns the output from the command.
global proc string CallDeadlineCommand( string $command, int $showProgress )
{
	string $tempDir = `internalVar -userTmpDir`;
	string $result = "";

	if( $showProgress )
		waitCursor -state on;

	print( "running deadline command: " + $command + "\n" );

	//sets the progress bar to 33%... since we can't really adjust the bar while it's loading
	if( $showProgress && `progressBar -exists frw_progBar` )
		progressBar -edit -progress (`progressBar -query -maxValue frw_progBar` / 3) frw_progBar;

	string $deadlineCommand = getDeadlineCommand();
	string $deadlineCommandString = "";

	string $prevPath = "";
	if( `about -macOS` )
	{
		$deadlineCommandString = "\""+$deadlineCommand + "\" 2> /dev/null";
		$deadlineCommandString = $deadlineCommandString + " " + $command;
	}
	else if( `about -nt` )
	{
		$deadlineBin = `getenv "DEADLINE_PATH"`;
		$deadlineCommandString = "call \"" + $deadlineCommand + "\" " + $command + " 2> nul";

		//Need to set the PATH, cuz windows 8 seems to load DLLs from the PATH earlier that cwd....
		$prevPath = `getenv "PATH"`;
		string $newPath = dirname( $deadlineCommand )+ ";" + $prevPath;
		putenv "PATH" $newPath;
	}
	else
	{
		$deadlineCommandString = "\"" + $deadlineCommand+ "\" " + $command + " 2> /dev/null";
	}

	$result = system( $deadlineCommandString );

	if( `about -nt` )
	{
		//restore the old PATH
		putenv "PATH" $prevPath;
	}

	$result = substituteAllString( $result, "\r", "" );

	//sets the progress bar to max (since we finished)
	if( $showProgress && `progressBar -exists frw_progBar` )
		progressBar -edit -progress `progressBar -query -maxValue frw_progBar` frw_progBar;

	string $resultArray[];
	$resultArray = stringToStringArray( $result, "\n" );
	//if( size($resultArray) > 2 && startsWith( $resultArray[2], "UNC paths are not supported." ) )
	if( size($resultArray) > 2 && ( startsWith( $resultArray[0], "'\\\\" ) || startsWith( $resultArray[0], "'//" ) ) )
	{
		int $tempResultArraySize = size($resultArray) - 3;
		string $tempResultArray[];
		for( $i = 0; $i < $tempResultArraySize; $i++ )
			$tempResultArray[$i] = $resultArray[$i+3];
		$result = stringArrayToString( $tempResultArray, "\n" );
	}

	if( endsWith( $result, "\n" ) )
		$result = substring( $result, 1, size( $result ) - 1 );

	if( $showProgress )
		waitCursor -state off;

	return $result;
}

// Quickly finds the intersection of two string arrays
global proc string[] IntersectTwoStringArray(string $firstArr[], string $secondArr[] )
{
	string $getSelection = `stringArrayIntersector`;
	stringArrayIntersector -edit -intersect $firstArr $getSelection;
	stringArrayIntersector -edit -intersect $secondArr $getSelection;

	string $intersect[] = (`stringArrayIntersector -query $getSelection`); // This is all of the selected *Geometry*
	deleteUI $getSelection;

	return $intersect;
}

global proc string GetRenderLayerDisplayName( string $layer )
{
	string $renderLayerName = $layer;

	if( $layer == "defaultRenderLayer" )
	{
		$renderLayerName = "masterLayer";
	}

	if( `exists renderLayerDisplayName`)
	{
		$renderLayerName = `renderLayerDisplayName $layer`;
	}

	return $renderLayerName;
}

//---------------------------------------------------------
// Functions for saving submission dialog options.
//---------------------------------------------------------

// Adds a string attribute.
global proc AddStringAttribute( string $attrName )
{
	if( ! `attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -dt "string" defaultRenderGlobals;
}

// Adds a long attribute.
global proc AddLongAttribute( string $attrName )
{
	if( ! `attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -at long defaultRenderGlobals;
}

// Adds a long attribute.
global proc AddFloatAttribute( string $attrName )
{
	if( ! `attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -at "float" defaultRenderGlobals;
}

//Adds a string array attribute
global proc AddStrArrayAttribute( string $attrName )
{
	if( !`attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -dt stringArray defaultRenderGlobals;
}

// Saves the persistent deadline options in the scene.
global proc SavePersistentDeadlineOptions()
{
	global string $ProjectPathGrp;
	global string $ImageOutputPathGrp;
	global string $StartupScriptPathGrp;
	global string $CompositeNamePathGrp;
	global string $MentalRayFilenameGrp;
	global string $VRayFilenameGrp;
	global string $LimitGroupGrp;
	global string $DependenciesGrp;
	global string $MachineListGrp;
	global string $JobNameGrp;

	global int $TileRegionRenderType;
	global int $JigsawRegionRenderType;

	global int $BlankImageCompType;
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;

	global int $deadlineGPUsPerTask;
	global int $deadlineGPUsSelectDevices;

	global int $irayUseCPUs;
	global float $irayCPULoad;

	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	int $compType = `optionMenuGrp -q -select frw_compositeType`;

	string $renderer = GetCurrentRenderer();
	int $renderLayersEnabled = IsRenderLayersOn();

	AddStringAttribute( "deadlineJobName" );
	setAttr defaultRenderGlobals.deadlineJobName -type "string" `textFieldGrp -q -text frw_JobName`;

	AddStringAttribute( "deadlineJobComment" );
	setAttr defaultRenderGlobals.deadlineJobComment -type "string" `textFieldGrp -q -text frw_JobComment`;

	AddStringAttribute( "deadlineDepartment" );
	setAttr defaultRenderGlobals.deadlineDepartment -type "string" `textFieldGrp -q -text frw_Department`;

	AddStringAttribute( "deadlineGroup" );
	setAttr defaultRenderGlobals.deadlineGroup -type "string" `optionMenuGrp -q -value frw_Group`;

	AddStringAttribute( "deadlineJobPool" );
	setAttr defaultRenderGlobals.deadlineJobPool -type "string" `optionMenuGrp -q -value frw_deadlinePool`;

	AddStringAttribute( "deadlineJobSecondaryPool" );
	setAttr defaultRenderGlobals.deadlineJobSecondaryPool -type "string" `optionMenuGrp -q -value frw_deadlineSecondaryPool`;

	//AddLongAttribute( "deadlineUseOnlyPool" );
	//setAttr defaultRenderGlobals.deadlineUseOnlyPool `checkBox -q -v frw_poolMachinesOnly`;

	AddLongAttribute( "deadlineJobPriority" );
	setAttr defaultRenderGlobals.deadlineJobPriority `intSliderGrp -q -v frw_JobPriority`;

	AddLongAttribute( "deadlineLimitCount" );
	setAttr defaultRenderGlobals.deadlineLimitCount `intSliderGrp -q -v frw_LimitCount`;

	AddLongAttribute( "deadlineConcurrentTasks" );
	setAttr defaultRenderGlobals.deadlineConcurrentTasks `intSliderGrp -q -v frw_ConcurrentTasks`;

	AddLongAttribute( "deadlineSlaveTimeout" );
	setAttr defaultRenderGlobals.deadlineSlaveTimeout `intSliderGrp -q -v frw_SlaveTimeout`;

	AddLongAttribute( "deadlineMinSlaveTimeout" );
	setAttr defaultRenderGlobals.deadlineMinSlaveTimeout `intSliderGrp -q -v frw_MinSlaveTimeout`;

	AddLongAttribute( "deadlineAutoTaskTimeout" );
	setAttr defaultRenderGlobals.deadlineAutoTaskTimeout `checkBox -q -v frw_AutoTaskTimeout`;

	AddStringAttribute( "deadlineLimitGroups" );
	setAttr defaultRenderGlobals.deadlineLimitGroups -type "string" `textFieldGrp -q -text frw_limitGroups`;

	AddStringAttribute( "deadlineMachineList" );
	setAttr defaultRenderGlobals.deadlineMachineList -type "string" `textFieldGrp -q -text frw_machineList`;

	AddLongAttribute( "deadlineIsBlacklist" );
	setAttr defaultRenderGlobals.deadlineIsBlacklist `checkBox -q -v frw_isBlacklist`;

	AddLongAttribute( "deadlineSubmitAsSuspended" );
	setAttr defaultRenderGlobals.deadlineSubmitAsSuspended `checkBox -q -v frw_submitAsSuspended`;

	AddLongAttribute( "deadlineCloseOnSubmission" );
	setAttr defaultRenderGlobals.deadlineCloseOnSubmission `checkBox -q -v frw_closeOnSubmission`;

	//AddLongAttribute( "deadlineDeleteOnComplete" );
	//setAttr defaultRenderGlobals.deadlineDeleteOnComplete `checkBox -q -v frw_deleteOnComplete`;

	AddLongAttribute( "deadlineChunkSize" );
	setAttr defaultRenderGlobals.deadlineChunkSize `intSliderGrp -q -v frw_FrameGroup`;

	//AddStringAttribute( "deadlineOutputFilePath" );
	//setAttr defaultRenderGlobals.deadlineOutputFilePath -type "string" `textFieldButtonGrp -q -fiame $ImageOutputPathGrp`;

	AddLongAttribute( "deadlineSubmitMayaScene" );
	setAttr defaultRenderGlobals.deadlineSubmitMayaScene `checkBox -q -v frw_submitMayaScene`;

	//AddStringAttribute( "deadlineProjectPathOverride" );
	//setAttr defaultRenderGlobals.deadlineProjectPathOverride -type "string" `textFieldButtonGrp -q -text $ProjectPathGrp`;

	AddLongAttribute( "deadlineNumCPUs" );
	if( EnableCpuOption( $renderer ) )
		setAttr defaultRenderGlobals.deadlineNumCPUs `intSliderGrp -q -v frw_MaxCPUs`;

	AddLongAttribute( "deadlineSubmitEachRenderLayer" );
	if( $renderLayersEnabled )
		setAttr defaultRenderGlobals.deadlineSubmitEachRenderLayer `checkBox -q -v frw_submitEachRenderLayer`;

	AddLongAttribute( "deadlineOverrideLayerSettings" );
	if( $renderLayersEnabled )
		setAttr defaultRenderGlobals.deadlineOverrideLayerSettings `checkBox -q -v frw_overrideLayerSettings`;

	AddLongAttribute( "deadlineSubmitEachCamera" );
	setAttr defaultRenderGlobals.deadlineSubmitEachCamera `checkBox -q -v frw_submitEachCamera`;

	AddLongAttribute( "deadlineIgnoreDefaultCameras" );
	setAttr defaultRenderGlobals.deadlineIgnoreDefaultCameras `checkBox -q -v frw_ignoreDefaultCameras`;

	AddLongAttribute( "deadlineUseMayaBatchPlugin" );
	setAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin `checkBox -q -v frw_useMayaBatchPlugin`;

	AddLongAttribute( "deadlineUseLocalAssetCaching" );
	setAttr defaultRenderGlobals.deadlineUseLocalAssetCaching `checkBox -q -v frw_useLocalAssetCaching`;

	AddLongAttribute( "deadlineStrictErrorChecking" );
	setAttr defaultRenderGlobals.deadlineStrictErrorChecking `checkBox -q -v frw_strictErrorChecking`;

	AddLongAttribute( "deadlineLocalRendering" );
	setAttr defaultRenderGlobals.deadlineLocalRendering `checkBox -q -v frw_localRendering`;

	AddStringAttribute( "deadlineStartupScript" );
	setAttr defaultRenderGlobals.deadlineStartupScript -type "string" `textFieldGrp -q -text frw_startupScript`;

	AddStringAttribute( "deadlineMayaArgs" );
	setAttr defaultRenderGlobals.deadlineMayaArgs -type "string" `textFieldGrp -q -text frw_mayaArgs`;

	AddLongAttribute( "deadlineTilesInX" );
	setAttr defaultRenderGlobals.deadlineTilesInX `intSliderGrp -q -v frw_tilesInX`;

	AddLongAttribute( "deadlineTilesInY" );
	setAttr defaultRenderGlobals.deadlineTilesInY `intSliderGrp -q -v frw_tilesInY`;

	AddLongAttribute( "deadlineTileSingleJob" );
	setAttr defaultRenderGlobals.deadlineTileSingleJob `checkBox -q -v frw_submitTileSingleJob`;

	AddLongAttribute( "deadlineTileDependentJob" );
	setAttr defaultRenderGlobals.deadlineTileDependentJob `checkBox -q -v frw_submitTileDependentJob`;

	AddLongAttribute( "deadlineTileCleanupJob" );
	setAttr defaultRenderGlobals.deadlineTileCleanupJob `checkBox -q -v frw_submitTileCleanupJob`;

	AddLongAttribute( "deadlineTileErrorOnMissing" );
	setAttr defaultRenderGlobals.deadlineTileErrorOnMissing `checkBox -q -v frw_submitTileErrorOnMissing`;

	AddLongAttribute( "tileMissingBackground" );
	setAttr defaultRenderGlobals.tileMissingBackground `checkBox -q -v frw_submitTileErrorOnMissingBackground`;

	AddStringAttribute( "deadlineMentalRayFilename" );
	setAttr defaultRenderGlobals.deadlineMentalRayFilename -type "string" `textFieldButtonGrp -q -text $MentalRayFilenameGrp`;

	AddLongAttribute( "deadlineSubmitMentalRayJob" );
	setAttr defaultRenderGlobals.deadlineSubmitMentalRayJob `checkBox -q -v frw_submitMentalRayJob`;

	AddLongAttribute( "deadlineMentalRayThreads" );
	setAttr defaultRenderGlobals.deadlineMentalRayThreads `intSliderGrp -q -v frw_mentalRayThreads`;

	AddLongAttribute( "deadlineMentalRayOffset" );
	setAttr defaultRenderGlobals.deadlineMentalRayOffset `intSliderGrp -q -v frw_mentalRayOffset`;

	AddLongAttribute( "deadlineMentalRayLocalRendering" );
	setAttr defaultRenderGlobals.deadlineMentalRayLocalRendering `checkBox -q -v frw_mentalRayLocalRendering`;

	AddStringAttribute( "deadlineMentalRayArgs" );
	setAttr defaultRenderGlobals.deadlineMentalRayArgs -type "string" `textFieldGrp -q -text frw_mentalRayArgs`;

	AddStringAttribute( "deadlineVRayFilename" );
	setAttr defaultRenderGlobals.deadlineVRayFilename -type "string" `textFieldButtonGrp -q -text $VRayFilenameGrp`;

	AddLongAttribute( "deadlineSubmitVRayJob" );
	setAttr defaultRenderGlobals.deadlineSubmitVRayJob `checkBox -q -v frw_submitVRayJob`;

	AddLongAttribute( "deadlineVRayThreads" );
	setAttr defaultRenderGlobals.deadlineVRayThreads `intSliderGrp -q -v frw_vrayThreads`;

	AddLongAttribute( "deadlineSubmitVrimg2ExrJob" );
	setAttr defaultRenderGlobals.deadlineSubmitVrimg2ExrJob `checkBox -q -v frw_submitVrimg2ExrJob`;

	AddLongAttribute( "deadlineDeleteVrimgFiles" );
	setAttr defaultRenderGlobals.deadlineDeleteVrimgFiles `checkBox -q -v frw_deleteVrimgFiles`;

	AddLongAttribute( "deadlineExportRenderManThreads" );
	setAttr defaultRenderGlobals.deadlineExportRenderManThreads `intSliderGrp -q -v frw_exportRenderManThreads`;

	AddLongAttribute( "deadlineRenderRenderManWithRis" );
	setAttr defaultRenderGlobals.deadlineExportRenderManThreads `checkBox -q -v frw_renderRenderManWithRis`;

	AddLongAttribute( "deadlineSubmitRenderManJob" );
	setAttr defaultRenderGlobals.deadlineSubmitRenderManJob `checkBox -q -v frw_submitRenderManJob`;

	AddLongAttribute( "deadlineRenderManFrameDependent" );
	setAttr defaultRenderGlobals.deadlineRenderManFrameDependent `checkBox -q -v frw_renderManFrameDependent`;

	AddLongAttribute( "deadlineRenderManThreads" );
	setAttr defaultRenderGlobals.deadlineRenderManThreads `intSliderGrp -q -v frw_rendermanThreads`;

	AddStringAttribute( "deadlineRenderManArgs" );
	setAttr defaultRenderGlobals.deadlineRenderManArgs -type "string" `textFieldGrp -q -text frw_rendermanArgs`;

	AddLongAttribute( "deadlineSubmitArnoldJob" );
	setAttr defaultRenderGlobals.deadlineSubmitArnoldJob `checkBox -q -v frw_submitArnoldJob`;

	AddLongAttribute( "deadlineExportArnoldLocal" );
	setAttr defaultRenderGlobals.deadlineExportArnoldLocal `checkBox -q -v frw_exportArnoldLocal`;

	AddLongAttribute( "deadlineArnoldThreads" );
	setAttr defaultRenderGlobals.deadlineArnoldThreads `intSliderGrp -q -v frw_arnoldThreads`;

	AddStringAttribute( "deadlineArnoldArgs" );
	setAttr defaultRenderGlobals.deadlineArnoldArgs -type "string" `textFieldGrp -q -text frw_arnoldArgs`;

	AddLongAttribute( "deadlineSubmitMaxwellJob" );
	setAttr defaultRenderGlobals.deadlineSubmitMaxwellJob `checkBox -q -v frw_submitMaxwellJob`;

	AddLongAttribute( "deadlineSubmitRedshiftJob" );
	setAttr defaultRenderGlobals.deadlineSubmitRedshiftJob `checkBox -q -v frw_submitRedshiftJob`;

	AddLongAttribute( "deadlineExportRedshiftLocal" );
	setAttr defaultRenderGlobals.deadlineExportRedshiftLocal `checkBox -q -v frw_exportRedshiftLocal`;

	AddLongAttribute( "deadlineRedshiftFrameDependent" );
	setAttr defaultRenderGlobals.deadlineRedshiftFrameDependent `checkBox -q -v frw_redshiftFrameDependent`;

	AddLongAttribute( "deadlineRedshiftLayerSubmission" );
	setAttr defaultRenderGlobals.deadlineRedshiftLayerSubmission `checkBox -q -v frw_redshiftLayerSubmission`;

	AddLongAttribute( "deadlineRedshiftThreads" );
	setAttr defaultRenderGlobals.deadlineRedshiftThreads `intSliderGrp -q -v frw_redshiftThreads`;

	AddStringAttribute( "deadlineRedshiftArgs" );
	setAttr defaultRenderGlobals.deadlineRedshiftArgs -type "string" `textFieldGrp -q -text frw_redshiftArgs`;

	AddLongAttribute( "deadlineExportMaxwellLocal" );
	setAttr defaultRenderGlobals.deadlineExportMaxwellLocal `checkBox -q -v frw_exportMaxwellLocal`;

	AddLongAttribute( "deadlineMaxwellThreads" );
	setAttr defaultRenderGlobals.deadlineMaxwellThreads `intSliderGrp -q -v frw_maxwellThreads`;

	AddStringAttribute( "deadlineMaxwellArgs" );
	setAttr defaultRenderGlobals.deadlineMaxwellArgs -type "string" `textFieldGrp -q -text frw_maxwellArgs`;

	// Enable or disable some options based on current values.
	int $useMayaBatchPlugin = `checkBox -q -v frw_useMayaBatchPlugin`;
	int $submitMayaScene = `checkBox -q -v frw_submitMayaScene`;
	textFieldGrp -edit -enable $useMayaBatchPlugin frw_startupScript;
	textFieldGrp -edit -enable (!$useMayaBatchPlugin) frw_mayaArgs;
	checkBox -edit -enable (!$useMayaBatchPlugin) frw_ignoreError211;
	checkBox -edit -enable ($useMayaBatchPlugin) frw_useLocalAssetCaching;

	if( $renderer == "mentalRay" )
	{
		AddLongAttribute( "deadlineMentalRayAutoMemoryLimit" );
		setAttr defaultRenderGlobals.deadlineMentalRayAutoMemoryLimit `checkBox -q -v frw_autoMemoryLimit`;

		AddLongAttribute( "deadlineMentalRayMemoryLimit" );
		setAttr defaultRenderGlobals.deadlineMentalRayMemoryLimit `intSliderGrp -q -v frw_memoryLimit`;

		int $autoMemoryLimit = `checkBox -q -v frw_autoMemoryLimit`;
		intSliderGrp -edit -enable (!$autoMemoryLimit) frw_memoryLimit;
	}

	if( $renderer == "redshift" || $renderer == "ifmIrayPhotoreal" || $renderer == "octaneRender"  )
	{
		AddLongAttribute( "deadlineGPUsPerTask" );
		setAttr defaultRenderGlobals.deadlineGPUsPerTask `intSliderGrp -q -v frw_deadlineGPUsPerTask`;

		string $deadlineGPUsSelectDevices = `textFieldGrp -q -text frw_deadlineGPUsSelectDevices`;
		intSliderGrp -edit -enable (strcmp($deadlineGPUsSelectDevices, "") == 0) frw_deadlineGPUsPerTask;

		AddStringAttribute( "deadlineGPUsSelectDevices" );
		setAttr defaultRenderGlobals.deadlineGPUsSelectDevices -type "string" `textFieldGrp -q -text frw_deadlineGPUsSelectDevices`;

		int $deadlineGPUsPerTask = `intSliderGrp -q -v frw_deadlineGPUsPerTask`;
		textFieldGrp -edit -enable ($deadlineGPUsPerTask == 0) frw_deadlineGPUsSelectDevices;
	}

	if( $renderer == "vray" )
	{
		AddLongAttribute( "deadlineVrayAutoMemoryEnabled" );
		setAttr defaultRenderGlobals.deadlineVrayAutoMemoryEnabled `checkBox -q -v frw_vrayAutoMemoryEnabled`;

		AddLongAttribute( "deadlineVrayAutoMemoryBuffer" );
		setAttr defaultRenderGlobals.deadlineVrayAutoMemoryBuffer `intSliderGrp -q -v frw_vrayAutoMemoryBuffer`;

		checkBox -edit -enable $useMayaBatchPlugin frw_vrayAutoMemoryEnabled;

		int $vrayAutoMemoryEnabled = `checkBox -q -v frw_vrayAutoMemoryEnabled`;
		intSliderGrp -edit -enable ($useMayaBatchPlugin && $vrayAutoMemoryEnabled) frw_vrayAutoMemoryBuffer;
	}

	if( $renderer == "ifmIrayPhotoreal" )
	{
		AddLongAttribute( "deadlineIRayUseCPUs" );
		setAttr defaultRenderGlobals.deadlineIRayUseCPUs `checkBox -q -v frw_irayUseCPUs`;

		int $iraySelectUseCPUs = `checkBox -q -v frw_irayUseCPUs`;

		AddFloatAttribute( "deadlineIRayCPULoad" );
		setAttr defaultRenderGlobals.deadlineIRayCPULoad  `floatSliderGrp -q -v frw_irayCPULoad`;

		floatSliderGrp -edit -enable $iraySelectUseCPUs frw_irayCPULoad;

	}

	int $regionRendering = `checkBox -q -v frw_regionRendering`;
	int $animationEnabled = IsAnimatedOn();
	if( $renderLayersEnabled )
	{
		int $submitEachRenderLayer = `checkBox -q -v frw_submitEachRenderLayer`;
		checkBox -edit -enable $submitEachRenderLayer frw_regionRendering;
		checkBox -edit -enable $submitEachRenderLayer frw_overrideLayerSettings;

		int $layerOverride = `checkBox -q -v frw_overrideLayerSettings`;

		if( $submitEachRenderLayer )
			textFieldGrp -edit -enable ($animationEnabled && $layerOverride) frw_FrameList;
		else
			textFieldGrp -edit -enable $animationEnabled frw_FrameList;

		if( !$submitEachRenderLayer && $regionRendering )
		{
		   $regionRendering = false;
		   checkBox -edit -v $regionRendering frw_regionRendering;
		}
	}
	else
		textFieldGrp -edit -enable $animationEnabled frw_FrameList;

	int $submitEachCamera = `checkBox -q -v frw_submitEachCamera`;
	checkBox -edit -enable $submitEachCamera frw_ignoreDefaultCameras;
	rowLayout -edit -visible ($regionType == $JigsawRegionRenderType) frw_jigsawRenderLayout;
	columnLayout -edit -visible ($regionType == $TileRegionRenderType) frw_tileRenderLayout;
	button -edit -enable $regionRendering frw_openJigsaw;
	text -edit -enable $regionRendering frw_jigsawLabel;
	intSliderGrp -edit -enable $regionRendering frw_tilesInX;
	intSliderGrp -edit -enable $regionRendering frw_tilesInY;

	checkBox -edit -enable $regionRendering frw_submitTileSingleJob;

	int $singleRegionRendering = `checkBox -q -v frw_submitTileSingleJob`;
	int $assemblyRendering = `checkBox -q -v frw_submitTileDependentJob`;

	//checkBox -edit -enable frw_submitTileSingleJob;
	intSliderGrp -edit -enable ($regionRendering && ($singleRegionRendering)) frw_tileSingleFrame;
	checkBox -edit -enable $regionRendering frw_submitTileDependentJob;
	checkBox -edit -enable ($regionRendering && $assemblyRendering && $regionType == $JigsawRegionRenderType) frw_submitTileErrorOnMissing;
	checkBox -edit -enable ($regionRendering && $assemblyRendering) frw_submitTileCleanupJob;

	optionMenuGrp -edit -enable ($regionRendering && $regionType == $JigsawRegionRenderType && $assemblyRendering) frw_compositeType;
	checkBox -edit -enable ($regionRendering && $compType != $BlankImageCompType && $regionType == $JigsawRegionRenderType && $assemblyRendering) frw_submitTileErrorOnMissingBackground;
	textFieldButtonGrp -edit -enable ($regionRendering && $compType != $BlankImageCompType && $regionType == $JigsawRegionRenderType && $assemblyRendering) frw_submitTileCompositeOverName;

	checkBox -edit -enable $animationEnabled frw_renderPreviewJobFirst;
	int $previewEnabled = `checkBox -q -v frw_renderPreviewJobFirst`;
	checkBox -edit -enable ($previewEnabled && $animationEnabled) frw_dependent;
	intSliderGrp -edit -enable ($previewEnabled && $animationEnabled) frw_PreviewFrames;
	intSliderGrp -edit -enable ($previewEnabled && $animationEnabled) frw_PreviewPriority;

	string $taskOrder = `optionMenuGrp -q -value frw_taskOrder`;

	int $outOfOrderStepEnabled = (strcmp($taskOrder, "Every Nth, Then Forward") == 0) || (strcmp($taskOrder, "Every Nth - Block Fill") == 0) || (strcmp($taskOrder,"Every Nth - Half Raster Refine") == 0);
	intSliderGrp -edit -enable $outOfOrderStepEnabled frw_taskOrderStep;

	int $submitVrayJob = `checkBox -q -v frw_submitVRayJob`;
	checkBox -edit -enable $submitVrayJob  frw_submitVrimg2ExrJob;
	checkBox -edit -enable $submitVrayJob  frw_deleteVrimgFiles;

	int $maxwellCoopRender = `checkBox -q -v frw_maxwellCooperativeRendering`;
	int $maxwellAutoMergeFiles = `checkBox -q -v frw_maxwellAutoMergeFiles`;

	text -edit -enable $maxwellCoopRender frw_maxwellNumCoopRendersLabel;
	intField -edit -enable $maxwellCoopRender frw_maxwellNumCoopRenders;
	checkBox -edit -enable $maxwellCoopRender frw_maxwellCoopSeparateJobs;
	checkBox -edit -enable $maxwellCoopRender frw_maxwellAutoMergeFiles;
	checkBox -edit -enable $maxwellCoopRender frw_maxwellMissingIntermediate;
	checkBox -edit -enable $maxwellCoopRender frw_maxwellDeleteIntermediate;

	if( $maxwellCoopRender )
	{
		checkBox -edit -enable $maxwellAutoMergeFiles frw_maxwellMissingIntermediate;
		checkBox -edit -enable $maxwellAutoMergeFiles frw_maxwellDeleteIntermediate;
	}

	int $subFramesEnabled = `checkBox -q -v frw_abcSubFrameCheck`;

	floatSliderGrp -edit -enable $subFramesEnabled frw_abcLowSubFrameCheck;
	floatSliderGrp -edit -enable $subFramesEnabled frw_abcHighSubFrameCheck;

}

global proc UpdateRegionRenderType()
{
	global int $JigsawRegionRenderType;
	global int $TileRegionRenderType;

	int $jobType = `optionMenuGrp -q -select frw_regionRenderType`;

	rowLayout -edit -enable ($jobType == $JigsawRegionRenderType) frw_jigsawRenderLayout;
	columnLayout -edit -enable ($jobType == $TileRegionRenderType) frw_tileRenderLayout;
	SavePersistentDeadlineOptions();
}

global proc UpdateCompositeType()
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;

	int $compType = `optionMenuGrp -q -select frw_compositeType`;

	rowLayout -edit -enable ($compType == $SelectedImageCompType) frw_compLayout;
	SavePersistentDeadlineOptions();
}

global proc UpdateJobType()
{
	global string $MayaRenderOptionsRollout;
	global string $MayaRenderOptionsArnoldRollout;
	global string $MayaRenderOptionsMentalRayRollout;
	global string $MayaRenderOptionsRedshiftRollout;
	global string $MayaRenderOptionsIRayRollout;
	global string $MayaRenderOptionsVRayRollout;
	global string $MayaRenderOptionsTileRollout;
	global string $MentalRayExportRollout;
	global string $MentalRayExportRenderJobRollout;
	global string $VrayExportRollout;
	global string $VrayExportRenderJobRollout;
	global string $VrayExportVrimgJobRollout;
	global string $RendermanExportRollout;
	global string $RendermanExportRenderJobRollout;
	global string $ArnoldExportRollout;
	global string $ArnoldExportRenderJobRollout;
	global string $MaxwellExportRollout;
	global string $MaxwellExportRenderJobRollout;
	global string $MaxwellExportCoopOptionsRollout;
	global string $RedshiftExportRollout;
	global string $RedshiftExportRenderJobRollout;
	global string $BifrostSimulationJobRollout;
	global string $AlembicExportJobRollout;
	global string $AlembicAdvancedOptionsJobRollout;
	global string $MayaScriptJobRollout;
	global string $FluidCachingJobRollout;
	global string $GeometryCachingJobRollout;

	global int $MayaRenderJobType;
	global int $MentalRayExportJobType;
	global int $VRayExportJobType;
	global int $RendermanExportJobType;
	global int $ArnoldExportJobType;
	global int $MaxwellExportJobType;
	global int $RedshiftExportJobType;

	global int $BifrostSimulationJobType;
	global int $AlembicExportJobType;
	global int $MayaScriptJobType;
	global int $FluidCachingJobType;
	global int $GeometryCachingJobType;

	int $jobType = `optionMenuGrp -q -select frw_mayaJobType`;
	string $renderer = GetCurrentRenderer();

	frameLayout -edit -visible ($jobType == $MayaRenderJobType) $MayaRenderOptionsRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "arnold") $MayaRenderOptionsArnoldRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "mentalRay") $MayaRenderOptionsMentalRayRollout;
	frameLayout -edit -visible ( ($jobType == $MayaRenderJobType && $renderer == "redshift") || $jobType == $RedshiftExportJobType ) $MayaRenderOptionsRedshiftRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "vray") $MayaRenderOptionsVRayRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "ifmIrayPhotoreal") $MayaRenderOptionsIRayRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType || $jobType == $ArnoldExportJobType ) $MayaRenderOptionsTileRollout;

	frameLayout -edit -visible ($jobType == $MentalRayExportJobType ) $MentalRayExportRollout;
	frameLayout -edit -visible ($jobType == $MentalRayExportJobType ) $MentalRayExportRenderJobRollout;

	frameLayout -edit -visible ($jobType == $VRayExportJobType ) $VrayExportRollout;
	frameLayout -edit -visible ($jobType == $VRayExportJobType ) $VrayExportRenderJobRollout;
	frameLayout -edit -visible ($jobType == $VRayExportJobType ) $VrayExportVrimgJobRollout;

	frameLayout -edit -visible ($jobType == $RendermanExportJobType ) $RendermanExportRollout;
	frameLayout -edit -visible ($jobType == $RendermanExportJobType ) $RendermanExportRenderJobRollout;

	frameLayout -edit -visible ($jobType == $ArnoldExportJobType ) $ArnoldExportRollout;
	frameLayout -edit -visible ($jobType == $ArnoldExportJobType ) $ArnoldExportRenderJobRollout;

	frameLayout -edit -visible ($jobType == $MaxwellExportJobType ) $MaxwellExportRollout;
	frameLayout -edit -visible ($jobType == $MaxwellExportJobType ) $MaxwellExportRenderJobRollout;
	frameLayout -edit -visible ($jobType == $MaxwellExportJobType ) $MaxwellExportCoopOptionsRollout;

	frameLayout -edit -visible ($jobType == $BifrostSimulationJobType) $BifrostSimulationJobRollout;

	frameLayout -edit -visible ($jobType == $AlembicExportJobType) $AlembicExportJobRollout;
	frameLayout -edit -visible ($jobType == $AlembicExportJobType) $AlembicAdvancedOptionsJobRollout;

	frameLayout -edit -visible ($jobType == $MayaScriptJobType) $MayaScriptJobRollout;

	frameLayout -edit -visible ($jobType == $FluidCachingJobType) $FluidCachingJobRollout;

	frameLayout -edit -visible ($jobType == $GeometryCachingJobType) $GeometryCachingJobRollout;

	frameLayout -edit -visible ($jobType == $RedshiftExportJobType ) $RedshiftExportRollout;
	frameLayout -edit -visible ($jobType == $RedshiftExportJobType ) $RedshiftExportRenderJobRollout;

	optionMenuGrp -edit -en ($jobType != $RedshiftExportJobType ) frw_redshiftVerbose;
	if ($jobType == $RedshiftExportJobType)
	{
		checkBox -edit -v true frw_useMayaBatchPlugin;
	}
	checkBox -edit -en ($jobType  != $RedshiftExportJobType) frw_useMayaBatchPlugin;
}

//---------------------------------------------------------
// Functions for job submission.
//---------------------------------------------------------

proc int[] removeDuplicateIntegers(int $array[])
{
	int $index = 0;
	int $newarray[];
	for( $i = 0 ; $i < size($array) ; $i++ )
	{
		$entry = true;
		for( $j = 0 ; $j < $i ; $j++ )
		{
			if( $array[$i] == $array[$j] ) //duplicate
			{
				$entry = false;
			}
		}
		if( $entry == true )
		{
			$newarray[$index] = $array[$i];
			$index++;
		}
	}
	return $newarray;
}

proc int[] GetFramesArray(string $frameString)
{
	string $frameArray[];
	// Removing all whitespace from the framestring so that everything is in a predictable ordering.
	$frameString = substituteAllString($frameString, " ", "");

	//splitting the frame string into groups separated by commas
	int $numTokens = `tokenize $frameString "," $frameArray`;
	int $frames[] = {};
	for( $i = 0; $i<$numTokens; $i++ )
	{
		//Example  $FramesArray[$i] being "-6--4x2"
		//Pull the frame step from the grouping
		int $step = 1;
		string $stepArray[];
		tokenize $frameArray[$i] "x" $stepArray;
		//Example  $stepArray = { "-6--4", "2" }
		if( `size($stepArray)` > 1 )
		{
			$step = int($stepArray[1]);
		}
		//Example  $step = 2

		//Split the remaining info on -'s this will allow us to handle ranges yet will remove any negatives so we have to handle those
		string $startStopArray[];
		tokenize $stepArray[0] "-" $startStopArray;
		//Example  $startStopArray = { "6", "4" }
		int $start = $startStopArray[0];
		//Example  $start = 6
		//if the first value is negative set it to negative
		if( startsWith( $stepArray[0], "-") )
		{
			$start = $start * -1;
		}
		//Example  $start = -6
		int $stop = $start;
		//Example  $stop = -6
		//If it is a range get the value and then test if it is negative
		if( `size($startStopArray)` > 1 )
		{
			$stop = $startStopArray[1];
			//Example  $stop = 4
			string $startPart = $start+"-";
			//Example  $startPart = "-6-"
			string $stopPart = substring( $stepArray[0], size( $startPart ) + 1, size( $stepArray[0] ) );
			//Example  $stopPart = "-4"
			if( startsWith( $stopPart, "-") )
			{
				$stop = $stop * -1;
			}
			//Example  $stop = -4

		}

		for($f = $start; $f<=$stop;$f+=$step)
		{
			$frames[size($frames)] = $f;
		}
	}

	return removeDuplicateIntegers($frames);
}

proc int[] ApplyOutOfOrder(int $frames[])
{
	string $taskOrder = `optionMenuGrp -q -value frw_taskOrder`;
	int $taskStep = `intSliderGrp -q -v frw_taskOrderStep`;

	if( strcmp($taskOrder, "Every Nth, Then Forward") == 0 )
	{
		int $tempFramesBefore[] = {};
		int $tempFramesAfter[] = {};
		int $frameCount = size($frames);
		for ($i = 0; $i < $frameCount; $i++)
		{
			if($i % $taskStep == 0)
				$tempFramesBefore[size($tempFramesBefore)] = $frames[$i];
			else
				$tempFramesAfter[size($tempFramesAfter)] = $frames[$i];
		}

		for ($i = 0; $i < size($tempFramesAfter); $i++)
		{
			$tempFramesBefore[size($tempFramesBefore)] = $tempFramesAfter[$i];
		}

		$frames = $tempFramesBefore;
	}
	else if(strcmp($taskOrder, "Every Nth - Block Fill" ) == 0)
	{
		int $newFrames[] = {};
		int $frameCount = size($frames);
		int $blockSize = $frameCount/$taskStep;

		for($i=0; $i < $blockSize; $i++)
		{
			for($j=0; $j < $taskStep; $j++)
			{
				int $index = ($j * $blockSize) + $i;
				$newFrames[size($newFrames)] = $frames[$index];
			}
		}

		if(size($frames) > size($newFrames))
		{
			// Check that no elements have been missed
			for($i=0; $i < size($frames); $i++)
			{
				int $found = 0;
				for($j = 0; $j < size($newFrames); $j++)
				{
					if($newFrames[$j] == $frames[$i])
						$found = 1;

				}
				if($found == 0)
					$newFrames[size($newFrames)] = $frames[$i];
			}
		}

		$frames = $newFrames;
	}
	else if(strcmp($taskOrder, "Every Nth - Half Raster Refine" ) == 0)
	{
		int $newFrames[] = {};
		int $frameCount = size($frames);
		int $step = $taskStep;

		while($step > 1)
		{
			for($i=0; $i < size($frames); $i+=$step)
			{
				int $found = 0;
				for($j = 0; $j < size($newFrames); $j++)
				{
					if($newFrames[$j] == $frames[$i])
					{
						$found = 1;
					}
				}

				if($found == 0)
				{
					$newFrames[size($newFrames)] = $frames[$i];
				}

			}
			$step = $step / 2;
		}
		if(size($frames) > size($newFrames))
		{
			// Check that no elements have been missed
			for($i=0; $i < size($frames); $i++)
			{
				int $found = 0;
				for($j = 0; $j < size($newFrames); $j++)
				{
					if($newFrames[$j] == $frames[$i])
						$found = 1;

				}
				if($found == 0)
					$newFrames[size($newFrames)] = $frames[$i];
			}
		}

		$frames = $newFrames;
	}
	else if(strcmp($taskOrder, "Last To First (Reverse)" ) == 0)
	{
		int $newFrames[] = {};
		for($i=(size($frames)-1); $i >= 0; $i--)
		{
			$newFrames[size($newFrames)] = $frames[$i];
		}

		$frames = $newFrames;
	}
	else if(strcmp($taskOrder, "First And Last Frames First" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			$newFrames[size($newFrames)] = $frames[0];
			$newFrames[size($newFrames)] = $frames[(size($frames) - 1)];

			for($i=1; $i < (size($frames) - 1); $i++)
			{
				$newFrames[size($newFrames)] = $frames[$i];
			}

			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "From Both Ends" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			int $halfSize = size($frames) / 2;
			int $back = size($frames) - 1;

			for($front = 0; $front < $halfSize; $front++)
			{

				$newFrames[size($newFrames)] = $frames[$front];
				if(!($front >= $back))
					$newFrames[size($newFrames)] = $frames[$back];

				$back--;
			}

			if(size($frames) > size($newFrames))
			{
				// Check that no elements have been missed
				for($i=0; $i < size($frames); $i++)
				{
					int $found = 0;
					for($j = 0; $j < size($newFrames); $j++)
					{
						if($newFrames[$j] == $frames[$i])
							$found = 1;

					}
					if($found == 0)
						$newFrames[size($newFrames)] = $frames[$i];
				}
			}

			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "From Center" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			int $halfSize = size($frames) / 2;
			int $back = $halfSize+1;
			while($back >= size($frames))
				$back -= 1;

			for($front = ($halfSize-1); $front >= 0 ; $front--)
			{

				$newFrames[size($newFrames)] = $frames[$front];
				if(!($front >= $back))
					$newFrames[size($newFrames)] = $frames[$back];

				$back++;
			}

			if(size($frames) > size($newFrames))
			{
				// Check that no elements have been missed
				for($i=0; $i < size($frames); $i++)
				{
					int $found = 0;
					for($j = 0; $j < size($newFrames); $j++)
					{
						if($newFrames[$j] == $frames[$i])
							$found = 1;

					}
					if($found == 0)
						$newFrames[size($newFrames)] = $frames[$i];
				}
			}

			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "From Both Ends And From Center" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			int $theSize = size($frames);
			int $halfSize = $theSize / 2;

			int $front = 0;
			int $back = $theSize - 1;
			int $middleDec = $halfSize - 1;
			int $middleInc = $halfSize;

			while($front < $halfSize && $middleDec > $front && $back > $halfSize && $middleInc < $back)
			{
				$newFrames[size($newFrames)] = $frames[$front];
				$newFrames[size($newFrames)] = $frames[$back];
				$newFrames[size($newFrames)] = $frames[$middleDec];
				$newFrames[size($newFrames)] = $frames[$middleInc];

				$front++;
				$middleInc++;
				$middleDec--;
				$back--;
			}

			if(size($frames) > size($newFrames))
			{
				// Check that no elements have been missed
				for($i=0; $i < size($frames); $i++)
				{
					int $found = 0;
					for($j = 0; $j < size($newFrames); $j++)
					{
						if($newFrames[$j] == $frames[$i])
							$found = 1;

					}
					if($found == 0)
						$newFrames[size($newFrames)] = $frames[$i];
				}
			}

			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "Random" ) == 0)
	{
		int $newFrames[] = {};
		int $usedIndices[] = {};
		int $theSize = size($frames);

		int $attempts = 0;

		for($i=0; $i < $theSize; $i++)
		{
			$usedIndices[size($usedIndices)] = 0;
		}

		while(size($newFrames) < size($frames) && $attempts < 30000)
		{
			int $randIndex = rand(0, $theSize);

			if($randIndex < $theSize)
			{
				if($usedIndices[$randIndex] == 0)
				{
					$usedIndices[$randIndex] = 1;
					$newFrames[size($newFrames)] = $frames[$randIndex];
				}
			}

			$attempts++;

		}

		print("Attempts = "+$attempts+"\n");
		if($attempts < 30000)
			$frames = $newFrames;

	}

	return $frames;
}

proc string FromArrayToCommaSeparatedString(int $array[])
{
	string $result = "";

	for($i = 0; $i < (size($array) - 1); $i++)
	{
		$result = $result + $array[$i] +",";
	}
	$result = $result + $array[size($array)-1];

	return $result;
}

proc string[] getXGenFiles(  )
{
	string $xgenFiles[];
	// xgen files must be stored relative to the scene
	string $collectionNames[] = `ls -type xgmPalette`;
	string $currpath;
	int $curr = 0;
	for( $i = 0; $i < size( $collectionNames ); $i++ )
	{
		$currpath = $collectionNames[$i] + ".xfn";
		if( !size( dirname( $currpath ) ) )
		{
			$xgenFiles[ $curr++ ] = ( dirname( `file -q -sn` ) + "/" + `getAttr $currpath` );
		}
	}
	return $xgenFiles;
}

proc int[] WriteIntegrationSettings( int $fileId, int $groupBatch )
{
	global string $IntegrationInfoKeys[];
	global string $IntegrationInfoValues[];

	string $integrationSettingsFilename = "";
	int $kvpIndex = 0;
	string $batchMode = "";

	int $id = stringArrayFind( "integrationSettingsPath", 0, $IntegrationInfoKeys );
	if($id >= 0)
		$integrationSettingsFilename = $IntegrationInfoValues[$id];

	$id = stringArrayFind( "extraKVPIndex", 0, $IntegrationInfoKeys );
	if($id >= 0)
		$kvpIndex = $IntegrationInfoValues[$id];

	$id = stringArrayFind( "batchMode", 0, $IntegrationInfoKeys );
	if($id >= 0)
		$batchMode = $IntegrationInfoValues[$id];
		if( $batchMode == "True" )
			$groupBatch = true;

	if( `filetest -f $integrationSettingsFilename` )
	{
		string $data = `freadAllText $integrationSettingsFilename`;
		fprint $fileId( $data );
	}


	return {$groupBatch, $kvpIndex };
}

// Creates the submission files and submits the job to Deadline.
proc string WriteJobFilesAndSubmit( string $renderer, int $showDialog, int $regionRendering, int $jobType, string $cameraOverride )
{
	global string $DeadlineSubmitterWindow;
	global string $StartupScriptPathGrp;
	global int $MayaRenderJobType;
	global int $MentalRayExportJobType;
	global int $VRayExportJobType;
	global int $RendermanExportJobType;
	global int $ArnoldExportJobType;
	global int $MaxwellExportJobType;
	global int $BifrostSimulationJobType;
	global int $AlembicExportJobType;
	global int $MayaScriptJobType;
	global int $FluidCachingJobType;
	global int $GeometryCachingJobType;
	global int $RedshiftExportJobType;

	global int $TileRegionRenderType;
	global int $JigsawRegionRenderType;

	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;

	// Get the deadline temp directory.
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";

	string $priorityQuery = CallDeadlineCommand( "-getmaximumpriority", false );
	int $maximumPriority = (int) $priorityQuery;
	if( $maximumPriority == 0 )
	{
		$maximumPriority = 100;
	}

	// Get the output file path and prefix.
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );

	string $mentalRayFilename = CheckSlashes( `textFieldGrp -q -text frw_mentalRayFilePath` );
	string $vrayFilename = CheckSlashes( `textFieldGrp -q -text frw_vrayFilePath` );

	// Get some initial settings.
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;

	$overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings`;

	// Append the render layer name to the job name if the submit each render layer check is on.
	string $currentRenderLayer = "";
	int $submitEachRenderLayer = false;
	if( IsRenderLayersOn() )
	{
		$submitEachRenderLayer = `checkBox -q -value frw_submitEachRenderLayer`;
		$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;

		if( $jobType == $MayaRenderJobType && $submitEachRenderLayer )
		{
			if($overrideLayerSettings)
			{
				$jobField = "frw_JobName_" + $currentRenderLayer;
				$jobName = `textFieldGrp -q -text $jobField`;
			}
			else
			{
				$jobName += " - " + $currentRenderLayer;
			}

			int $range[] = GetFrameRange();
			int $fromFrame = $range[0];
			int $toFrame = $range[1];
			int $byFrame = $range[2];

			$frameList = $fromFrame + "-" + $toFrame;
			if( $byFrame > 1 )
			{
				$frameList = $frameList + "x" + $byFrame;
			}
		}
		else if( $jobType == $RedshiftExportJobType && `checkBox -q -v frw_redshiftLayerSubmission` )
		{
			$jobName += " - " + $currentRenderLayer;
		}
	}

	// Get region rendering settings.
	string $regionLeft = 0;
	string $regionTop = 0;
	string $regionRight = 0;
	string $regionBottom = 0;
	int $currX = 0;
	int $currY = 0;
	int $currTile = 0;

	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`;

	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	int $singleRegionFrame = `intSliderGrp -q -v frw_tileSingleFrame`;
	int $singleRegionTiles = 0;
	string $singleRegionLeft = "";
	string $singleRegionTop = "";
	string $singleRegionRight = "";
	string $singleRegionBottom = "";

	// Append tile information to job name if doing a region render.
	if( $jobType == $MayaRenderJobType && $regionRendering )
	{
		if( !$singleRegionJob )
		{
			if( `attributeExists deadlineRegionLeft defaultRenderGlobals` )
			{
				$regionLeft = `getAttr defaultRenderGlobals.deadlineRegionLeft`;
			}

			if( `attributeExists deadlineRegionTop defaultRenderGlobals` )
			{
				$regionTop = `getAttr defaultRenderGlobals.deadlineRegionTop`;
			}

			if( `attributeExists deadlineRegionRight defaultRenderGlobals` )
			{
				$regionRight = `getAttr defaultRenderGlobals.deadlineRegionRight`;
			}

			if( `attributeExists deadlineRegionBottom defaultRenderGlobals` )
			{
				$regionBottom = `getAttr defaultRenderGlobals.deadlineRegionBottom`;
			}

			if( `attributeExists deadlineCurrTile defaultRenderGlobals` )
			{
				$currTile = `getAttr defaultRenderGlobals.deadlineCurrTile`;
			}

			if( `attributeExists deadlineCurrX defaultRenderGlobals` )
			{
				$currX = `getAttr defaultRenderGlobals.deadlineCurrX`;
			}

			if( `attributeExists deadlineCurrY defaultRenderGlobals` )
			{
				$currY = `getAttr defaultRenderGlobals.deadlineCurrY`;
			}

			if($regionType == $TileRegionRenderType)
			{
				$jobName += " (Tile " + $currTile + " : " + $currX + "x" + $currY + " of " + $tilesInX + "x" + $tilesInY + ")";
			}
			else
			{
				$jobName += " (Region " + $currTile + ")";
			}
		}
		else
		{
			if( `attributeExists deadlineRegionSingleTiles defaultRenderGlobals` )
			{
				$singleRegionTiles = `getAttr defaultRenderGlobals.deadlineRegionSingleTiles`;
			}

			if( `attributeExists deadlineRegionSingleLeft defaultRenderGlobals` )
			{
				$singleRegionLeft = `getAttr defaultRenderGlobals.deadlineRegionSingleLeft`;
			}

			if( `attributeExists deadlineRegionSingleTop defaultRenderGlobals` )
			{
				$singleRegionTop = `getAttr defaultRenderGlobals.deadlineRegionSingleTop`;
			}

			if( `attributeExists deadlineRegionSingleRight defaultRenderGlobals` )
			{
				$singleRegionRight = `getAttr defaultRenderGlobals.deadlineRegionSingleRight`;
			}

			if( `attributeExists deadlineRegionSingleBottom defaultRenderGlobals` )
			{
				$singleRegionBottom = `getAttr defaultRenderGlobals.deadlineRegionSingleBottom`;
			}

			$jobName += " (Frame " + $singleRegionFrame + " - " + $singleRegionTiles + " Tiles)";
		}
	}

	// Figure out the camera to use (if specified).
	string $camera = "";
	if( $cameraOverride != "" )
	{
		$camera = $cameraOverride;
	}
	else
	{
		string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
		string $cameraNames[] = `listTransforms -cameras`;
		for( $cameraName in $cameraNames )
		{
			if( $cameraName == $selectedCamera )
			{
				$camera = $selectedCamera;
				break;
			}
		}
	}

	//Check if we need to create a preview job and submit that first

	int $previewEnabled = `checkBox -q -value frw_renderPreviewJobFirst`;
	int $previewPriority = `intSliderGrp -q -v frw_PreviewPriority`;
	int $previewFrames = `intSliderGrp -q -v frw_PreviewFrames`;
	int $previewDependent = `checkBox -q -value frw_dependent`;
	int $frameOffset = `intSliderGrp -q -v frw_frameNumberOffset`;
	int $frameRange[] = GetFramesArray($frameList);
	int $numFrames = 0;
	int $gap = 0;
	int $previewFrameRange[];
	int $newFrameRange[];
	string $submitResults = "";

	if( $regionRendering )
	{
		if (!($regionRendering && $submitEachRenderLayer && !$singleRegionJob))
		{
			$previewEnabled = 0;
		}
	}

	if ($previewEnabled == 1)
	{
		//We need to make a preview job. The preview job needs to be a dependency of the rest of frames if that is enabled

		//Some checks to make things are cool
		$numFrames = size($frameRange);
		if ($numFrames > $previewFrames)
		{
			$gap = $numFrames/$previewFrames;

			//Build the new frame lists
			for( $i = 0; $i < $numFrames; $i++ )
			{
				if( $i % $previewFrames == 0)
				{
					$previewFrameRange[size($previewFrameRange)]=$frameRange[$i];
				}
				else
				{
					$newFrameRange[size($newFrameRange)]=$frameRange[$i];
				}
			}
			$frameRange=$newFrameRange;
		}
		else
		{
			print("Preview frame is larger or equal to the number of frames in the Job, does not make any sense to create a preview Job.");
			$previewEnabled = 0;
		}
	}
	$frameRange = ApplyOutOfOrder($frameRange);
	$previewFrameRange = ApplyOutOfOrder($previewFrameRange);
	for($jobNumber = 0; $jobNumber <= $previewEnabled; $jobNumber++)
	{

		string $namePostFix = "";
		//Check if the Job Name needs a special postfix
		if($previewEnabled == 1)
		{
			if($jobNumber == 0)
			{
				$namePostFix = " [PREVIEW FRAMES]";
			}
			else
			{
				$namePostFix = " [REST OF FRAMES]";
			}
		}

		string $jobDependencies = `textFieldGrp -q -text frw_dependencies`;
		//If this is the rest of frames job, check if we need to add the previous job as a dependency
		if($previewEnabled == 1 && $previewDependent == 1 && $jobNumber == 1)
		{

			string $jobId = "";
			string $resultArray[];
			$resultArray = stringToStringArray( $submitResults, "\n" );
			for( $n = 0; $n < size($resultArray); $n++ )
			{
				if( startsWith( $resultArray[$n], "JobID=" ) )
				{
					$jobId = substituteAllString( $resultArray[$n], "JobID=", "" );
					break;
				}
			}

			if( size($jobDependencies) == 0)
			{
				$jobDependencies = $jobId+"";
			}
			else
			{
				$jobDependencies = $jobDependencies+","+$jobId;
			}
		}

		//Calculate the Priority
		int $jobPriority = `intSliderGrp -q -v frw_JobPriority`;

		if ($previewEnabled == 1 && $jobNumber == 0)
		{
			$jobPriority = $jobPriority + $previewPriority;

			if($maximumPriority < $jobPriority)
			{
				$jobPriority = $maximumPriority;
			}

		}

		int $hasREs = 0;
		string $REs[] = {};
		string $removableREs[] = {};
		int $isMultichannelExr = false;
		string $multichannel = " (multichannel)";
		string $ext = "";

		string $elements[] = {""};

		if( $renderer == "vray" )
		{
			$elements = getVRayElementNames();
		}
		else if ( $renderer == "arnold" )
		{
			$elements = getArnoldElementNames();
		}
		else if ( $renderer == "maxwell" )
		{
			$elements = getMaxwellElementNames();
		}
		else if ( $renderer == "redshift" )
		{
			$elements = getRedshiftElements();
		}

		// Create the job info file.
		string $submitFilename = CheckSlashes( $tempDir + "/maya_deadline_info.job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
		{
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
		}

		int $useMayaBatchPlugin = `checkBox -q -v frw_useMayaBatchPlugin`;
		if( $useMayaBatchPlugin )
		{
			fprint $fileId ( "Plugin=MayaBatch\n" );
		}
		else
		{
			fprint $fileId ( "Plugin=MayaCmd\n" );
		}

		if( $camera != "" )
		{
			$jobName = $jobName + " - " + $camera;
		}

		// Add job name suffix for special Maya jobs.
		if( $jobType == $BifrostSimulationJobType )
		{
			$jobName += " [Bifrost Job]";
		}
		else if( $jobType == $AlembicExportJobType )
		{
			$jobName += " [Alembic Export Job]";
		}
		else if( $jobType == $MayaScriptJobType )
		{
			$jobName += " [Script Job]";
		}
		else if( $jobType == $FluidCachingJobType )
		{
			$jobName += " [Fluid Caching Job]";
		}
		else if( $jobType == $GeometryCachingJobType )
		{
			$jobName += " [Geometry Caching Job]";
		}

		fprint $fileId ( "Name=" + $jobName + $namePostFix + "\n" );
		int $submitEachCamera = `checkBox -q -v frw_submitEachCamera`;
		if($submitEachRenderLayer || $submitEachCamera)
		{
			fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
		}

		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
		fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_LimitCount` + "\n" );
		fprint $fileId ( "Priority=" + $jobPriority + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
		fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_SlaveTimeout` + "\n" );
		fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_MinSlaveTimeout` + "\n" );
		fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_AutoTaskTimeout` + "\n" );
		fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ConcurrentTasks` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );
		fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_limitGroups` + "\n" );
		fprint $fileId ( "JobDependencies=" + $jobDependencies + "\n" );

		// umedia
		fprint $fileId ( "IncludeEnvironment=True\n" );

		if( `checkBox -q -value frw_isBlacklist` )
		{
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		}
		else
		{
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		}

		if( `checkBox -q -value frw_submitAsSuspended` )
		{
			fprint $fileId ( "InitialStatus=Suspended\n" );
		}

		if( $jobType == $MayaRenderJobType )
		{
			int $counter = 0;

			// Store the currently selected render layer
			string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
			string $renderLayerList[] = {""};
			if( IsRenderLayersOn() )
			{
				if( $submitEachRenderLayer )
				{
					$renderLayerList = {$currentRenderLayer};
				}
				else
				{

					$renderLayerList = getRenderableRenderLayers();
				}
			}

			// Loop through the render layer if the checkbox is on
			for( $i = 0; $i < size( $renderLayerList ); $i++ )
			{
				int $isRenderable = 0;
				if( $renderLayerList[$i] == "")
				{
					$isRenderable = 1;
				}
				else
				{
					if( !catch(`editRenderLayerGlobals -currentRenderLayer $renderLayerList[$i]`) )
					{
						$isRenderable = 1;
					}
				}

				if( $isRenderable )
				{
					if( $renderer == "mentalRay" )
					{
						$elements = getMentalRayElementNames( $renderLayerList[$i] );
					}

					string $tempOutputFilePath = $outputFilePath;

					string $renderableCameras[] = {};
					if( $camera != "" )
					{
						stringArrayInsertAtIndex(0, $renderableCameras, $camera );
					}
					else
					{
						$renderableCameras  = deadlineGetRenderableCameras( false );
					}

					if( size($renderableCameras) == 0 )
					{
						stringArrayInsertAtIndex(0, $renderableCameras, "" );
					}
					//Redshift has it's own functions that get the output filenames
					//There are separate functions for the main pass and for AOV's
					//If multiple AOV's have the same output filename then they are merged into one file
					//As such we only want to include the files once.
					if ( $renderer == "redshift" )
					{
						string $usedOutputPaths[];

						//The options node might not have been created yet and if it has not been created then redshiftGetAovImageName will throw an error
						redshiftGetRedshiftOptionsNode( 1 );

						string $paddingString = "#";
						if( `getAttr "defaultRenderGlobals.animation"` )
						{
							int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
							while( size($paddingString) < $paddingSize )
							{
								$paddingString = "#" + $paddingString;
							}
						}

						for ($element in $elements)
						{
							string $outputFilename = "";
							if( $element == "" )
							{
								$outputFilename = redshiftGetImageFormatString( 0, $renderableCameras[0] );
							}
							else
							{
								$outputFilename = redshiftGetAovImageName( $element, 0, $renderableCameras[0] );
							}

							if( `getAttr "defaultRenderGlobals.animation"` )
							{
								$outputFilename = `substitute "#+" $outputFilename $paddingString `;
							}

							if( !stringArrayContains($outputFilename,$usedOutputPaths)  )
							{
								fprint $fileId ( "OutputFilename" + $counter + "=" + $outputFilename + "\n" );
								$counter += 1;
								stringArrayInsertAtIndex(0, $usedOutputPaths, $outputFilename);
							}
						}

					}
					else
					{
						for( $cameraName in $renderableCameras )
						{

							for($element in $elements)
							{
								string $outputPrefix = "";
								$outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, $renderLayerList[$i], $cameraName, $element ) );
								$outputPrefix = swapDeepExr( $outputPrefix );

								if( $jobType == $MayaRenderJobType && $regionRendering )
								{
									if( !$singleRegionJob )
									{
										if($regionType ==$TileRegionRenderType)
										{
											$outputPrefix = GetTileOutputPrefix( $outputPrefix, $currX, $currY, $tilesInX, $tilesInY, $renderer );
										}
										else
										{
											$outputPrefix = GetJigsawOutputPrefix( $outputPrefix, $currTile, $renderer );
										}

										fprint $fileId ( "OutputFilename" + $counter + "=" + CheckSlashes( $tempOutputFilePath + "/" + $outputPrefix ) + "\n" );
									}
									else
									{
										$outputPrefix = GetOutputPrefix( 1, $singleRegionFrame, $renderLayerList[$i], $cameraName, $element );
										$outputPrefix = swapDeepExr( $outputPrefix );

										if($regionType == $TileRegionRenderType)
										{
											int $tileNum = 0;
											for( $y = 1; $y <= $tilesInY; $y++ )
											{
												for( $x = 1; $x <= $tilesInX; $x++ )
												{
													string $tempFilePrefix = GetTileOutputPrefix( $outputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
													fprint $fileId ( "OutputFilename" + $counter + "Tile"+$tileNum+"=" + CheckSlashes( $tempOutputFilePath + "/" + $tempFilePrefix ) + "\n" );
													$tileNum++;
												}
											}
										}
										else
										{
											for( $tileNum = 0; $tileNum < $singleRegionTiles; $tileNum++ )
											{

												string $tempFilePrefix = GetJigsawOutputPrefix( $outputPrefix, $tileNum, $renderer );
												fprint $fileId ( "OutputFilename" + $counter + "Tile"+$tileNum+"=" + CheckSlashes( $tempOutputFilePath + "/" + $tempFilePrefix ) + "\n" );
											}
										}
									}
								}
								else
								{
									fprint $fileId ( "OutputFilename" + $counter + "=" + CheckSlashes( $tempOutputFilePath + "/" + $outputPrefix ) + "\n" );
								}
								$counter += 1;
							}
						}
					}
				}
			}
			// Reselect the current render layer
			editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;

		}
		else if( $jobType == $MentalRayExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + dirname( $mentalRayFilename ) + "\n" );
		}
		else if( $jobType == $VRayExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + dirname( $vrayFilename ) + "\n" );
		}
		else if( $jobType == $RendermanExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` + "/renderman/" + GetStrippedSceneFileName() ) + "\n" );
		}
		else if( $jobType == $ArnoldExportJobType || $jobType == $MaxwellExportJobType )
		{
			string $assExportFolder = `workspace -fre "ASS"`;
			if( $assExportFolder == "" )
			{
				$assExportFolder = "data";
			}

			fprint $fileId ( "OutputDirectory0=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` + "/" + $assExportFolder ) + "\n" );
		}
		else if( $jobType == $RedshiftExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` + "/redshift/" ) + "\n" );
		}

		$frameList = FromArrayToCommaSeparatedString($frameRange);
		if($jobNumber == 0 && $previewEnabled == 1)
		{
			$frameList = FromArrayToCommaSeparatedString($previewFrameRange);
		}

		if( $jobType == $MayaRenderJobType && $regionRendering && $singleRegionJob )
		{
			//fprint $fileId ( "Frames=0-" + ($singleRegionTiles-1) + "\n" );
			//fprint $fileId ( "ChunkSize=1\n" );
			fprint $fileId ( "TileJob=True\n" );
			fprint $fileId ( "TileJobFrame=" + $singleRegionFrame + "\n" );

			if( $regionType == $TileRegionRenderType)
			{
				fprint $fileId ( "TileJobTilesInX=" + $tilesInX + "\n" );
				fprint $fileId ( "TileJobTilesInY=" + $tilesInY + "\n" );
			}
			else
			{
				fprint $fileId ( "TileJobTilesInX=" + $singleRegionTiles + "\n" );
				fprint $fileId ( "TileJobTilesInY=1\n" );
			}

		}
		else
		{
			//TODO, what do I do with this nonsense when submitting a preview job
			if( $jobType == $MayaRenderJobType && $submitEachRenderLayer )
			{
				if($overrideLayerSettings)
				{
					$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;

					$field = "frw_FrameList_" + $currentRenderLayer;
					fprint $fileId ( "Frames=" + `textFieldGrp -q -text $field` + "\n" );

					$field = "frw_FrameGroup_" + $currentRenderLayer;
					fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -v $field` + "\n" );
				}
				else
				{
					fprint $fileId ( "Frames=" + $frameList + "\n" );
					fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -v frw_FrameGroup` + "\n" );
				}
			}
			else
			{
				if( ( $jobType == $ArnoldExportJobType && $regionRendering && $singleRegionJob ) )
				{
					fprint $fileId ( "Frames=" + $singleRegionFrame + "\n" );
				}
				else
				{
					fprint $fileId ( "Frames=" + $frameList + "\n" );
				}

				// Regular renders and Arnold exports can be split across machines, but other exports (AFAIK) must be done on a single machine.
				if( $jobType == $MayaRenderJobType || $jobType == $ArnoldExportJobType || $jobType == $MaxwellExportJobType || $jobType == $RendermanExportJobType || $jobType == $RedshiftExportJobType )
				{
					fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -v frw_FrameGroup` + "\n" );
				}
				else
				{
					fprint $fileId ( "ChunkSize=100000\n" );
				}
			}
		}

		if( $jobType == $MayaRenderJobType && $regionRendering && $useMayaBatchPlugin && $renderer == "vray" )
		{
			fprint $fileId ( "ForceReloadPlugin=True\n" );
		}

		$kvpIndex = 0;
		$groupBatch = false;
		$dependentJob = false;
		int $submitDependentRegionJob = `checkBox -q -v frw_submitTileDependentJob`;
		if( $regionRendering && $submitDependentRegionJob)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDependentVRrayJob = `checkBox -q -v frw_submitVRayJob`;
		if($jobType == $VRayExportJobType && $submitDependentVRrayJob)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDependentArnold = `checkBox -q -v frw_submitArnoldJob`;
		if($jobType == $ArnoldExportJobType && $submitDependentArnold)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDependentMaxwell = `checkBox -q -v frw_submitMaxwellJob`;
		if( $jobType == $MaxwellExportJobType && $submitDependentMaxwell )
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDepRenderMan = `checkBox -q -v frw_submitRenderManJob`;
		if($jobType == $RendermanExportJobType && $submitDepRenderMan)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDepMentalRay = `checkBox -q -v frw_submitMentalRayJob`;
		if($jobType == $MentalRayExportJobType && $submitDepMentalRay)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDepRedShift = `checkBox -q -v frw_submitRedshiftJob`;
		if($jobType == $RedshiftExportJobType && $submitDepRedShift)
		{
			$groupBatch = true;
			$dependentJob = true;
		}

		if( !$dependentJob )
		{
			int $integrationResults[] = WriteIntegrationSettings( $fileId, $groupBatch );
			$groupBatch = $integrationResults[0];
			$kvpIndex = $integrationResults[1];

		}

		if ( $groupBatch )
		{
			string $batchName = `textFieldGrp -q -text frw_JobName`;
			//This will group the jobs created later in the same batch
			fprint $fileId ( "BatchName=" + $batchName + "\n" );
		}

		fclose $fileId;

		// Create the plugin info file.
		string $jobFilename = CheckSlashes( $tempDir + "/maya_deadline_job.job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
		{
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
		}

		// If animation is enabled.
		fprint $fileId ( "Animation=" + IsAnimatedOn() + "\n" );

		if( $jobType == $MentalRayExportJobType )
		{
			fprint $fileId ( "Renderer=mentalRayExport\n" );
			fprint $fileId ( "UsingRenderLayers=false\n" );

			global string $gExportFilterCheckBoxes[];
			global string $gExportPathesCheckBoxes[];

			fprint $fileId ( "MentalRayExportfile=" + $mentalRayFilename + "\n" );
			fprint $fileId ( "MentalRayExportBinary=" + ((`radioButton -query -select MayatomrExport_Binary`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportTabStop=" + ($tabstop = `intField -query -value MayatomrExport_TabSize`) + "\n" );

			int $perframe = 0;
			int $padframe = 0;
			if(`checkBoxGrp -query -value1 MayatomrExport_FilePerFrame`)
			{
				$perframe = `optionMenuGrp -q -select MayatomrExport_FrameExtension`;
				$padframe = `intFieldGrp -q -value1 MayatomrExport_FramePadding`;
				if ($padframe > 9)
				{
					$padframe = 9;
				}
			}

			fprint $fileId ( "MentalRayExportPerFrame=" + $perframe + "\n" );
			fprint $fileId ( "MentalRayExportPadFrame=" + $padframe + "\n" );
			fprint $fileId ( "MentalRayExportPerLayer=" + `checkBoxGrp -query -value1 MayatomrExport_FilePerLayer` + "\n" );

			$pathnames = "";
			if(`checkBoxGrp -query -value1 MayatomrExport_Pathes`)
			{
				for( $cnt=0; $cnt < size( $gExportPathesCheckBoxes ); $cnt++ )
				{
					$pathnames += `optionMenuGrp -query -sl $gExportPathesCheckBoxes[$cnt]`;
				}
			}
			else
			{
				$pathnames = "n";
			}

			fprint $fileId ( "MentalRayExportPathNames=" + $pathnames + "\n" );

			$fragment = (`optionMenuGrp -q -select MayatomrExport_Fragment`-1);
			fprint $fileId ( "MentalRayExportFragment=" + $fragment + "\n" );
			fprint $fileId ( "MentalRayExportFragmentMaterials=" + ((`checkBoxGrp -q -v1 MayatomrExport_FragmentMaterials`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportFragmentShaders=" + ((`checkBoxGrp -q -v1 MayatomrExport_FragmentIncomingShdrs`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportFragmentChildDag=" + ((`checkBoxGrp -q -v1 MayatomrExport_FragmentChildDag`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportPassContributionMaps=" + ((`checkBoxGrp -q -v1 MayatomrExport_PassContributionMaps`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportPassUserData=" + ((`checkBoxGrp -q -v1 MayatomrExport_PassUserData`) ? 1 : 0) + "\n" );

			$filter = "";
			if(`checkBoxGrp -query -value1 MayatomrExport_Filters`)
			{
				for($cnt=0; $cnt<size($gExportFilterCheckBoxes); $cnt++)
				{
					$filter += (`checkBoxGrp -query -value1 $gExportFilterCheckBoxes[$cnt]`) ? "0" : "1";
				}
			}

			fprint $fileId ( "MentalRayExportFilterString=" + $filter + "\n" );
		}
		else if( $jobType == $VRayExportJobType )
		{
			fprint $fileId ( "Renderer=vrayExport\n" );
			fprint $fileId ( "VRayExportFile=" + $vrayFilename + "\n" );
		}
		else if( $jobType == $RendermanExportJobType )
		{
			fprint $fileId ( "Renderer=rendermanExport\n" );
			fprint $fileId ( "MaxProcessors=" + `intSliderGrp -q -v frw_exportRenderManThreads` + "\n" );
			fprint $fileId ( "RenderWithRis=" + `checkBox -q -v frw_renderRenderManWithRis` + "\n" );
		}
		else if( $jobType == $ArnoldExportJobType )
		{
			fprint $fileId ( "Renderer=arnoldExport\n" );
		}
		else if( $jobType == $MaxwellExportJobType )
		{
			fprint $fileId ( "Renderer=maxwellExport\n" );

			string $outputScript = `textFieldButtonGrp -q -text frw_maxwellScriptName`;
			if($cameraOverride != "")
			{
				string $base = basenameEx( $outputScript );
				string $folder = substituteAllString($outputScript,basename($outputScript,""),"");
				string $ext = fileExtension( $outputScript );

				$outputScript = $folder+$base+"_"+$cameraOverride+"."+$ext;
			}

			fprint $fileId ( "MaxwellMXSFile=" + $outputScript + "\n" );
		}
		else if( $jobType == $RedshiftExportJobType )
		{
			fprint $fileId ( "Renderer=redshiftExport\n" );
			if( IsRenderLayersOn() )
			{
				fprint $fileId ( "RenderLayer=" + `editRenderLayerGlobals -q -crl` + "\n" );
			}
		}
		else if( $jobType == $BifrostSimulationJobType )
		{

			fprint $fileId ( "BifrostJob=True\n" );

			string $cacheOutDir = CheckSlashes( `textFieldGrp -q -text frw_bifrostCacheDir` );
			fprint $fileId( "OutputFilePath=" + $cacheOutDir + "\n" );

			if(IntMayaVersion() > 2015)
			{
				string $formatIndex = (string)((`optionMenuGrp -q -select frw_biFrostCompressionFormat`)-1); // Change index from 1-3 to 0-2
				fprint $fileId( "BifrostCompressionFormat=" + $formatIndex + "\n" );
			}
		}
		else if( $jobType == $AlembicExportJobType )
		{
			string $alembicAttrs[] = { "frw_verboseCheck", "frw_noNormalsCheck", "frw_renderableOnlyCheck",
									   "frw_stripNamespacesCheck", "frw_uvWriteCheck", "frw_writeColorSetsCheck",
									   "frw_writeFaceSetsCheck", "frw_wholeFrameGeoCheck", "frw_worldSpaceCheck",
									    "frw_writeVisibilityCheck", "frw_filterEulerRotationsCheck", "frw_writeCreasesCheck" };

			string $alembicOutFile = CheckSlashes(`textFieldGrp -q -text frw_alembicExportFile` );

			fprint $fileId ( "AlembicJob=True\n" );
			fprint $fileId( "OutputFile=" + basename( $alembicOutFile, "" ) + "\n" );

			for($i = 0; $i<size($alembicAttrs); $i++)
			{
				if(`checkBox -q -v $alembicAttrs[$i]`)
				{
					string $checkedItem = substituteAllString(`checkBox -q -label $alembicAttrs[$i]`, " ", "" );
					fprint $fileId( $checkedItem + "=True\n" );
				}
			}

			if( `checkBox -q -v frw_abcSubFrameCheck` )
			{
				fprint $fileId ( "AlembicSubFrames=True\n" );
				fprint $fileId( "AlembicLowSubFrame=" + `floatSliderGrp -q -v frw_abcLowSubFrameCheck` + "\n" );
				fprint $fileId( "AlembicHighSubFrame=" + `floatSliderGrp -q -v frw_abcHighSubFrameCheck` + "\n" );
			}

			fprint $fileId( "AlembicAttributes=" + `textFieldGrp -q -text frw_abcDynamicAttributes` + "\n" );
			fprint $fileId( "AlembicAttributePrefix=" + `textFieldGrp -q -text frw_abcDynamicAttributePrefix` + "\n" );

			// if index == 1, use HDF, else use Ogawa
			if( `optionMenuGrp -q -sl frw_alembicFormat` == 1 )
			{
				fprint $fileId( "AlembicFormatOption=HDF\n" );
			}
			else
			{
				fprint $fileId( "AlembicFormatOption=Ogawa\n" );
			}

			fprint $fileId( "OutputFilePath="+ CheckSlashes( dirname( $alembicOutFile ) ) + "\n" );

			// AlembicExportSelection
			string $alembicSelection = "All";
			string $items[] = `ls -sl`;

			if( `radioButtonGrp -q -select frw_AlembicExportSelection` == 2 && size( stringArrayRemove( $items, `ls` ) ) )
			{
				$alembicSelection = "";
				for($item in $items)
				{
					$alembicSelection += ( $item + "," );
				}
				$alembicSelection = `substring $alembicSelection 1 (size($alembicSelection)-1)`; // Chop off the last comma
			}
			fprint $fileId( "AlembicSelection=" + $alembicSelection + "\n" );
		}
		else if( $jobType == $MayaScriptJobType )
		{
			fprint $fileId ( "ScriptJob=True\n" );

			string $fullfile = `textFieldGrp -q -text frw_mayaScriptJob`;
			string $result = basename( $fullfile, "" );
			fprint $fileId ( "ScriptFilename=" + $result +"\n");
		}
		// Fluid and Geometry caching is very similar. This would be easy to form into generalized nCaching (along with nCaching, nParticles, nCloth, nHair) in the future
		else if( $jobType == $FluidCachingJobType )
		{
			// This will be handled in a similar fashion to Geometry caching
			string $fluidCacheOutDir = `textFieldButtonGrp -q -text frw_FluidCacheOutputDir`;
			string $fileDists[] = { "True", "False" };

			fprint $fileId ( "FluidCacheJob=True\n" );

			fprint $fileId ( "FluidCacheFileName=" + `textFieldGrp -q -text frw_FluidCacheFileName` + "\n" );
			fprint $fileId ( "OutputFilePath=" + $fluidCacheOutDir  + "\n" );
			fprint $fileId ( "CacheFormat=" + `optionMenuGrp -q -value frw_FluidCacheFormat` + "\n" );
			fprint $fileId ( "OneFilePerFluid=" + `checkBox -q -value frw_FluidCacheSplitCheck` + "\n" );
			fprint $fileId ( "OneFilePerFrame=" + $fileDists[int(`radioButtonGrp -q -select frw_FluidCacheFileDistRadio`)-1] + "\n" );

			string $selection = "All";
			string $fluids[] = `listTransforms "-type fluidShape"`;
			string $sels[] = `ls -sl`;

			string $selectedFluids[] = IntersectTwoStringArray($fluids, $sels);

			if( size( stringArrayRemove( $selectedFluids, $fluids ) ) ) // There is a difference between the selected fluids and all fluids in the scene. Therefore we have not selected everything
			{
				$selection = "";
				for($item in $selectedFluids)
				{
					$selection += $item + ",";
				}
				$selection = `substring $selection 1 (size($selection)-1)`; // Chop off the last comma
			}

			fprint $fileId ( "SelectedFluids=" + $selection + "\n" );

		}
		else if( $jobType == $GeometryCachingJobType )
		{
			string $GeometricCacheOutDir = `textFieldGrp -q -text frw_GeometricCacheOutputDir`;
			string $fileDists[] = { "True", "False" };
			string $dblOrFlt[] = { "Double", "Float" };
			string $storePts[] = { "Local", "World" };

			fprint $fileId ( "GeometryCacheJob=True\n" );
			fprint $fileId ( "OutputFilePath=" + $GeometricCacheOutDir  + "\n" );
			fprint $fileId ( "OneFilePerFrame=" + $fileDists[int(`radioButtonGrp -q -select frw_GeometricCacheFileDistRadio`)-1] + "\n" );
			fprint $fileId ( "SavePointsAs=" + $dblOrFlt[int(`radioButtonGrp -q -select frw_GeometricCacheDblOrFltRadio`)-1] + "\n" );
			fprint $fileId ( "SavePointsIn=" + $storePts[int(`radioButtonGrp -q -select frw_GeometricCacheLocOrWldRadio`)-1] + "\n" );
			fprint $fileId ( "OneFilePerGeometry=" + `checkBox -q -value frw_GeometricCacheSplitCheck` + "\n" );
			fprint $fileId ( "CacheFormat=" + `optionMenuGrp -q -value frw_GeoCacheFormat` + "\n" );
			fprint $fileId ( "GeoCacheFileName=" + `textFieldGrp -q -text frw_GeoCacheFileName` + "\n" );

			string $selection = "All"; // default is all Geometry selected
			string $geos[] = `listTransforms -geometry`;
			string $sels[] = `ls -sl`;

			string $selectedGeos[] = IntersectTwoStringArray($geos, $sels); // This is all of the selected Geometry

			if( size( stringArrayRemove( $selectedGeos, $geos ) ) ) // There is a difference between the selected Geometry and all the Geometry. Therefore we have not selected everything
			{
				// reassign the string and set up the actual selection
				$selection = "";
				for($item in $selectedGeos)
				{
					$selection += $item + ",";
				}
				$selection = `substring $selection 1 (size($selection)-1)`; // Chop off the last comma
			}

			fprint $fileId ( "SelectedGeometry=" + $selection + "\n" );
		}
		else
		{
			fprint $fileId ( "Renderer=" + $renderer + "\n" );
			fprint $fileId ( "UsingRenderLayers=" + IsRenderLayersOn() + "\n" );
			fprint $fileId ( "RenderLayer=" + $currentRenderLayer + "\n" );

			int $renderHalfFrames = ShowHalfFramesOption( $renderer ) ? `checkBox -q -value frw_renderHalfFrames` : 0;
			fprint $fileId ( "RenderHalfFrames=" + $renderHalfFrames + "\n" );

			fprint $fileId ( "FrameNumberOffset=" + $frameOffset + "\n" );

			int $localRendering = `checkBox -q -value frw_localRendering`;
			fprint $fileId ( "LocalRendering=" + $localRendering + "\n" );

			int $strictErrorChecking = `checkBox -q -value frw_strictErrorChecking`;
			fprint $fileId ( "StrictErrorChecking=" + $strictErrorChecking + "\n" );

			if( $regionRendering )
			{
				fprint $fileId ( "RegionRendering=True\n" );
				if( !$singleRegionJob )
				{
					fprint $fileId ( "RegionLeft=" + $regionLeft + "\n" );
					fprint $fileId ( "RegionTop=" + $regionTop + "\n" );
					fprint $fileId ( "RegionRight=" + $regionRight + "\n" );
					fprint $fileId ( "RegionBottom=" + $regionBottom + "\n" );
				}
				else
				{

					//fprint $fileId ( "RegionSingleJob=True\n" );
					//fprint $fileId ( "RegionSingleFrame=" + $singleRegionFrame + "\n" );
					fprint $fileId ( $singleRegionLeft + "\n" );
					fprint $fileId ( $singleRegionTop + "\n" );
					fprint $fileId ( $singleRegionRight + "\n" );
					fprint $fileId ( $singleRegionBottom + "\n" );

					if($regionType == $JigsawRegionRenderType)
					{
						for( $tileNum = 0; $tileNum < $singleRegionTiles; $tileNum++ )
						{
							string $outputFilePrefix = GetMayaOutputPrefix( $camera, $currentRenderLayer );
							$outputFilePrefix = GetJigsawOutputPrefix($outputFilePrefix, $tileNum, $renderer);

							fprint $fileId ("RegionPrefix" + $tileNum + "=" + $outputFilePrefix + "\n");

						}
					}
					else
					{
						int $tileNum = 0;
						for( $y = 1; $y <= $tilesInY; $y++ )
						{
							for( $x = 1; $x <= $tilesInX; $x++ )
							{
								string $outputFilePrefix = GetMayaOutputPrefix( $camera, $currentRenderLayer );
								$outputFilePrefix = GetTileOutputPrefix( $outputFilePrefix, $x, $y, $tilesInX, $tilesInY, $renderer );

								// Renderman strips the leading '_' from output file names, so we need to add an additional one.
								//if( $renderer == "renderMan" || $renderer == "renderManRIS" )
								//	$outputFilePrefix = "_" + $outputFilePrefix;

								fprint $fileId ("RegionPrefix" + $tileNum + "=" + $outputFilePrefix + "\n");
								$tileNum++;
							}
						}
					}
				}
			}

			if( EnableCpuOption( $renderer ) )
			{
				fprint $fileId ( "MaxProcessors=" + `intSliderGrp -q -v frw_MaxCPUs` + "\n" );
			}

			if( $renderer == "mayaSoftware" )
			{
				// render globals qualification
				string $rendQual[] = `listConnections defaultRenderGlobals.qual`;

				// get antialising quality level and turn it into a string
				string $strAntialiasing = "highest";
				int $intAntialiasing = `getAttr ($rendQual[0] + ".edgeAntiAliasing")`;
				if ( $intAntialiasing == 1 )
				{
					$strAntialiasing = "high";
				}

				if ( $intAntialiasing == 2 )
				{
					$strAntialiasing = "medium";
				}

				if ( $intAntialiasing == 3 )
				{
					$strAntialiasing = "low";
				}

				fprint $fileId ( "AntiAliasing=" + $strAntialiasing + "\n" );
			}

			// Krakatoa options currently only supported by the MayaBatch plugin.
			if( $useMayaBatchPlugin && $renderer == "MayaKrakatoa")
			{
				string $boolVal = "";
				float $krakatoaFinalPassDensity = `getAttr "MayaKrakatoaRenderSettings.finalPassDensity"`;
				fprint $fileId ( "KrakatoaFinalPassDensity="+ $krakatoaFinalPassDensity + "\n" );

				int $krakatoaFinalPassDensityExponent = `getAttr "MayaKrakatoaRenderSettings.finalPassDensityExponent"`;
				fprint $fileId ( "KrakatoaFinalPassDensityExponent=" + $krakatoaFinalPassDensityExponent + "\n" );

				int $krakatoaUseLightingPassDensity = `getAttr "MayaKrakatoaRenderSettings.useLightingPassDensity"`;

				if($krakatoaUseLightingPassDensity == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaUseLightingPassDensity=" + $boolVal+ "\n" );

				float $krakatoaLightingDensity = `getAttr "MayaKrakatoaRenderSettings.lightingPassDensity"`;
				fprint $fileId ( "KrakatoaLightingPassDensity="+ $krakatoaLightingDensity + "\n" );

				int $krakatoaLightingDensityExponent = `getAttr "MayaKrakatoaRenderSettings.lightingPassDensityExponent"`;
				fprint $fileId ( "KrakatoaLightingPassDensityExponent=" + $krakatoaLightingDensityExponent + "\n" );

				int $krakatoaUseEmissionStrength = `getAttr "MayaKrakatoaRenderSettings.useEmissionStrength"`;
				if($krakatoaUseEmissionStrength == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaUseEmissionStrength=" + $boolVal + "\n" );

				float $krakatoaEmissionStrength = `getAttr "MayaKrakatoaRenderSettings.emissionStrength"`;
				fprint $fileId ( "KrakatoaEmissionStrength="+ $krakatoaEmissionStrength + "\n" );

				int $krakatoaEmissionStrengthExponent = `getAttr "MayaKrakatoaRenderSettings.emissionStrengthExponent"`;
				fprint $fileId ( "KrakatoaEmissionStrengthExponent=" + $krakatoaEmissionStrengthExponent + "\n" );

				int $krakatoaUseEmission = `getAttr "MayaKrakatoaRenderSettings.useEmission"`;
				if($krakatoaUseEmission == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaUseEmission=" + $boolVal + "\n" );

				int $krakatoaUseAbsorption = `getAttr "MayaKrakatoaRenderSettings.useAbsorption"`;
				if($krakatoaUseAbsorption == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaUseAbsorption=" + $boolVal + "\n" );

				int $krakatoaEnableMotionBlur = `getAttr "MayaKrakatoaRenderSettings.enableMotionBlur"`;
				if($krakatoaEnableMotionBlur == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaEnableMotionBlur=" + $boolVal + "\n" );

				int $krakatoaMotionBlurParticleSegments = `getAttr "MayaKrakatoaRenderSettings.motionBlurParticleSegments"`;
				fprint $fileId ( "KrakatoaMotionBlurParticleSegments=" + $krakatoaMotionBlurParticleSegments+ "\n" );

				int $krakatoaJitteredMotionBlur = `getAttr "MayaKrakatoaRenderSettings.jitteredMotionBlur"`;
				if($krakatoaJitteredMotionBlur == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaJitteredMotionBlur=" + $boolVal + "\n" );

				float $krakatoaShutterAngle = `getAttr "MayaKrakatoaRenderSettings.shutterAngle"`;
				fprint $fileId ( "KrakatoaShutterAngle="+ $krakatoaShutterAngle + "\n" );

				int $krakatoaEnableDOF = `getAttr "MayaKrakatoaRenderSettings.enableDOF"`;
				if($krakatoaEnableDOF == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaEnableDOF=" + $boolVal + "\n" );

				float $krakatoaSampleRateDOF = `getAttr "MayaKrakatoaRenderSettings.sampleRateDOF"`;
				fprint $fileId ( "KrakatoaSampleRateDOF="+ $krakatoaSampleRateDOF + "\n" );

				int $krakatoaEnableMatteObjects = `getAttr "MayaKrakatoaRenderSettings.enableMatteObjects"`;
				if($krakatoaEnableMatteObjects == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaEnableMatteObjects=" + $boolVal + "\n" );

				int $krakatoaEnableOverrideBG = `getAttr "MayaKrakatoaRenderSettings.overrideBG"`;
				if($krakatoaEnableOverrideBG == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaEnableOverrideBG=" + $boolVal + "\n" );

				//float $krakatoaBGOverride[] = `getAttr "MayaKrakatoaRenderSettings.backgroundColor"`;
				//fprint $fileId ( "KrakatoaBGOverride=" + $krakatoaBGOverride[0]+ " "+ $krakatoaBGOverride[1] + " " + $krakatoaBGOverride[2] + "\n" );

				int $krakatoaEnableOverrideColor = `getAttr "MayaKrakatoaRenderSettings.overrideColor"`;
				if($krakatoaEnableOverrideColor == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaEnableOverrideColor=" + $boolVal + "\n" );

				//float $krakatoaColorOverride[] = `getAttr "MayaKrakatoaRenderSettings.colorChannelOverride"`;
				//fprint $fileId ( "KrakatoaColorOverride=" + $krakatoaColorOverride[0]+ " "+ $krakatoaColorOverride[1] + " " + $krakatoaColorOverride[2] + "\n" );

				int $krakatoaEnableOverrideEmission = `getAttr "MayaKrakatoaRenderSettings.overrideEmission"`;
				if($krakatoaEnableOverrideEmission == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaEnableOverrideEmission=" + $boolVal + "\n" );

				//float $krakatoaEmissionOverride[] = `getAttr "MayaKrakatoaRenderSettings.emissionChannelOverride"`;
				//fprint $fileId ( "KrakatoaEmissionOverride=" + $krakatoaEmissionOverride[0]+ " "+ $krakatoaEmissionOverride[1] + " " + $krakatoaEmissionOverride[2] + "\n" );

				int $krakatoaEnableOverrideAbsorption = `getAttr "MayaKrakatoaRenderSettings.overrideAbsorption"`;
				if($krakatoaEnableOverrideAbsorption == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaEnableOverrideAbsorption=" + $boolVal+ "\n" );

				//float $krakatoaAbsorptionOverride[] = `getAttr "MayaKrakatoaRenderSettings.absorptionChannelOverride"`;
				//fprint $fileId ( "krakatoaAbsorptionOverride=" + $krakatoaAbsorptionOverride[0]+ " "+ $krakatoaAbsorptionOverride[1] + " " + $krakatoaAbsorptionOverride[2] + "\n" );

				string $krakatoaRenderingMethod = `getAttr -asString "MayaKrakatoaRenderSettings.renderingMethod"`;
				fprint $fileId ( "KrakatoaRenderingMethod="+ $krakatoaRenderingMethod + "\n" );

				if ($krakatoaRenderingMethod =="Voxels")
				{
					float $krakatoaVoxelSize = `getAttr "MayaKrakatoaRenderSettings.voxelSize"`;
					fprint $fileId ( "KrakatoaVoxelSize="+ $krakatoaVoxelSize + "\n" );

					float $krakatoaVoxelFilterRadius = `getAttr "MayaKrakatoaRenderSettings.voxelFilterRadius"`;
					fprint $fileId ( "KrakatoaVoxelFilterRadius="+ $krakatoaVoxelFilterRadius + "\n" );
				}

				int $krakatoaForceEXROutput = `getAttr "MayaKrakatoaRenderSettings.forceEXROutput"`;
				if($krakatoaForceEXROutput == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaForceEXROutput=" + $boolVal + "\n" );
			}

			if( $renderer == "arnold" )
			{
				string $arnoldVerbose = `optionMenuGrp -q -value frw_arnoldVerbose`;
				fprint $fileId ( "ArnoldVerbose=" + $arnoldVerbose + "\n" );
			}

			if( $renderer == "mentalRay" )
			{
				string $mentalRayVerbose = `optionMenuGrp -q -value frw_mentalRayVerbose`;
				fprint $fileId ( "MentalRayVerbose=" + $mentalRayVerbose + "\n" );

				int $autoMemoryLimit = `checkBox -q -value frw_autoMemoryLimit`;
				fprint $fileId ( "AutoMemoryLimit=" + $autoMemoryLimit + "\n" );

				int $memoryLimit = `intSliderGrp -q -v frw_memoryLimit`;
				fprint $fileId ( "MemoryLimit=" + $memoryLimit + "\n" );
			}

			if( $renderer == "redshift" || $renderer == "ifmIrayPhotoreal" || $renderer == "octaneRender" )
			{
				int $deadlineGPUsPerTask = `intSliderGrp -q -v frw_deadlineGPUsPerTask`;
				fprint $fileId ( "GPUsPerTask=" + $deadlineGPUsPerTask + "\n" );

				string $deadlineGPUsSelectDevices = `textFieldGrp -q -text frw_deadlineGPUsSelectDevices`;
				fprint $fileId ( "GPUsSelectDevices=" + `textFieldGrp -q -text frw_deadlineGPUsSelectDevices` + "\n" );
			}

			if( $renderer == "redshift" )
			{
				int $redshiftVerbose = `optionMenuGrp -q -sl frw_redshiftVerbose`;
				fprint $fileId ( "RedshiftVerbose=" + ( $redshiftVerbose -1 ) + "\n" );
			}

			if( $renderer == "ifmIrayPhotoreal" )
			{
				string $boolVal = "";

				int $irayUseCPUs = `checkBox -q -v frw_irayUseCPUs`;

				if($irayUseCPUs == 1)
				{
					$boolVal = "True";
				}
				else
				{
					$boolVal = "False";
				}

				fprint $fileId ( "IRayUseCPUs=" + $boolVal + "\n" );

				float $irayCPULoad = `floatSliderGrp -q -v frw_irayCPULoad`;
				fprint $fileId ( "IRayCPULoad=" + $irayCPULoad + "\n" );

				int $irayMaxSamples = `getAttr ifmGlobalsIrayPhotoreal.irayMaxSamples`;
				fprint $fileId ( "IRayMaxSamples=" + $irayMaxSamples + "\n" );
			}

			if( $renderer == "vray" )
			{
				if( $useMayaBatchPlugin )
				{
					int $vrayAutoMemoryEnabled = `checkBox -q -value frw_vrayAutoMemoryEnabled`;
					fprint $fileId ( "VRayAutoMemoryEnabled=" + $vrayAutoMemoryEnabled + "\n" );

					int $vrayAutoMemoryBuffer = `intSliderGrp -q -v frw_vrayAutoMemoryBuffer`;
					fprint $fileId ( "VRayAutoMemoryBuffer=" + $vrayAutoMemoryBuffer + "\n" );
				}
			}

			if( $renderer == "maxwell" )
			{
				fprint $fileId ( "MaxwellRenderTime=" + `getAttr "maxwellRenderOptions.renderTime"` + "\n" );
				fprint $fileId ( "MaxwellSamplingLevel=" + `getAttr "maxwellRenderOptions.samplingLevel"` + "\n" );
				fprint $fileId ( "MaxwellResumeRender=false\n" );
			}

			if( $renderer == "OctaneRender" )
			{
				fprint $fileId ( "OctaneMaxSamples=" + `getAttr "octaneSettings.MaxSamples"` + "\n" );
			}
		}

		//fprint $fileId ( "Version=" + IntMayaVersion() + "\n" );
		fprint $fileId ( "Version=" + MayaVersion() + "\n" );

		if( MayaVersion() >= 2016.5 )
		{
			fprint $fileId ( "UseLegacyRenderLayers=" + !mayaHasRenderSetup() + "\n" );
		}

		string $mayaBuild = `optionMenuGrp -q -value frw_mayaBuild`;
		fprint $fileId ( "Build=" + $mayaBuild + "\n" );

		fprint $fileId ( "ProjectPath=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` ) + "\n" );
		if( !$useMayaBatchPlugin )
		{
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_mayaArgs` + "\n" );
		}
		else
		{
			fprint $fileId ( "StartupScript=" + `textFieldButtonGrp -q -text $StartupScriptPathGrp` + "\n" );
		}

		int $res[] = GetGlobalsResolution();
		fprint $fileId ( "ImageWidth=" + $res[0] + "\n" );
		fprint $fileId ( "ImageHeight=" + $res[1] + "\n" );
		//if( $renderer != "vray" )
		//	fprint $fileId ( "AspectRatio=" + `getAttr "defaultResolution.deviceAspectRatio"` + "\n" );

		// Skip existing is only supported in 2014 and later, and by specific renderers.
		if( IntMayaVersion() >= 2014 && ( $renderer == "ifmirayphotoreal" || $renderer == "mentalRay" || $renderer == "mayaSoftware" || $renderer == "mayaHardware" || $renderer == "mayaHardware2" || $renderer == "mayaVector") )
		{
			int $skipExistingFrames = `getAttr defaultRenderGlobals.skipExistingFrames`;
			fprint $fileId ( "SkipExistingFrames=" + $skipExistingFrames + "\n" );
		}

		string $baseOutputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
		fprint $fileId ( "OutputFilePath=" + $baseOutputFilePath + "\n" );
		if( IsRenderLayersOn() && !$submitEachRenderLayer )
		{
			fprint $fileId ( "OutputFilePrefix=\n" );
		}
		else if( $jobType == $MaxwellExportJobType )
		{
			fprint $fileId ( "OutputFilePrefix=\n" );
		}
		else
		{
			string $mayaOutputFilePrefix = GetMayaOutputPrefix( $camera, $currentRenderLayer );
			if( $jobType == $MayaRenderJobType && $regionRendering )
			{

				int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
				if($regionType == $TileRegionRenderType)
				{
					$mayaOutputFilePrefix = GetTileOutputPrefix( $mayaOutputFilePrefix, $currX, $currY, $tilesInX, $tilesInY, $renderer );
				}
				else
				{
					$mayaOutputFilePrefix = GetJigsawOutputPrefix( $mayaOutputFilePrefix, $currTile, $renderer );
				}
			}

			fprint $fileId ( "OutputFilePrefix=" + $mayaOutputFilePrefix + "\n" );
		}

		//fprint $fileId ( "MotionBlur=" + GetMotionBlur() + "\n" );

		// If the user has specified a camera, make it the default
		fprint $fileId ( "Camera=" + $camera + "\n" );

		// Now list all the camera options
		fprint $fileId ("Camera0=\n");
		string $cameraNames[] = `listTransforms -cameras`;
		for( $n = 1 ; $n <= size($cameraNames); $n++ )
		{
			fprint $fileId ( "Camera" + $n + "=" + $cameraNames[ $n - 1 ] + "\n" );
		}

		string $sceneFilePath = CheckSlashes( `file -q -sceneName` );
		int $submitMayaSceneFile = `checkBox -q -value frw_submitMayaScene`;
		if( !$submitMayaSceneFile )
		{
			fprint $fileId ( "SceneFile=" + $sceneFilePath + "\n" );
		}

		int $ignoreError211 = `checkBox -q -value frw_ignoreError211`;
		fprint $fileId ( "IgnoreError211=" + $ignoreError211 + "\n" );

		if( $useMayaBatchPlugin )
		{
			int $useLocalAssetCaching = `checkBox -q -value frw_useLocalAssetCaching`;
			fprint $fileId ( "UseLocalAssetCaching=" + $useLocalAssetCaching + "\n" );
		}

		fclose $fileId;


		string $argList[];
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;
		if( $submitMayaSceneFile )
		{
			$argList[size($argList)] = $sceneFilePath;
			string $xgenFiles[] = getXGenFiles();
			// add xgen files to job params and command
			for($xgenPath in $xgenFiles)
			{
				$argList[size($argList)] = $xgenPath;
			}
		}
		if( $jobType == $MayaScriptJobType)
		{
			string $result = `textFieldGrp -q -tx frw_mayaScriptJob`;
			$argList[size($argList)] = $result;
		}

		// Submit the job to Deadline
		string $submissionCommandFile = CreateArgumentsFile( $argList );
		$submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
	}

	// Get the job id to return
	string $jobId = "";
	string $resultArray[];
	$resultArray = stringToStringArray( $submitResults, "\n" );
	for( $n = 0; $n < size($resultArray); $n++ )
	{
		if( startsWith( $resultArray[$n], "JobID=" ) )
		{
			$jobId = substituteAllString( $resultArray[$n], "JobID=", "" );
			break;
		}
	}

	// Specify which renderer is being used.
	if( $jobType == $MentalRayExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: mentalRayExport\n";
	}
	else if( $jobType == $VRayExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: vrayExport\n";
	}
	else if( $jobType == $RendermanExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: rendermanExport\n";
	}
	else if( $jobType == $ArnoldExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: arnoldExport\n";
	}
	else if( $jobType == $MaxwellExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: maxwellExport\n";
	}
	else if( $jobType == $BifrostSimulationJobType )
	{
		$submitResults = $submitResults + "\n\nCreating bifrost simulation\n";
	}
	else if( $jobType == $AlembicExportJobType )
	{
		$submitResults = $submitResults + "\n\nExporting to Alembic format\n";
	}
	else if( $jobType == $MayaScriptJobType )
	{
		$submitResults = $submitResults + "\n\nRunning Maya Script Job\n";
	}
	else if( $jobType == $GeometryCachingJobType )
	{
		$submitResults = $submitResults + "\n\nRunning Geometry cache job\n";
	}
	else if( $jobType == $FluidCachingJobType )
	{
		$submitResults = $submitResults + "\n\nRunning Fluid cache job\n";
	}
	else
	{
		$submitResults = $submitResults + "\n\nUsing renderer: " + $renderer + "\n";
	}

	// Show results
	if( $showDialog )
	{
		confirmDialog -title "Submission Results" -parent $DeadlineSubmitterWindow -message $submitResults -button "Ok";
	}
	else
	{
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	}

	return $jobId;
}

proc int SetupDependentTileAnimationAssemblerJob(string $renderer, string $jobIds[], string $currentRenderLayer, string $currCamera)
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;
	global int $JigsawRegionRenderType;
	global int $TileRegionRenderType;

	int $jobCount = 0;
	int $totalTiles = 0;

	string $elements[] = {""};
	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	string $ext = "";
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
	int $overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;

	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];
	if( $renderer == "vray" )
	{
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.
	}

	if( $submitEachRenderLayer )
	{
		if($overrideLayerSettings)
		{
			$field = "frw_FrameList_" + $currentRenderLayer;
			$frameList = `textFieldGrp -q -text $field`;
		}
		else
		{
			int $range[] = GetFrameRange();
			int $fromFrame = $range[0];
			int $toFrame = $range[1];
			int $byFrame = $range[2];

			$frameList = $fromFrame + "-" + $toFrame;
			if( $byFrame > 1 )
				$frameList = $frameList + "x" + $byFrame;
		}
	}

	int $frameRange[] = GetFramesArray($frameList);

	string $regionLeftValues[];
	string $regionRightValues[];
	string $regionTopValues[];
	string $regionBottomValues[];
	int $tilesInX = 0;
	int $tilesInY = 0;
	int $deltaX = 0;
	int $deltaY = 0;

	if ( $regionType == $JigsawRegionRenderType )
	{
		string $regionString = `getAttr defaultRenderGlobals.deadlineRegionLeft`;
		$regionLeftValues = stringToStringArray($regionString,";");

		$regionString = `getAttr defaultRenderGlobals.deadlineRegionRight`;
		$regionRightValues = stringToStringArray($regionString,";");

		$regionString = `getAttr defaultRenderGlobals.deadlineRegionTop`;
		$regionTopValues = stringToStringArray($regionString,";");

		$regionString = `getAttr defaultRenderGlobals.deadlineRegionBottom`;
		$regionBottomValues = stringToStringArray($regionString,";");

		$totalTiles = size( $regionLeftValues );
	}
	else if ( $regionType == $TileRegionRenderType )
	{
		$tilesInX = `intSliderGrp -q -v frw_tilesInX`;
		$tilesInY = `intSliderGrp -q -v frw_tilesInY`;
		$deltaX = floor (1.0 * $width / $tilesInX );
		$deltaY = floor (1.0 * $height / $tilesInY );
	}

	if( $renderer == "vray" )
	{
		$elements = getVRayElementNames();
	}
	else if( $renderer == "arnold" )
	{
		$elements = getArnoldElementNames();
	}
	else if( $renderer == "mentalRay" )
	{
		$elements = getMentalRayElementNames( $currentRenderLayer );
	}

	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );

	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	string $configFilenames[];
	string $submitFilename = "";
	string $jobFilename = "";
	string $configFilename = "";
	int $currTile = 0;

	string $jobIdString = stringArrayToString ($jobIds,",");

	for($element in $elements)
	{
		$configFilenames = {};

		string $jobName = `textFieldGrp -q -text frw_JobName`;
		if( $currentRenderLayer != "" )
		{
			$jobName += " - " + $currentRenderLayer;
		}

		if( $currCamera != "" )
		{
			$jobName += " - " + $currCamera;
		}

		if( $element != "" )
		{
			$jobName = $jobName + " - "+$element+" (Animation - Tile Assembly Job)";
		}
		else
		{
			$jobName = $jobName + " - (Animation - Tile Assembly Job)";
		}

		$submitFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_info.job" );
		$fileId = `fopen $submitFilename "w"`;

		if( $fileId == 0 )
		{
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
		}

		fprint $fileId ( "Plugin=DraftTileAssembler\n" );
		fprint $fileId ( "Name=" + $jobName + "\n" );
		fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
		fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_JobPriority` + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );

		fprint $fileId ( "IsFrameDependent=True\n" );

		int $curFile = 0;
		for( $frameNumber in $frameRange )
		{
			string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
			$outputPrefix = swapDeepExr( $outputPrefix );
			string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );

			fprint $fileId ( "OutputFilename"+$curFile+"=" +$outputFilename + "\n" );
			$curFile++;
		}

		fprint $fileId ( "JobDependencies=" + $jobIdString + "\n" );
		fprint $fileId ( "Frames="+$frameList+"\n" );

		fprint $fileId ( "ChunkSize=1\n" );

		if( `checkBox -q -value frw_isBlacklist` )
		{
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		}
		else
		{
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		}

		WriteIntegrationSettings( $fileId, 1 );

		fclose $fileId;

		$jobFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_job.job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
		{
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
		}
		int $errorOnMissing = `checkBox -q -v frw_submitTileErrorOnMissing`;
		int $tileMissingBackground = `checkBox -q -v frw_submitTileErrorOnMissingBackground`;
		string $missing = $errorOnMissing ? "true" : "false";
		string $missingBackground = $tileMissingBackground ? "true" : "false";
		fprint $fileId ( "ErrorOnMissing=" +$missing+ "\n" );
		fprint $fileId ( "ErrorOnMissingBackground="+$missingBackground+"\n" );
		fprint $fileId ( "CleanupTiles=" + `checkBox -q -v frw_submitTileCleanupJob` + "\n" );
		fprint $fileId ( "MultipleConfigFiles=true\n" );
		fclose $fileId;

		int $frameCount = 0;

		for($frameNumber in $frameRange)
		{
			string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
			string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
			string $base = basenameEx( $outputPrefix );

			string $dateString = `date -format "YYYY_MM_DD_hh_mm_ss"`;
			string $configDirectory = dirname( $outputFilename );

			if( $element == "" || $renderer == "vray" )
			{
				$configFilename = CheckSlashes( $configDirectory  + "/"+$base+"_config_"+$dateString+".txt" );
			}
			else
			{
				$configFilename = CheckSlashes( $configDirectory  + "/"+$base+"_"+$element+"_config_"+$dateString+".txt" );
			}
			sysFile -makeDir $configDirectory;

			$fileId = `fopen $configFilename "w"`;
			if( $fileId == 0 )
			{
				print( "Error in Deadline Submission Script: could not create " + $configFilename + "\n" );
			}

			fprint $fileId ( "\n" );
			fprint $fileId ( "ImageFileName=" + $outputFilename + "\n" );
			fprint $fileId ( "ImageWidth=" +$width+ "\n" );
			fprint $fileId ( "ImageHeight=" + $height + "\n" );

			string  $imfType = getImfImageType();
			if( TilesAreCropped( $renderer, $imfType ) )
			{
				fprint $fileId ( "TilesCropped=False\n" );
			}
			else
			{
				fprint $fileId ( "TilesCropped=True\n" );
			}

			int $currTile = 0;
			string $inputPrefix = "";
			string $inputImageFilename = "";

			if( $regionType == $JigsawRegionRenderType )
			{
				for( $i = 0; $i < $totalTiles; $i++ )
				{
					string $tileRegionLeft = $regionLeftValues[$i];
					string $tileRegionLeftArray[] = stringToStringArray($tileRegionLeft, ",");
					string $tileRegionRight = $regionRightValues[$i];
					string $tileRegionRightArray[] = stringToStringArray($tileRegionRight, ",");
					string $tileRegionTop = $regionTopValues[$i];
					string $tileRegionTopArray[] = stringToStringArray($tileRegionTop, ",");
					string $tileRegionBottom = $regionBottomValues[$i];
					string $tileRegionBottomArray[] = stringToStringArray($tileRegionBottom, ",");

					if( $tileRegionLeftArray[$frameCount] != "-1" )
					{
						$inputPrefix = GetJigsawOutputPrefix( $outputPrefix, $i, $renderer);
						$inputImageFilename = CheckSlashes( $outputFilePath  + "/" + $inputPrefix );

						int $currWidth = int($tileRegionRightArray[$frameCount])-int($tileRegionLeftArray[$frameCount]);
						int $currHeight = int($tileRegionBottomArray[$frameCount])-int($tileRegionTopArray[$frameCount]);
						int $top = int($tileRegionTopArray[$frameCount]);

						if( $renderer == "vray" )
						{
							$currWidth ++;
							$currHeight ++;
						}

						fprint $fileId ( "Tile"+$currTile+"FileName=" + $inputImageFilename + "\n");

						fprint $fileId ( "Tile"+$currTile+"X=" + ( $tileRegionLeftArray[$frameCount] ) + "\n" );
						fprint $fileId ( "Tile"+$currTile+"Y=" + ( $top ) + "\n" );

						fprint $fileId ( "Tile"+$currTile+"Width=" + ( $currWidth ) + "\n" );
						fprint $fileId ( "Tile"+$currTile+"Height=" + ( $currHeight ) + "\n" );
					}

					$currTile++;
				}
			}
			else if( $regionType == $TileRegionRenderType )
			{
				int $newY = -1;
				int $tempBottom = -1;

				for( $y = 1; $y <= $tilesInY; $y++ )
				{
					for( $x = 1; $x <= $tilesInX; $x++ )
					{
						$inputPrefix = GetTileOutputPrefix( $outputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
						$inputImageFilename = CheckSlashes( $outputFilePath  + "/" + $inputPrefix );

						$newY = $tilesInY - $y;
						if( $renderer == "vray" )
						{
							$newY = $y - 1;
						}

						$tempBottom = ( $deltaY * $newY );

						fprint $fileId ( "Tile" + $currTile + "FileName=" + $inputImageFilename + "\n" );
						fprint $fileId ( "Tile" + $currTile + "X=" + ( $deltaX * ( $x - 1 ) ) + "\n" );
						fprint $fileId ( "Tile" + $currTile + "Y=" + ( $tempBottom ) + "\n" );
						fprint $fileId ( "Tile" + $currTile + "Width=" + ( $deltaX ) + "\n" );
						fprint $fileId ( "Tile" + $currTile + "Height=" + ( $deltaY ) + "\n" );
						$currTile++;
					}
				}
			}

			fprint $fileId ( "TileCount=" + $currTile + "\n" );

			int $compType = `optionMenuGrp -q -select frw_compositeType`;
			string $oldImage;
			if($compType == $PreviousImageCompType)
			{
				$oldImage = $outputFilename;
				fprint $fileId ("BackgroundSource="+$oldImage+"\n");
			}
			else if($compType == $SelectedImageCompType)
			{
				$oldImage = `textFieldButtonGrp -q -text frw_submitTileCompositeOverName`;
				fprint $fileId ("BackgroundSource="+$oldImage+"\n");
			}
			fclose $fileId;
			stringArrayInsertAtIndex(`size($configFilenames)`, $configFilenames, $configFilename );
		}

		string $argList[];
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;
		for($conFile in $configFilenames)
		{
			$argList[size($argList)] = $conFile;
		}

		// Submit the job to Deadline
		string $submissionCommandFile = CreateArgumentsFile( $argList );
		string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
		// Show results
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
		$jobCount++;
	}

	return $jobCount;
}

proc int SetupDependentJigsawAssemblerJob(string $renderer, string $jobIds[], int $frameNumber, int $regionValues[], string $currentRenderLayer, string $currCamera)
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;

	string $elements[] = {""};

	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	string $ext = "";

	if( $renderer == "vray" )
	{
		$elements = getVRayElementNames();
	}
	else if( $renderer == "arnold" )
	{
		$elements = getArnoldElementNames();
	}
	else if( $renderer == "mentalRay" )
	{
		$elements = getMentalRayElementNames( $currentRenderLayer );
	}

	string $jobName = `textFieldGrp -q -text frw_JobName`;
	if( $currentRenderLayer != "" )
		$jobName += " - " + $currentRenderLayer;
	if( $currCamera != "" )
		$jobName += " - " + $currCamera;

	$jobName = $jobName + "(Frame " + $frameNumber + " - Tile Assembly Job)";

	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );

	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	string $configFilenames[];
	string $submitFilename = "";
	string $jobFilename = "";
	string $configFilename = "";

	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];;
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.

	int $totalTiles = size($regionValues)/4;
	int $currTile = 0;
	$submitFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=DraftTileAssembler\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_JobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );

	int $curFile = 0;
	for( $element in $elements  )
	{
		string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
		$outputPrefix = swapDeepExr( $outputPrefix );
		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		fprint $fileId ( "OutputFilename"+$curFile+"=" + $outputFilename + "\n" );
		$curFile++;
	}

	string $jobIdString = stringArrayToString ($jobIds,",");
	fprint $fileId ( "JobDependencies=" + $jobIdString + "\n" );

	fprint $fileId ( "Frames=0-"+(`size($elements)` -1)+"\n" );

	fprint $fileId ( "ChunkSize=1\n" );

	if( `checkBox -q -value frw_isBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );

	WriteIntegrationSettings( $fileId, 1 );

	fclose $fileId;
	$jobFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	int $errorOnMissing = `checkBox -q -v frw_submitTileErrorOnMissing`;
	int $tileMissingBackground = `checkBox -q -v frw_submitTileErrorOnMissingBackground`;
	string $missing = $errorOnMissing ? "true" : "false";
	string $missingBackground = $tileMissingBackground ? "true" : "false";
	fprint $fileId ( "ErrorOnMissing=" +$missing+ "\n" );
	fprint $fileId ("ErrorOnMissingBackground="+$missingBackground+"\n");
	fprint $fileId ( "CleanupTiles=" + `checkBox -q -v frw_submitTileCleanupJob` + "\n" );

	if( size($elements) > 1 )
		fprint $fileId ( "MultipleConfigFiles=true\n" );

	fclose $fileId;
	for($element in $elements)
	{
		string $dateString = `date -format "YYYY_MM_DD_hh_mm_ss"`;
		string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
		$outputPrefix = swapDeepExr( $outputPrefix );
		string $baseName =  basenameEx( $outputPrefix );

		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		string $configDirectory = dirname( $outputFilename );

		if( $element == "" || $renderer == "vray" )
			$configFilename = CheckSlashes( $configDirectory  + "/"+$baseName+"_config_"+$dateString+".txt" );
		else
			$configFilename = CheckSlashes( $configDirectory  + "/" + $baseName + "_" + $element + "_config_"+$dateString+".txt" );

		sysFile -makeDir $configDirectory;
		$fileId = `fopen $configFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $configFilename + "\n" );

		int $currTile = 0;
		fprint $fileId ( "\n" );
		fprint $fileId ( "TileCount=" +$totalTiles+ "\n" );
		fprint $fileId ( "ImageFileName=" + $outputFilename + "\n" );
		fprint $fileId ( "ImageWidth=" +$width+ "\n" );
		fprint $fileId ( "ImageHeight=" + $height + "\n" );

		string  $imfType = getImfImageType();
		if( TilesAreCropped( $renderer, $imfType ) )
		{
			fprint $fileId ( "TilesCropped=False\n" );
		}
		else
		{
			fprint $fileId ( "TilesCropped=True\n" );
		}
		for($i = 0; $i<size($regionValues)/4; $i++)
		{
			string $inputPrefix = GetJigsawOutputPrefix( $outputPrefix, $i, $renderer);
			string $inputImageFilename = CheckSlashes( $outputFilePath  + "/" + $inputPrefix );

			int $currWidth = $regionValues[$i*4+1]-$regionValues[$i*4];
			int $currHeight = $regionValues[$i*4+3]-$regionValues[$i*4+2];

			int $top = ($regionValues[$i*4+2]);
			if( $renderer == "vray" || $renderer == "ifmIrayPhotoreal" )
				$top = $height - ($regionValues[$i*4+3]);

			fprint $fileId ("Tile"+$currTile+"FileName=" + $inputImageFilename + "\n");
			fprint $fileId ( "Tile"+$currTile+"X="+($regionValues[$i*4])+"\n" );
			fprint $fileId ( "Tile"+$currTile+"Y="+($top)+"\n" );
			fprint $fileId ( "Tile"+$currTile+"Width="+($currWidth)+"\n" );
			fprint $fileId ( "Tile"+$currTile+"Height="+($currHeight)+"\n" );
			$currTile++;
		}

		int $compType = `optionMenuGrp -q -select frw_compositeType`;
		string $oldImage;
		if($compType == $PreviousImageCompType)
		{
			$oldImage = $outputFilename;
			fprint $fileId ("BackgroundSource="+$oldImage+"\n");
		}
		else if($compType == $SelectedImageCompType)
		{
			$oldImage = `textFieldButtonGrp -q -text frw_submitTileCompositeOverName`;
			fprint $fileId ("BackgroundSource="+$oldImage+"\n");
		}
		fclose $fileId;

		stringArrayInsertAtIndex(0, $configFilenames, $configFilename );

	}

	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;
	for($conFile in $configFilenames)
	{
		$argList[size($argList)] = $conFile;
	}

	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	return 1;
}

global proc int[] removeDuplicateIntegers(int $array[])
{
	int $index = 0;
	int $newarray[];
	for( $i = 0 ; $i < size($array) ; $i++ )
	{
		$entry = true;
		for( $j = 0 ; $j < $i ; $j++ )
		{
			if( $array[$i] == $array[$j] ) //duplicate
				$entry = false;
		}
		if( $entry == true )
		{
			$newarray[$index] = $array[$i];
			$index++;
		}
	}
	return $newarray;
}

global proc string[] getVRayElementNames()
{
	string $elementNames[] = {""};

	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	string $ext = "";

	string $REs[] = `ls -type VRayRenderElement -type VRayRenderElementSet`;
	if (`optionMenuGrp -exists vrayImageFormatMenu`)
		$ext = `optionMenuGrp -q -v vrayImageFormatMenu`;
	else
		$ext = `getAttr vraySettings.imageFormatStr`;
		if ($ext == "")
			$ext = "png";//for some reason this happens if you have not changed the format

	if( endsWith( $ext, $multichannel ) )
	{
		$ext = substring( $ext, 1, size( $ext ) - size( $multichannel ) );
		$isMultichannelExr = true;
	}
	int $enableAll = `getAttr "vraySettings.relements_enableall"`;
	int $useReferenced = `getAttr "vraySettings.relements_usereferenced"`;

	if( !$isMultichannelExr && $enableAll )
	{
		for($RE in $REs)
		{
			int $enabled = `getAttr ($RE+".enabled")`;
			int $isReferenced = `referenceQuery -isNodeReferenced $RE`;

			if($isReferenced == 1 && $useReferenced == 0)
				continue;

			if($enabled == 1)
			{
				string $reType = `getAttr ($RE+".vrayClassType")`;

				string $REName = "";
				if( $reType == "ExtraTexElement" || $reType == "MaterialSelectElement" )
				{
					string $RENameFunction[]  = `listAttr -st "vray_explicit_name_*" $RE`;
					$REName = `getAttr ($RE+"."+$RENameFunction[0])`;
					if( $REName == "" )
					{
						$RENameFunction = `listAttr -st "vray_name_*" $RE`;

						$REName = `getAttr ($RE+"."+$RENameFunction[0])`;

						if( $reType == "ExtraTexElement" )
						{
							string $textures[] = `listConnections( $RE+ ".vray_texture_extratex")`;
							if( size($textures) > 0 )
							{
								if( $REName != "" )
								{
									$REName+= "_";
								}
								$REName+=  $textures[0];
							}
						}
						else if ( $reType == "MaterialSelectElement" )
						{
							string $materials[] = `listConnections( $RE+ ".vray_mtl_mtlselect")`;
							if( size($materials) > 0 )
							{
								if( $REName != "" )
								{
									$REName+= "_";
								}
								$REName+= $materials[0];
							}
						}
					}
				}
				else
				{
					string $RENameFunction[]  = `listAttr -st "vray_name_*" $RE`;
					if( `size($RENameFunction)` == 0 )
					{
						$RENameFunction = `listAttr -st "vray_filename_*" $RE`;
					}
					$REName = `getAttr ($RE+"."+$RENameFunction[0])`;
				}

				$REName = substituteAllString($REName, " ", "_" );
				stringArrayInsertAtIndex( 0, $elementNames, $REName );
			}
		}

		int $separateAlpha = `getAttr "vraySettings.separateAlpha"`;
		if( $separateAlpha == 1 )
		{
			stringArrayInsertAtIndex( 0, $elementNames, "Alpha" );
		}
	}

	return $elementNames;
}

global proc string[] getMaxwellElementNames()
{
	string $elementNames[] = {""};
	int $embedChannels = `getAttr maxwellRenderOptions.embedAlpha`;

	if( !$embedChannels )
	{
		if( `getAttr maxwellRenderOptions.alphaChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "alpha" );

		if( `getAttr maxwellRenderOptions.deepChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "deep" );

		if( `getAttr maxwellRenderOptions.depthChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "zbuffer" );

		if( `getAttr maxwellRenderOptions.shadowChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "shadow" );

		if( `getAttr maxwellRenderOptions.objIDChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "object" );

		if( `getAttr maxwellRenderOptions.matIDChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "material" );

		if( `getAttr maxwellRenderOptions.motionVectorChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "motion" );

		if( `getAttr maxwellRenderOptions.roughnessChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "roughness" );

		if( `getAttr maxwellRenderOptions.fresnelChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "fresnel" );

		if( `getAttr maxwellRenderOptions.normalsChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "normals" );

		if( `getAttr maxwellRenderOptions.positionChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "position" );

		if( `getAttr maxwellRenderOptions.uvChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "uv" );

		if( `getAttr maxwellRenderOptions.customAlphaChannel` == 1 )
		{
			string $customChannelNameAttributes[] = `listAttr -st "*cn" -multi  maxwellRenderOptions.mxCustomAlphaChannels`;
			for( $nameAttr in $customChannelNameAttributes )
			{
				stringArrayInsertAtIndex(0,$elementNames, "customAlpha_"+`getAttr( "maxwellRenderOptions." + $nameAttr )` );
			}
		}
	}

	return $elementNames;
}

global proc string getMaxwellChannelExtension( int $index, int $isChannel )
{
	string $extension = "";
	if( ($index == 0 && $isChannel ) || ($index == 32 && !$isChannel ) )
	{
		$extension = "png";
	}
	else if( ($index == 1 && $isChannel ) || ($index == 8 && !$isChannel ) )
	{
		$extension = "jpg";
	}
	else if( ($index == 2 && $isChannel ) || ($index == 19 && !$isChannel ) )
	{
		$extension = "tga";
	}
	else if( ($index == 3 && $isChannel ) || ($index == 20 && !$isChannel ) )
	{
		$extension = "bmp";
	}
	else if( ($index == 4 && $isChannel ) || ($index == 3 && !$isChannel ) )
	{
		$extension = "tif";
	}
	else if( ($index == 5 && $isChannel ) || ($index == 31 && !$isChannel ) )
	{
		$extension = "exr";
	}
	else if( ($index == 6 && $isChannel ) || ($index == 35 && !$isChannel ) )
	{
		$extension = "hdr";
	}
	else if( ($index == 7 && $isChannel ) || ($index == 36 && !$isChannel ) )
	{
		$extension = "jp2";
	}
	return $extension;
}

global proc string swapDeepExr( string $inputPath)
{
	string $outputPath = $inputPath;
	if( endsWith( $outputPath, "deepexr" ) )
	{
		$outputPath = substring( $outputPath, 1, size( $outputPath ) - size( "deepexr" ) );
		$outputPath = $outputPath+"exr";
	}
	return $outputPath;
}

global proc string[] getArnoldElementNames()
{
	string $elementNames[] = {""};

	int $aovMode = `getAttr "defaultArnoldRenderOptions.aovMode"`;
	int $mergeAOV = `getAttr "defaultArnoldDriver.mergeAOVs"`;
	string $imfType = getImfImageType();
	if( $aovMode  )
	{
		if( !$mergeAOV )
		{
			$elementNames = {};
			string $AOVnames[] = `ls -type aiAOV`;
			for($aovName in $AOVnames)
			{
				int $enabled = `getAttr ($aovName+".enabled")`;
				if($enabled == 1)
				{
					stringArrayInsertAtIndex(0,$elementNames,`getAttr ($aovName+".name")`);
				}
			}
			stringArrayInsertAtIndex(0, $elementNames, "beauty" );
		}
	}

	return $elementNames;
}

global proc string[] getArnoldElements()
{
	string $elementNames[] = {""};

	int $aovMode = `getAttr "defaultArnoldRenderOptions.aovMode"`;
	int $mergeAOV = `getAttr "defaultArnoldDriver.mergeAOVs"`;
	string $imfType = getImfImageType();
	if( $aovMode  )
	{
		if( !$mergeAOV )
		{
			$elementNames = {};
			string $AOVnames[] = `ls -type aiAOV`;
			for($aovName in $AOVnames)
			{
				int $enabled = `getAttr ($aovName+".enabled")`;
				if($enabled == 1)
				{
					stringArrayInsertAtIndex(0,$elementNames,$aovName);
				}
			}
		}
	}

	return $elementNames;
}

global proc string[] getRedshiftElements()
{
	string $elementNames[] = {""};

	string $imfType = getImfImageType();
	int $forceExr = `getAttr "redshiftOptions.exrForceMultilayer"`;

	if( $imfType != "exr" || $forceExr == 0 )
	{
		string $REs[] = `ls -type RedshiftAOV`;

		for($RE in $REs)
		{
			int $enabled = `getAttr ($RE+".enabled")`;
			if($enabled == 1)
			{
				stringArrayInsertAtIndex(0,$elementNames,$RE);
			}
		}
	}

	return $elementNames;
}

global proc string[] getMentalRayElementNames( string $currentRenderLayer)
{
	string $elementNames[] = {""};
	//Format's in Maya are stored as integers.  For Mental ray EXR is stored as 51.
	int $exrFormat = 51;

	if( $currentRenderLayer != "" )
	{
		int $format = `getAttr defaultRenderGlobals.imageFormat`;
		string $prefix = `getAttr defaultRenderGlobals.imageFilePrefix`;

		//If the format is exr and there is not a renderPass token in the output prefix then the output is rendered as a single multichannel exr so we do not have to handle the elements separately.
		if ( $format != $exrFormat || `match "<RenderPass>" $prefix`!= "" )
		{
			string $renderLayers[] = {};
			$renderLayers = `ls -type renderLayer`;
			if( stringArrayContains($currentRenderLayer, $renderLayers) )
			{
				string $connectedPasses[] = `listConnections ($currentRenderLayer+".rps")`;
				if( size($connectedPasses) >0 )
				{
					$elementNames = {};
					stringArrayInsertAtIndex(0, $elementNames, "MasterBeauty" );
					for( $pass in $connectedPasses )
					{
						stringArrayInsertAtIndex(0,$elementNames,$pass );
					}
				}
			}
		}
	}

	return $elementNames;
}

proc int SetupDependentTileAssemblerJob( string $renderer, string $jobIds[], int $frameNumber, int $tilesInX, int $tilesInY, string $currentRenderLayer, string $currCamera )
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	if( $currentRenderLayer != "" )
		$jobName += " - " + $currentRenderLayer;
	if( $currCamera != "" )
		$jobName += " - " + $currCamera;

	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	if(!$singleRegionJob)
	{
		$jobName = $jobName + "(Tile Assembly Job)";
	}
	else
	{
		$jobName = $jobName + "(Frame " + $frameNumber + " - Tile Assembly Job)";
	}

	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );

	int $submitEachCamera = `checkBox -q -v frw_submitEachCamera`;

	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";

	string $elements[] = {""};

	if( $renderer == "vray" )
	{
		$elements = getVRayElementNames();
	}
	else if( $renderer == "arnold" )
	{
		$elements = getArnoldElementNames();
	}
	else if( $renderer == "mentalRay" )
	{
		$elements = getMentalRayElementNames( $currentRenderLayer );
	}

	string $renderableCameras[] = deadlineGetRenderableCameras( false );

	string $submitFilename = "";
	string $jobFilename = "";
	string $configFilenames[];
	string $configFilename = "";

	int $draftMultiFrames[];

	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.

	int $deltaX = floor (1.0 * $width / $tilesInX );
	int $deltaY = floor (1.0 * $height / $tilesInY );

	int $totalTiles = $tilesInX * $tilesInY;
	int $currTile = 0;
	$submitFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=DraftTileAssembler\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_JobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );

	int $curFile = 0;
	for( $element in $elements  )
	{
		string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		fprint $fileId ( "OutputFilename"+$curFile+"=" + $outputFilename + "\n" );
		$curFile++;
	}

	string $jobIdString = stringArrayToString ($jobIds,",");
	fprint $fileId ( "JobDependencies=" + $jobIdString + "\n" );

	if($singleRegionJob)
		fprint $fileId ( "Frames=0-"+(`size($elements)` -1)+"\n" );
	else
		fprint $fileId ("Frames=0-"+(size($draftMultiFrames)-1)+"\n");

	fprint $fileId ( "ChunkSize=1\n" );
	fprint $fileId ( "MachineLimit=1\n" );

	if( `checkBox -q -value frw_isBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );

	WriteIntegrationSettings( $fileId, 1 );

	fclose $fileId;
	$jobFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	int $errorOnMissing = `checkBox -q -v frw_submitTileErrorOnMissing`;
	string $missing = $errorOnMissing ? "true" : "false";
	fprint $fileId ( "ErrorOnMissing=" +$missing+ "\n" );
	fprint $fileId ( "CleanupTiles=" + `checkBox -q -v frw_submitTileCleanupJob` + "\n" );
	if ( size($elements) > 1 )
		fprint $fileId ( "MultipleConfigFiles=true\n" );

	fclose $fileId;

	for( $element in $elements)
	{
		string $dateString = `date -format "YYYY_MM_DD_hh_mm_ss"`;
		string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
		$outputPrefix = swapDeepExr( $outputPrefix );
		string $baseName =  basenameEx( $outputPrefix );

		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		string $configDirectory = dirname( $outputFilename );

		if( $element == "" || $renderer == "vray" )
			$configFilename = CheckSlashes( $configDirectory  + "/"+$baseName+"_config_"+$dateString+".txt" );
		else
			$configFilename = CheckSlashes( $configDirectory  + "/" + $baseName + "_" + $element + "_config_"+$dateString+".txt" );

		sysFile -makeDir $configDirectory;
		$fileId = `fopen $configFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $configFilename + "\n" );

		int $currTile = 0;
		fprint $fileId ( "\n" );
		fprint $fileId ( "TileCount=" +$totalTiles+ "\n" );
		fprint $fileId ( "ImageFileName=" + $outputFilename + "\n" );
		fprint $fileId ( "ImageWidth=" +$width+ "\n" );
		fprint $fileId ( "ImageHeight=" + $height + "\n" );

		string  $imfType = getImfImageType();
		if( TilesAreCropped( $renderer, $imfType ) )
		{
			fprint $fileId ( "TilesCropped=False\n" );
		}
		else
		{
			fprint $fileId ( "TilesCropped=True\n" );
		}

		for( $y = 1; $y <= $tilesInY; $y++ )
		{
			for( $x = 1; $x <= $tilesInX; $x++ )
			{
				int $newY = $tilesInY - $y;
				if( $renderer == "vray" || $renderer == "ifmIrayPhotoreal" )
				{
					$newY = $y-1;
				}

				int $tempBottom;
				$tempBottom = ($deltaY * $newY);
				string $inputPrefix = GetTileOutputPrefix( $outputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
				if($singleRegionJob )
				{
					string $inputImageFilename = CheckSlashes( $outputFilePath  + "/" + $inputPrefix );

					fprint $fileId ("Tile"+$currTile+"FileName="+$inputImageFilename+"\n");
					fprint $fileId ("Tile"+$currTile+"="+$inputImageFilename+"\n");

				}
				else
				{
					string $ext;
					$ext = `fileExtension $inputPrefix`;

					string $postFix = "."+$frameNumber+"."+$ext;

					string $base = basename( $inputPrefix, $postFix );
					fprint $fileId ("Tile"+$currTile+"Prefix="+$base+"\n");
				}

				fprint $fileId ( "Tile"+$currTile+"X="+($deltaX * ( $x - 1 ))+"\n" );
				fprint $fileId ( "Tile"+$currTile+"Y="+($tempBottom)+"\n" );

				//if last tile increase width to remaining amount... like what we are doing in render job.
				if( $x == $tilesInX )
				{
					int $finalWidth = $width - ( $deltaX * ( $x - 1 ) );
					fprint $fileId ( "Tile"+$currTile+"Width="+($finalWidth)+"\n" );
				}
				else
				{
					fprint $fileId ( "Tile"+$currTile+"Width="+($deltaX)+"\n" );
				}

				if( $y == $tilesInY )
				{
					int $finalHeight = $height - ( $deltaY * ( $y - 1 ) );
					fprint $fileId ( "Tile"+$currTile+"Height="+($finalHeight)+"\n" );
				}
				else
				{
					fprint $fileId ( "Tile"+$currTile+"Height="+($deltaY)+"\n" );
				}


				$currTile++;
			}
		}
		fclose $fileId;

		stringArrayInsertAtIndex(0, $configFilenames, $configFilename );
	}

	// Submit the job to Deadline
	string $submissionCommand = "\"" + $submitFilename + "\" \"" + $jobFilename + "\"";

	for($conFile in $configFilenames)
	{
		$submissionCommand = $submissionCommand+" \""+$conFile+"\"";
	}

	string $argList[] ;
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;

	for($conFile in $configFilenames)
	{
		$argList[size($argList)] = $conFile;
	}

	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	return 1;
}

// Sets some region rendering settings before submitting the job to Deadline.
proc int SetupRegionRenderingJob( string $renderer, string $cameraOverride )
{
	global string $DeadlineSubmitterWindow;
	global int $MayaRenderJobType;
	global int $JigsawRegionRenderType;
	global int $TileRegionRenderType;

	int $submitCounter = 0;

	AddStringAttribute( "deadlineRegionLeft" );
	AddStringAttribute( "deadlineRegionTop" );
	AddStringAttribute( "deadlineRegionRight" );
	AddStringAttribute( "deadlineRegionBottom" );
	AddLongAttribute( "deadlineCurrX" );
	AddLongAttribute( "deadlineCurrY" );
	AddLongAttribute( "deadlineCurrTile" );

	AddStringAttribute( "deadlineRegionSingleLeft" );
	AddStringAttribute( "deadlineRegionSingleTop" );
	AddStringAttribute( "deadlineRegionSingleRight" );
	AddStringAttribute( "deadlineRegionSingleBottom" );
	AddLongAttribute( "deadlineRegionSingleTiles" );

	int $taskLimit = int(CallDeadlineCommand( "-getjobtasklimit", true ));
	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.

	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`;

	int $deltaX = floor (1.0 * $width / $tilesInX );
	int $deltaY = floor (1.0 * $height / $tilesInY );

	int $totalTiles = $tilesInX * $tilesInY;
	int $currTile = 0;

	string $camera = "";
	if( $cameraOverride != "" )
		$camera = $cameraOverride;
	else
	{
		string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
		string $cameraNames[] = `listTransforms -cameras`;
		for( $cameraName in $cameraNames )
		{
			if( $cameraName == $selectedCamera )
			{
				$camera = $selectedCamera;
				break;
			}
		}
	}

	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	int $regions[];
	int $assemblyRegions[];

	string $jobIdList[];
	if( !$singleRegionJob )
	{
		if($regionType == $TileRegionRenderType)
		{

			for( $y = 1; $y <= $tilesInY; $y++ )
			{
				for( $x = 1; $x <= $tilesInX; $x++ )
				{
					$currTile++;

					int $newY = $y;
					if( IsRegionRenderingInverted( $renderer ) )
						$newY = $tilesInY - $y + 1;

					setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" ($deltaX * ( $x - 1 ));
					setAttr defaultRenderGlobals.deadlineRegionTop -type "string" ($deltaY * ( $newY - 1 ));

					int $tempRight;
					if( $x == $tilesInX )
						$tempRight = $width - 1;
					else
						$tempRight = ($deltaX * $x) - 1;

					if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" )
						$tempRight++;

					setAttr defaultRenderGlobals.deadlineRegionRight -type "string" $tempRight;

					int $tempBottom;
					if( $newY == $tilesInY )
						$tempBottom = $height - 1;
					else
						$tempBottom = ($deltaY * $newY) - 1;

					if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" )
						$tempBottom++;

					if( $renderer == "vray" )
						$tempBottom = $tempBottom + 1;

					setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" $tempBottom;

					setAttr defaultRenderGlobals.deadlineCurrX $x;
					setAttr defaultRenderGlobals.deadlineCurrY $y;
					setAttr defaultRenderGlobals.deadlineCurrTile $currTile;

					string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 1, $MayaRenderJobType, $camera );
					if($jobId != "")
					{
						stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId) ;
						$submitCounter++;
					}
				}
			}
		}
		else
		{

			if(catchQuiet(`python("jigsawThread.isAlive()")`))
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}

			if(`python("jigsawThread.isAlive()")`)
			{
				python("jigsawThread.requestSave()");
				int $invert = IsRegionRenderingInverted( $renderer );
				$regions = `python("jigsawThread.getRegions(" + $invert + ")")`;
				$assemblyRegions = `python("jigsawThread.getRegions()")`;
			}
			else
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}

			string $regionLeftValues[];
			string $regionRightValues[];
			string $regionTopValues[];
			string $regionBottomValues[];
			string $frameList = `textFieldGrp -q -text frw_FrameList`;
			int $frameRange[] = GetFramesArray($frameList);
			int $numRegions = size($regions)/4;

			int $renderHeight = `getAttr "defaultResolution.height"`;
			int $renderWidth = `getAttr "defaultResolution.width"`;

			for($curRegion =0;$curRegion<$numRegions;$curRegion++)
			{
				int $top = ($regions[$curRegion*4+2]);
				int $right = ($regions[$curRegion*4+1]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "ifmIrayPhotoreal" )
				{
					$right++;
				}

				int $left = ($regions[$curRegion*4]);
				int $bottom = ($regions[$curRegion*4+3]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" )
				{
					$bottom++;
				}

				if($renderer == "arnold")
				{
					if( $right == $renderWidth )
					{
						$right -=1;
					}

					if( $bottom == $renderHeight )
					{
						$bottom -=1;
					}
				}

				if(`size($regionLeftValues)` == $curRegion)
				{
					stringArrayInsertAtIndex($curRegion, $regionLeftValues, ""+$left);
					stringArrayInsertAtIndex($curRegion, $regionTopValues, ""+ $top);
					stringArrayInsertAtIndex($curRegion, $regionRightValues, ""+ $right);
					stringArrayInsertAtIndex($curRegion, $regionBottomValues, ""+ $bottom);
				}
				else
				{
					$regionLeftValues[$curRegion] = $regionLeftValues[$curRegion] +","+ $left;
					$regionTopValues[$curRegion] = $regionTopValues[$curRegion] +","+ $top;
					$regionRightValues[$curRegion] = $regionRightValues[$curRegion] +","+ $right;
					$regionBottomValues[$curRegion] = $regionBottomValues[$curRegion] +","+ $bottom;
				}
			}

			for( $i=0; $i<size($regionLeftValues);$i++)
			{
				setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" ($regionLeftValues[$i]);
				setAttr defaultRenderGlobals.deadlineRegionTop -type "string" ($regionTopValues[$i]);
				setAttr defaultRenderGlobals.deadlineRegionRight -type "string" ($regionRightValues[$i]);
				setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" ($regionBottomValues[$i]);

				setAttr defaultRenderGlobals.deadlineCurrTile $currTile;
				string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 1, $MayaRenderJobType, $camera );
				if($jobId != "")
				{
					stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId) ;
					$submitCounter++;
				}
				$currTile++;
			}
			string $assemblyRegionLeftValues[];
			string $assemblyRegionRightValues[];
			string $assemblyRegionTopValues[];
			string $assemblyRegionBottomValues[];

			for($curRegion =0;$curRegion<$numRegions;$curRegion++)
			{
				int $assemblyTop = ($assemblyRegions[$curRegion*4+2]);
				int $assemblyRight = ($assemblyRegions[$curRegion*4+1]);
				int $assemblyLeft = ($assemblyRegions[$curRegion*4]);
				int $assemblyBottom = ($assemblyRegions[$curRegion*4+3]);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionLeftValues, ""+$assemblyLeft);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionTopValues, ""+ $assemblyTop);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionRightValues, ""+ $assemblyRight);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionBottomValues, ""+ $assemblyBottom);
			}

			string $regionString = stringArrayToString($assemblyRegionLeftValues,";");
			setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" $regionString;
			$regionString = stringArrayToString($assemblyRegionTopValues,";");
			setAttr defaultRenderGlobals.deadlineRegionTop -type "string" $regionString;
			$regionString = stringArrayToString($assemblyRegionRightValues,";");
			setAttr defaultRenderGlobals.deadlineRegionRight -type "string" $regionString;
			$regionString = stringArrayToString($assemblyRegionBottomValues,";");
			setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" $regionString;
		}

		int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
		if( $submitDependentJob && $submitCounter > 0 )
		{
			int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
			if( IsRenderLayersOn() && !$submitEachRenderLayer )
			{
				// Store the currently selected render layer
				string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
				string $renderLayerList[] = getRenderableRenderLayers();

				// Loop through the render layer if the checkbox is on
				for( $layer in $renderLayerList )
				{
					// Select the render layer to make sure the render settings are updated
					if( !catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
					{
						if( $camera != "" )
						{
							int $count = SetupDependentTileAnimationAssemblerJob( $renderer, $jobIdList, $layer, $camera );
							$submitCounter += $count;
						}
						else
						{
							string $cameraNames[] = deadlineGetRenderableCameras( false );
							for( $cameraName in $cameraNames )
							{
								int $count = SetupDependentTileAnimationAssemblerJob( $renderer, $jobIdList, $layer, $cameraName );
								$submitCounter += $count;
							}
						}
					}
				}

				// Reselect the current render layer
				editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
			}
			else
			{
				string $currentRenderLayer = "";
				if( IsRenderLayersOn() && $submitEachRenderLayer )
					$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;

				if( $camera != "" )
				{
					int $count = SetupDependentTileAnimationAssemblerJob( $renderer, $jobIdList, $currentRenderLayer, $camera );
					$submitCounter += $count;
				}
				else
				{
					string $cameraNames[] = deadlineGetRenderableCameras( false );
					for( $cameraName in $cameraNames )
					{
						int $count = SetupDependentTileAnimationAssemblerJob( $renderer, $jobIdList, $currentRenderLayer, $cameraName );
						$submitCounter += $count;
					}
				}
			}
		}
	}
	else
	{
		setAttr defaultRenderGlobals.deadlineRegionSingleLeft -type "string" "";
		setAttr defaultRenderGlobals.deadlineRegionSingleTop -type "string" "";
		setAttr defaultRenderGlobals.deadlineRegionSingleRight -type "string" "";
		setAttr defaultRenderGlobals.deadlineRegionSingleBottom -type "string" "";

		if($regionType == $TileRegionRenderType)
		{
			if($tilesInX * $tilesInY > $taskLimit)
			{
				confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Unable to submit job with " + ($tilesInX * $tilesInY) + " tasks.  Task Count exceeded Job Task Limit of "+$taskLimit) -button "Close";
				return 0;
			}

			for( $y = 1; $y <= $tilesInY; $y++ )
			{
				for( $x = 1; $x <= $tilesInX; $x++ )
				{
					int $newY = $y;
					if( IsRegionRenderingInverted( $renderer ) )
						$newY = $tilesInY - $y + 1;

					string $regionSingleLeft = `getAttr defaultRenderGlobals.deadlineRegionSingleLeft`;
					$regionSingleLeft += "RegionLeft" + $currTile + "=" + ($deltaX * ( $x - 1 )) + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleLeft -type "string" $regionSingleLeft;

					string $regionSingleTop = `getAttr defaultRenderGlobals.deadlineRegionSingleTop`;
					$regionSingleTop += "RegionTop" + $currTile + "=" + ($deltaY * ( $newY - 1 )) + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleTop -type "string" $regionSingleTop;

					int $tempRight;
					if( $x == $tilesInX )
						$tempRight = $width - 1;
					else
						$tempRight = ($deltaX * $x) - 1;

					if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "ifmIrayPhotoreal" )
						$tempRight++;

					string $regionSingleRight = `getAttr defaultRenderGlobals.deadlineRegionSingleRight`;
					$regionSingleRight += "RegionRight" + $currTile + "=" + $tempRight + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleRight -type "string" $regionSingleRight;

					int $tempBottom;
					if( $newY == $tilesInY )
						$tempBottom = $height - 1;
					else
						$tempBottom = ($deltaY * $newY) - 1;

					if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS"|| $renderer == "ifmIrayPhotoreal" )
						$tempBottom++;

					string $regionSingleBottom = `getAttr defaultRenderGlobals.deadlineRegionSingleBottom`;
					$regionSingleBottom += "RegionBottom" + $currTile + "=" + $tempBottom + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleBottom -type "string" $regionSingleBottom;

					$currTile++;
				}
			}
		}
		else
		{
			if(catchQuiet(`python("jigsawThread.isAlive()")`))
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}

			if(`python("jigsawThread.isAlive()")`)
			{
				python("jigsawThread.requestSave()");
				int $invert = IsRegionRenderingInverted( $renderer );
				$regions = `python("jigsawThread.getRegions(" + $invert + ")")`;
				$assemblyRegions = `python("jigsawThread.getRegions()")`;
			}
			else
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}

			if(size($regions)/4 > $taskLimit)
			{
				confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Unable to submit job with " + (size($regions)/4) + " tasks.  Task Count exceeded Job Task Limit of "+$taskLimit) -button "Close";
				return 0;
			}

			int $renderHeight = `getAttr "defaultResolution.height"`;
			for( $i=0; $i<size($regions)/4;$i++)
			{
				int $tempRight = ($regions[$i*4+1]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "ifmIrayPhotoreal" )
					$tempRight++;

				int $tempBottom = ($regions[$i*4+3]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "ifmIrayPhotoreal" )
						$tempBottom++;

				string $regionSingleLeft = `getAttr defaultRenderGlobals.deadlineRegionSingleLeft`;
				$regionSingleLeft += "RegionLeft" + $currTile + "=" + ($regions[$i*4]) + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleLeft -type "string" $regionSingleLeft;

				string $regionSingleRight = `getAttr defaultRenderGlobals.deadlineRegionSingleRight`;
				$regionSingleRight += "RegionRight" + $currTile + "=" + $tempRight + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleRight -type "string" $regionSingleRight;

				string $regionSingleTop = `getAttr defaultRenderGlobals.deadlineRegionSingleTop`;
				$regionSingleTop += "RegionTop" + $currTile + "=" + ($regions[$i*4+2]) + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleTop -type "string" $regionSingleTop;

				string $regionSingleBottom = `getAttr defaultRenderGlobals.deadlineRegionSingleBottom`;
				$regionSingleBottom += "RegionBottom" + $currTile + "=" + $tempBottom + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleBottom -type "string" $regionSingleBottom;

				$currTile++;
			}
		}

		setAttr defaultRenderGlobals.deadlineRegionSingleTiles $currTile;

		string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 1, $MayaRenderJobType, $camera );
		if( $jobId != "" )
		{
			stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId);
			$submitCounter++;
		}

		int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
		if( $submitDependentJob && $submitCounter > 0 )
		{
			int $frameNumber = `intSliderGrp -q -v frw_tileSingleFrame`;

			int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
			if( IsRenderLayersOn() && !$submitEachRenderLayer )
			{
				// Store the currently selected render layer
				string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
				string $renderLayerList[] = getRenderableRenderLayers();

				// Loop through the render layer if the checkbox is on
				for( $layer in $renderLayerList )
				{
					// Select the render layer to make sure the render settings are updated
					if( !catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
					{
						if( $camera != "" )
						{
							if($regionType == $TileRegionRenderType)
							{
								int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $layer, $camera );
								$submitCounter += $count;
							}
							else
							{

								int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $layer, $camera );
								$submitCounter += $count;
							}
						}
						else
						{

							string $cameraNames[] = deadlineGetRenderableCameras( false );
							for( $cameraName in $cameraNames )
							{
								string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $frameNumber, $layer, $cameraName, "" ) );

								if($regionType == $TileRegionRenderType)
								{
									int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $layer, $cameraName );
									$submitCounter += $count;
								}
								else
								{
									int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $layer, $cameraName );
									$submitCounter += $count;
								}
							}
						}
					}
				}

				// Reselect the current render layer
				editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
			}
			else
			{
				string $currentRenderLayer = "";
				if( IsRenderLayersOn() && $submitEachRenderLayer )
					$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;

				if( $camera != "" )
				{
					if($regionType == $TileRegionRenderType)
					{
						int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $currentRenderLayer, $camera );
						$submitCounter += $count;
					}
					else
					{
						int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $currentRenderLayer, $camera );
						$submitCounter += $count;
					}
				}
				else
				{
					string $cameraNames[] = deadlineGetRenderableCameras( false );
					for( $cameraName in $cameraNames )
					{
						string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $cameraName, "") );
						if($regionType == $TileRegionRenderType)
						{
							int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $currentRenderLayer, $cameraName );
							$submitCounter += $count;
						}
						else
						{
							int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $currentRenderLayer, $cameraName );
							$submitCounter += $count;
						}
					}
				}
			}
		}
	}
	return $submitCounter;
}

proc int SetupMentalRayExportJob( string $renderer )
{
	global int $MentalRayExportJobType;

	int $submitCounter = 0;

	string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $MentalRayExportJobType, "" );

	$submitCounter++;

	int $submitDependentJob = `checkBox -q -v frw_submitMentalRayJob`;
	if( $submitDependentJob )
	{
		string $frameList = `textFieldGrp -q -text frw_FrameList`;
		string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );

		int $perlayer = `checkBoxGrp -query -value1 MayatomrExport_FilePerLayer`;
		int $perframe = `checkBoxGrp -query -value1 MayatomrExport_FilePerFrame`;
		int $padframe = 0;
		int $format = 0;
		if( $perframe )
		{
			$format = `optionMenuGrp -q -select MayatomrExport_FrameExtension`;
			$padframe = `intFieldGrp -q -value1 MayatomrExport_FramePadding`;
			if ($padframe > 9)
				$padframe = 9;
		}

		string $inputPath = CheckSlashes( `textFieldGrp -q -text frw_mentalRayFilePath` );
		string $inputDirectory = dirname( $inputPath ) + "/";
		string $inputFilename = basenameEx( $inputPath );
		string $inputExtension = fileExtension( $inputPath );

		string $padding = "";
		if( $perframe )
		{
			$padding = match( "[0-9]+", $frameList );
			while( size($padding) < $padframe )
				$padding = "0" + $padding;
		}


		string $renderLayerList[] = getRenderableRenderLayers();
		for( $i = 0; $i < size( $renderLayerList ); $i++ )
		{
			string $jobName = `textFieldGrp -q -text frw_JobName`;

			if( $perlayer )
			{
					$jobName = $jobName + " - " + $renderLayerList[$i];
			}

			string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";

			string $submitFilename = CheckSlashes( $tempDir + "/mr_deadline_info.job" );
			$fileId = `fopen $submitFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

			fprint $fileId ( "Plugin=MentalRay\n" );
			fprint $fileId ( "Name=" + $jobName + "\n" );
			fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
			fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
			fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineMentalPool` + "\n" );
			fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineMentalSecondaryPool` + "\n" );
			fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_MentalJobPriority` + "\n" );
			fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_MentalOnComplete` + "\n" );
			fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_MentalSlaveTimeout` + "\n" );
			fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_MentalMinSlaveTimeout` + "\n" );
			fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_MentalAutoTaskTimeout` + "\n" );
			fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_MentalConcurrentTasks` + "\n" );
			fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
			fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_MentalGroup` + "\n" );
			fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_MentalLimitCount` + "\n" );
			fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_MentalLimitGroups` + "\n" );
			fprint $fileId ( "OutputDirectory0=" + $outputFilePath + "\n" );
			fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
			fprint $fileId ( "Frames=" + $frameList + "\n" );
			fprint $fileId ( "ChunkSize=1\n" );

			if( `checkBox -q -value frw_MentalIsBlacklist` )
				fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_MentalMachineList` + "\n" );
			else
				fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_MentalMachineList` + "\n" );

			WriteIntegrationSettings( $fileId, 1 );

			fclose $fileId;

			$layer = "";

			// The layer name is only appended if there is more than one layer in the list.
			if( $perlayer && IsRenderLayersOn() )
			{

				$layer = GetRenderLayerDisplayName( $renderLayerList[$i] );
				$layer = "_" + $layer;
			}

			if( $perframe )
			{
				if( $format == 1 )
					$inputPath = $inputDirectory + $inputFilename + $layer + "." + $inputExtension + "." + $padding;
				else if( $format == 2 )
					$inputPath = $inputDirectory + $inputFilename + $layer + "." + $padding + "." + $inputExtension;
				else
					$inputPath = $inputDirectory + $inputFilename + $layer + "." + $padding;
			}
			else
				$inputPath = $inputDirectory + $inputFilename + $layer + "." + $inputExtension;

			string $jobFilename = CheckSlashes( $tempDir + "/mr_deadline_job.job" );
			$fileId = `fopen $jobFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

			fprint $fileId ( "InputFile=" + $inputPath + "\n" );
			fprint $fileId ( "SeparateFilesPerFrame=" + $perframe + "\n" );
			if( $perframe )
				fprint $fileId ( "StartFrameOffset=" + `intSliderGrp -q -v frw_mentalRayOffset` + "\n" );
			fprint $fileId ( "OutputPath=" + $outputFilePath + "\n" );
			fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_mentalRayThreads` + "\n" );
			fprint $fileId ( "LocalRendering=" + `checkBox -q -v frw_mentalRayLocalRendering` + "\n" );
			fprint $fileId ( "Build=" + `optionMenuGrp -q -value frw_mentalRayBuild` + "\n" );
			fprint $fileId ( "Verbose=5\n" );
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_mentalRayArgs` + "\n" );
			fclose $fileId;

			string $argList[];
			$argList[0] = $submitFilename;
			$argList[1] = $jobFilename;

			// Submit the job to Deadline
			string $submissionCommandFile = CreateArgumentsFile( $argList );
			string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

			// Show results
			print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );

			$submitCounter++;

			if( !$perlayer )
				break;
		}
	}

	return $submitCounter;
}

proc int SubmitDependentVRayJob( string $postfix, string $jobId )
{
	int $submitCounter = 0;

	int $submitLayers = false;
	string $currentRenderLayer = "";
	string $renderLayerList[] = {""};

	if( IsRenderLayersOn() )
	{
		$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
		$renderLayerList = getRenderableRenderLayers();
		$submitLayers = true;
	}

	for( $layer in $renderLayerList )
	{
		string $jobName = `textFieldGrp -q -text frw_JobName`;
		if( $postfix != "" )
			$jobName = $jobName + " (" + $postfix + ")";

		int $perframe = `getAttr( "vraySettings.misc_eachFrameInFile" )`;
		string $frameList = `textFieldGrp -q -text frw_FrameList`;

		string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
		string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", "", "" ) );
		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );

		string $inputPath = CheckSlashes( `textFieldGrp -q -text frw_vrayFilePath` );
		string $inputDirectory = dirname( $inputPath ) + "/";
		string $inputFilename = basenameEx( $inputPath );
		string $inputPadding = "";
		string $inputExtension = fileExtension( $inputPath );
		if( $inputExtension == "" )
			$inputExtension = "vrscene";

		if( $perframe )
			$inputPadding = "_0000";
		if( $postfix != "" )
			$inputFilename = $inputFilename + "_" + $postfix;

		if( $submitLayers )
		{
			// Select the render layer to make sure the render settings are updated
			if( catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
				continue;


			string $renderLayerName = GetRenderLayerDisplayName( $layer );

			$jobName = $jobName + " - " + $renderLayerName;
			$inputFilename = $inputFilename + "_" + $renderLayerName;
		}

		$inputPath = $inputDirectory + $inputFilename + $inputPadding + "." + $inputExtension;

		string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";

		string $submitFilename = CheckSlashes( $tempDir + "/vray_deadline_info.job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

		fprint $fileId ( "Plugin=Vray\n" );
		fprint $fileId ( "Name=" + $jobName + "\n" );
		string $batchName = `textFieldGrp -q -text frw_JobName`;
		//This will group the jobs created later in the same batch
		fprint $fileId ( "BatchName=" + $batchName + "\n" );
		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineVrayPool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineVraySecondaryPool` + "\n" );
		fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_VrayJobPriority` + "\n" );
		fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_VraySlaveTimeout` + "\n" );
		fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_VrayMinSlaveTimeout` + "\n" );
		fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_VrayAutoTaskTimeout` + "\n" );
		fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_VrayConcurrentTasks` + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_VrayOnComplete` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_VrayGroup` + "\n" );
		fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_VrayLimitCount` + "\n" );
		fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_VrayLimitGroups` + "\n" );
		//fprint $fileId ( "OutputDirectory0=" + $outputFilePath + "\n" );
		fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );
		fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
		fprint $fileId ( "Frames=" + $frameList + "\n" );
		fprint $fileId ( "ChunkSize=1\n" );

		if( `checkBox -q -value frw_VrayIsBlacklist` )
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );
		else
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );

		WriteIntegrationSettings( $fileId, 1 );

		fclose $fileId;

		string $jobFilename = CheckSlashes( $tempDir + "/vray_deadline_job.job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

		fprint $fileId ( "InputFilename=" + $inputPath + "\n" );
		fprint $fileId ( "SeparateFilesPerFrame=" + $perframe + "\n" );
		fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_vrayThreads` + "\n" );
		fprint $fileId ( "Width=0\n" );
		fprint $fileId ( "Height=0\n" );
		//fprint $fileId ( "OutputFilename=" + $outputFilePath + "\n" );
		fclose $fileId;

		string $argList[] ;
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;

		// Submit the job to Deadline
		string $submissionCommandFile = CreateArgumentsFile( $argList );
		string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

		$submitCounter++;

		// Show results
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );

		int $submitDependentJob = `checkBox -q -v frw_submitVRayJob`;
		if( `checkBox -q -v frw_submitVrimg2ExrJob` && $submitDependentJob  )
		{
			if( fileExtension( $outputFilename ) == "vrimg" )
			{
				string $convertJobId = "";
				string $jobIdRegEx = "[a-z,A-Z,0-9]+_[0-9]+_[a-z,A-Z,0-9]+_[0-9,a-f,A-F]+";
				$matches = `match $jobIdRegEx $submitResults`;
				if( size( $matches ) > 0 )
					$convertJobId = $matches;

				string $vrimgPrefix = CheckSlashes( GetOutputPrefix( 1, 0, "", "", "" ) );
				string $inputVrimgFilename = CheckSlashes( $outputFilePath  + "/" + $vrimgPrefix );

				string $outputExrDirectory = dirname( $inputVrimgFilename );
				string $outputExrPrefix = basename( CheckSlashes( GetOutputPrefix( 0, 0, "", "", "" ) ), ".vrimg" );
				string $outputExrFilename = CheckSlashes( $outputExrDirectory  + "/" + $outputExrPrefix + ".exr" );

				$jobName = $jobName + " - Conversion Job";

				string $convertSubmitFilename = CheckSlashes( $tempDir + "/vrimg_deadline_info.job" );
				$fileId = `fopen $convertSubmitFilename "w"`;
				if( $fileId == 0 )
					print( "Error in Deadline Submission Script: could not create " + $convertSubmitFilename + "\n" );

				fprint $fileId ( "Plugin=Vrimg2Exr\n" );
				fprint $fileId ( "Name=" + $jobName + "\n" );
				fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
				fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
				fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
				fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineVrayPool` + "\n" );
				fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineVraySecondaryPool` + "\n" );
				fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_VrayGroup` + "\n" );
				fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_VrayJobPriority` + "\n" );
				fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_VrayLimitGroups` + "\n" );
				fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_VrayOnComplete` + "\n" );
				fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_VrayLimitCount` + "\n" );
				fprint $fileId ( "Frames=" + $frameList + "\n" );
				fprint $fileId ( "ChunkSize=1\n" );
				fprint $fileId ( "OutputFilename0=" + $outputExrFilename + "\n" );
				fprint $fileId ( "JobDependencies=" + $convertJobId + "\n" );

				if( `checkBox -q -value frw_VrayIsBlacklist` )
					fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );
				else
					fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );

				WriteIntegrationSettings( $fileId, 1 );

				fclose $fileId;

				string $convertPluginFilename = CheckSlashes( $tempDir + "/vrimg_plugin_info.job" );
				$fileId = `fopen $convertPluginFilename "w"`;
				if( $fileId == 0 )
					print( "Error in Deadline Submission Script: could not create " + $convertPluginFilename + "\n" );

				fprint $fileId ( "InputFile=" + $inputVrimgFilename + "\n" );
				fprint $fileId ( "OutputFile=\n" );
				fprint $fileId ( "Half=False\n" );
				fprint $fileId ( "sRGB=False\n" );
				fprint $fileId ( "DataWindow=True\n" );
				fprint $fileId ( "SeparateFiles=False\n" );
				fprint $fileId ( "MultiPart=False\n" );
				fprint $fileId ( "SetGamma=False\n" );
				fprint $fileId ( "Gamma=1.8\n" );
				fprint $fileId ( "SetChannel=False\n" );
				fprint $fileId ( "Channel=\n" );
				fprint $fileId ( "LongChanNames=False\n" );
				fprint $fileId ( "SetCompression=False\n" );
				fprint $fileId ( "Compression=zip\n" );
				fprint $fileId ( "SetBufferSize=False\n" );
				fprint $fileId ( "BufferSize=10\n" );
				fprint $fileId ( "Threads=0\n" );

				if( `checkBox -q -v frw_deleteVrimgFiles` )
					fprint $fileId ( "DeleteInputFiles=True\n" );
				else
					fprint $fileId ( "DeleteInputFiles=False\n" );

				fclose $fileId;

				// Submit the job to Deadline
				string $convertSubmissionCommand = "\"" + $convertSubmitFilename + "\" \"" + $convertPluginFilename + "\"";
				string $convertSubmitResults = CallDeadlineCommand( $convertSubmissionCommand, true );

				// Show results
				print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $convertSubmitResults + "\n" );

				$submitCounter++;
			}
			else
				print( "\n\nWARNING: Vrimg2Exr job not submitted because output format is not vrimg\n" );
		}
	}

	if( $submitLayers )
	{
		// Reselect the current render layer
		editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
	}

	return $submitCounter;
}

proc int SetupVRayExportJob( string $renderer )
{
	global int $VRayExportJobType;

	int $submitCounter = 0;

	//string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, 0, 1, 0, "" );
	string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $VRayExportJobType, "" );

	$submitCounter++;

	int $submitDependentJob = `checkBox -q -v frw_submitVRayJob`;
	if( $submitDependentJob )
	{
		// Dependent job does not support the Separate Files option.
		if( !`getAttr( "vraySettings.misc_separateFiles" )` )
		{
			$submitCounter = $submitCounter + SubmitDependentVRayJob( "", $jobId );
		}

		//~ SubmitDependentVRayJob( "", $jobId );
		//~ $submitCounter++;

		//~ if( `getAttr( "vraySettings.misc_separateFiles" )` )
		//~ {
			//~ int $exportLights = `getAttr( "vraySettings.misc_exportLights" )`;
			//~ if( $exportLights )
			//~ {
				//~ SubmitDependentVRayJob( "lights", $jobId );
				//~ $submitCounter++;
			//~ }

			//~ int $exportNodes = `getAttr( "vraySettings.misc_exportNodes" )`;
			//~ if( $exportNodes )
			//~ {
				//~ SubmitDependentVRayJob( "nodes", $jobId );
				//~ $submitCounter++;
			//~ }

			//~ int $exportGeometry = `getAttr( "vraySettings.misc_exportGeometry" )`;
			//~ if( $exportGeometry )
			//~ {
				//~ $submitCounter++;
				//~ SubmitDependentVRayJob( "geometry", $jobId );
			//~ }

			//~ int $exportMaterials = `getAttr( "vraySettings.misc_exportMaterials" )`;
			//~ if( $exportMaterials )
			//~ {
				//~ SubmitDependentVRayJob( "materials", $jobId );
				//~ $submitCounter++;
			//~ }

			//~ int $exportTextures = `getAttr( "vraySettings.misc_exportTextures" )`;
			//~ if( $exportTextures )
			//~ {
				//~ SubmitDependentVRayJob( "textures", $jobId );
				//~ $submitCounter++;
			//~ }

			//~ int $exportBitmaps = `getAttr( "vraySettings.misc_exportBitmaps" )`;
			//~ if( $exportBitmaps )
			//~ {
				//~ SubmitDependentVRayJob( "bitmaps", $jobId );
				//~ $submitCounter++;
			//~ }
		//~ }
	}

	return $submitCounter;
}

proc int SetupArnoldKickRegionJob(string $jobId, string $camera, string $renderLayer)
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;

	global int $TileRegionRenderType;
	global int $JigsawRegionRenderType;

	print("Start Arnold Kick Region Job");
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;

	int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
	$overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings`;
	if( $submitEachRenderLayer )
	{
		if($overrideLayerSettings)
		{
			$field = "frw_FrameList_" + $renderLayer;
			$frameList = `textFieldGrp -q -text $field`;
		}
		else
		{
			int $range[] = GetFrameRange();
			int $fromFrame = $range[0];
			int $toFrame = $range[1];
			int $byFrame = $range[2];

			$frameList = $fromFrame + "-" + $toFrame;
			if( $byFrame > 1 )
				$frameList = $frameList + "x" + $byFrame;
		}
	}

	int $frameRange[] = GetFramesArray($frameList);

	int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;

	int $submissionCount = 0;

	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	string $projectPath = `textFieldGrp -q -text frw_projectPath`;
	string $assExportFolder = `workspace -fre "ASS"`;
	if( $assExportFolder == "" )
		$assExportFolder = "data";

	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $assFileName = GetStrippedSceneFileName();

	int $exportLocal = `checkBox -q -v frw_exportArnoldLocal`;

	int $renderHeight = `getAttr "defaultResolution.height"`;
	int $renderWidth = `getAttr "defaultResolution.width"`;

	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`;

	int $regions[];
	int $assemblyRegions[];
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	if($regionType == $TileRegionRenderType)
	{
		for( $y = 1; $y <= $tilesInY; $y++ )
		{
			for( $x = 1; $x <= $tilesInX; $x++ )
			{
				$regions[size($regions)]= ($x-1)*($renderWidth/$tilesInX);
				$assemblyRegions[ size($assemblyRegions) ] = ($x-1)*($renderWidth/$tilesInX);
				$regions[size($regions)]= ($x)*($renderWidth/$tilesInX);
				$assemblyRegions[ size($assemblyRegions) ] = ($x)*($renderWidth/$tilesInX);
				$regions[size($regions)]= ($y-1)*($renderHeight/$tilesInY);
				$assemblyRegions[ size($assemblyRegions) ] = ($tilesInY - $y)*($renderHeight/$tilesInY);
				$regions[size($regions)]= ($y)*($renderHeight/$tilesInY);
				$assemblyRegions[ size($assemblyRegions) ] = ($tilesInY - $y + 1)*($renderHeight/$tilesInY);
			}
		}
	}
	else
	{
		if(catchQuiet(`python("jigsawThread.isAlive()")`))
		{
			confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
			return 0;
		}
		if(`python("jigsawThread.isAlive()")`)
		{
			python("jigsawThread.requestSave()");
			$regions = `python("jigsawThread.getRegions(False)")`;
			$assemblyRegions = `python("jigsawThread.getRegions(True)")`;
		}
		else
		{
			confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
			return 0;
		}
	}

	int $numRegions = size($regions)/4;

	int $ignoreOutFormatControl = false;
	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
		string $padding = "";
		while( size($padding) < $paddingSize )
			$padding = "0" + $padding;

		int $periodInExt = `getAttr "defaultRenderGlobals.periodInExt"`;
		int $putFrameBeforeExt = `getAttr "defaultRenderGlobals.putFrameBeforeExt"`;

		if( $periodInExt == 0 ) // name#.ext
		{
			$assFileName += $padding;
		}
		else if( $periodInExt == 1 )
		{
			if( $putFrameBeforeExt ) // name.# or name.#.ext
			{
				$assFileName += "." + $padding;
			}
			else // name.ext.#
			{
				$assFileName += ".ass." + $padding;
				$ignoreOutFormatControl = true;
			}
		}
		else if( $periodInExt == 2 ) // name_#.ext
		{
			$assFileName += "_" + $padding;
		}
	}
	if( !$ignoreOutFormatControl && `getAttr "defaultRenderGlobals.outFormatControl"` == 0 )
		$assFileName += ".ass";

	string $inputPath = $projectPath + "/" + $assExportFolder + "/";

	if ( IsRenderLayersOn() )
	{
		string $layerName = GetRenderLayerDisplayName($renderLayer);
		$inputPath = $inputPath + $layerName + "/";
	}

	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	if ( $multipleRenderableCams )
		$inputPath = $inputPath + $camera + "/";

	$inputPath = $inputPath + CheckSlashes( $assFileName );

	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	int $singleRegionFrame = `intSliderGrp -q -v frw_tileSingleFrame`;

	string $singleJobName = $jobName;
	// Append camera name to the job
	if( $camera != "" )
		$singleJobName += " - " + $camera;

	// Append render layer name to the job
	if( $renderLayer != "" )
		$singleJobName += " - " + $renderLayer;

	string $elements[] = getArnoldElements();
	string $elementNames[] = getArnoldElementNames();

	string $extension = fileExtension( GetOutputPrefix( 0, 0, "", "", "" ) );

	if($singleRegionJob)
	{
		string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info.job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

		fprint $fileId ( "Plugin=Arnold\n" );
		fprint $fileId ( "Name=" + $singleJobName + " - Export\n" );

		if( !$exportLocal || $submitDependentJob )
			fprint $fileId ( "BatchName=" + $batchName + "\n" );

		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineArnoldPool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineArnoldSecondaryPool` + "\n" );
		fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_ArnoldJobPriority` + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_ArnoldOnComplete` + "\n" );
		fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_ArnoldSlaveTimeout` + "\n" );
		fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_ArnoldMinSlaveTimeout` + "\n" );
		fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_ArnoldAutoTaskTimeout` + "\n" );
		fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ArnoldConcurrentTasks` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_ArnoldGroup` + "\n" );
		fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_ArnoldLimitCount` + "\n" );
		fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_ArnoldLimitGroups` + "\n" );
		int $fileCount = 0;
		for( $element in $elementNames )
		{
			string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $singleRegionFrame, $renderLayer, $camera, $element ) );
			$outputPrefix = swapDeepExr( $outputPrefix );
			fprint $fileId ( "OutputFilename" + $fileCount + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix ) + "\n" );
			$fileCount++;
		}
		fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
		fprint $fileId ( "Frames=0-" + ($numRegions-1) + "\n" );
		fprint $fileId ( "ChunkSize=1\n" );

		if( `checkBox -q -value frw_ArnoldIsBlacklist` )
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
		else
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );

		WriteIntegrationSettings( $fileId, 1 );

		fclose $fileId;

		string $jobFilename = CheckSlashes( $tempDir + "/arnold_deadline_job.job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

		fprint $fileId ( "InputFile=" + $inputPath + "\n" );
		fprint $fileId ( "DisableFrameInterpretation=" + !IsAnimatedOn() + "\n" );
		fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_arnoldThreads` + "\n" );
		fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
		fprint $fileId ( "Verbose=4\n" );
		fprint $fileId ( "RegionJob=True\n" );
		fprint $fileId ( "SingleAss=True\n" );
		fprint $fileId ( "SingleRegionFrame="+$singleRegionFrame+"\n" );
		fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
		if( size($elements) > 0)
		{
			fprint $fileId ( "HasAOVs=True\n" );
			int $aovCount = 0;
			for( $curAOV in $elements )
			{

				string $aovName = `getAttr ($curAOV+".name")`;
				string $aovDriver[] = `listConnections ($curAOV+".outputs[0].driver")`;
				string $aovExtension = `getAttr ($aovDriver[0]+".aiTranslator")`;
				fprint $fileId ( "ASSAOV"+ $aovCount +"Name="+$aovDriver[0]+"@driver_"+$aovExtension+".RGBA."+$aovName+".filename\n" );
				$aovCount++;
			}
		}

		for($curRegion =0;$curRegion<$numRegions;$curRegion++)
		{
			int $top = ($regions[$curRegion*4+2]);
			int $right = ($regions[$curRegion*4+1]-1);
			int $left = ($regions[$curRegion*4]);
			int $bottom = ($regions[$curRegion*4+3]-1);

			if( $right == $renderWidth )
				$right -=1;
			if( $bottom == $renderHeight )
				$bottom -=1;

			fprint $fileId ( "RegionLeft"+$curRegion+"="+$left+"\n" );
			fprint $fileId ( "RegionTop"+$curRegion+"="+$top+"\n" );
			fprint $fileId ( "RegionRight"+$curRegion+"="+$right+"\n" );
			fprint $fileId ( "RegionBottom"+$curRegion+"="+$bottom+"\n" );

			int $elementCount = 0;
			for( $element in $elementNames )
			{
				string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $singleRegionFrame, $renderLayer, $camera, $element ) );
				$outputPrefix = swapDeepExr( $outputPrefix );
				$outputPrefix = GetJigsawOutputPrefix( $outputPrefix, $curRegion, "arnold" );
				if( $elementCount == 0)
				{
					fprint $fileId ( "RegionFilename"+$curRegion+"="+ CheckSlashes( $outputFilePath + "/" + $outputPrefix ) +"\n" );
				}
				else
				{
					fprint $fileId ( "AOV" + ( $elementCount - 1 ) + "Filename" + $curRegion + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix )+"\n" );
				}
				$elementCount++;
			}
		}

		fclose $fileId;

		string $argList[] ;
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;

		// Submit the job to Deadline
		string $submissionCommandFile = CreateArgumentsFile( $argList );
		string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

		// Show results
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
		// Get the job id to return
		string $jobId = "";
		string $resultArray[];
		$resultArray = stringToStringArray( $submitResults, "\n" );
		for( $n = 0; $n < size($resultArray); $n++ )
		{
			if( startsWith( $resultArray[$n], "JobID=" ) )
			{
				$jobId = substituteAllString( $resultArray[$n], "JobID=", "" );
				break;
			}
		}
		$submissionCount++;


		if($submitDependentJob)
		{
			string $dependentIds[] = {$jobId};
			$submissionCount += SetupDependentJigsawAssemblerJob("arnold", $dependentIds, $singleRegionFrame, $regions, $renderLayer, $camera);
		}
	}
	else
	{
		string $jobIdList[];

		AddStringAttribute( "deadlineRegionLeft" );
		AddStringAttribute( "deadlineRegionTop" );
		AddStringAttribute( "deadlineRegionRight" );
		AddStringAttribute( "deadlineRegionBottom" );
		string $regionLeftValues[];
		string $regionRightValues[];
		string $regionTopValues[];
		string $regionBottomValues[];

		for($curRegion =0;$curRegion<$numRegions;$curRegion++)
		{
			string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info.job" );
			$fileId = `fopen $submitFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

			fprint $fileId ( "Plugin=Arnold\n" );
			fprint $fileId ( "Name=" + $singleJobName + " - Render - Region "+$curRegion+"\n" );

			if( !$exportLocal || $submitDependentJob )
				fprint $fileId ( "BatchName=" + $batchName + "\n" );

			fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
			fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineArnoldPool` + "\n" );
			fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineArnoldSecondaryPool` + "\n" );
			fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_ArnoldJobPriority` + "\n" );
			fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_ArnoldOnComplete` + "\n" );
			fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_ArnoldSlaveTimeout` + "\n" );
			fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_ArnoldMinSlaveTimeout` + "\n" );
			fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_ArnoldAutoTaskTimeout` + "\n" );
			fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ArnoldConcurrentTasks` + "\n" );
			fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
			fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_ArnoldGroup` + "\n" );
			fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_ArnoldLimitCount` + "\n" );
			fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_ArnoldLimitGroups` + "\n" );
			int $fileCount = 0;
			for( $element in $elementNames )
			{
				string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, $renderLayer, $camera, $element ) );
				$outputPrefix = swapDeepExr( $outputPrefix );
				fprint $fileId ( "OutputFilename" + $fileCount + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix ) + "\n" );
				$fileCount++;
			}
			//fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );

			fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
			fprint $fileId ( "IsFrameDependent=true\n" ); // this can be enabled because arnold export jobs can be done across multiple machines
			fprint $fileId ( "Frames=" + $frameList + "\n" );
			fprint $fileId ( "ChunkSize=1\n" );

			if( `checkBox -q -value frw_ArnoldIsBlacklist` )
				fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
			else
				fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );

			WriteIntegrationSettings( $fileId, 1 );

			fclose $fileId;

			string $jobFilename = CheckSlashes( $tempDir + "/arnold_deadline_job.job" );
			$fileId = `fopen $jobFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

			fprint $fileId ( "InputFile=" + $inputPath + "\n" );
			fprint $fileId ( "DisableFrameInterpretation=" + !IsAnimatedOn() + "\n" );
			fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_arnoldThreads` + "\n" );
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
			fprint $fileId ( "Verbose=4\n" );
			fprint $fileId ( "RegionJob=True\n" );
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );

			if( size($elements) > 0)
			{
				fprint $fileId ( "HasAOVs=True\n" );
				int $aovCount = 0;
				for( $curAOV in $elements )
				{

					string $aovName = `getAttr ($curAOV+".name")`;
					string $aovDriver[] = `listConnections ($curAOV+".outputs[0].driver")`;
					string $aovExtension = `getAttr ($aovDriver[0]+".aiTranslator")`;
					fprint $fileId ( "ASSAOV"+ $aovCount +"Name="+$aovDriver[0]+"@driver_"+$aovExtension+".RGBA."+$aovName+".filename\n" );
					$aovCount++;
				}
			}

			int $top = ($regions[$curRegion*4+2]);
			int $right = ($regions[$curRegion*4+1]-1);
			int $left = ($regions[$curRegion*4]);
			int $bottom = ($regions[$curRegion*4+3]-1);

			fprint $fileId ( "RegionLeft="+$left+"\n" );
			fprint $fileId ( "RegionTop="+$top+"\n" );
			fprint $fileId ( "RegionRight="+$right+"\n" );
			fprint $fileId ( "RegionBottom="+$bottom+"\n" );

			int $assemblyTop = ($assemblyRegions[$curRegion*4+2]);
			int $assemblyRight = ($assemblyRegions[$curRegion*4+1]);
			int $assemblyLeft = ($assemblyRegions[$curRegion*4]);
			int $assemblyBottom = ($assemblyRegions[$curRegion*4+3]);
			stringArrayInsertAtIndex($curRegion, $regionLeftValues, ""+$assemblyLeft);
			stringArrayInsertAtIndex($curRegion, $regionTopValues, ""+ $assemblyTop);
			stringArrayInsertAtIndex($curRegion, $regionRightValues, ""+ $assemblyRight);
			stringArrayInsertAtIndex($curRegion, $regionBottomValues, ""+ $assemblyBottom);

			int $frameCount = 0;
			for ($frame in $frameRange)
			{
				int $elementCount = 0;
				for( $element in $elementNames )
				{
					string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $frame, $renderLayer, $camera, $element ) );
					$outputPrefix = swapDeepExr( $outputPrefix );
					$outputPrefix = GetJigsawOutputPrefix( $outputPrefix, $curRegion, "arnold" );
					if( $elementCount == 0)
					{
						fprint $fileId ( "RegionFilename"+$frame+"="+ CheckSlashes( $outputFilePath + "/" + $outputPrefix ) +"\n" );
					}
					else
					{
						fprint $fileId ( "AOV" + ( $elementCount - 1 ) + "Filename"+$frame+"=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix )+"\n" );
					}
					$elementCount++;
				}
			}

			fclose $fileId;

			string $argList[] ;
			$argList[0] = $submitFilename;
			$argList[1] = $jobFilename;

			// Submit the job to Deadline
			string $submissionCommandFile = CreateArgumentsFile( $argList );
			string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

			// Show results
			print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
			$submissionCount += 1;
			// Get the job id to return
			string $jobId = "";
			string $resultArray[];
			$resultArray = stringToStringArray( $submitResults, "\n" );
			for( $n = 0; $n < size($resultArray); $n++ )
			{
				if( startsWith( $resultArray[$n], "JobID=" ) )
				{
					$jobId = substituteAllString( $resultArray[$n], "JobID=", "" );
					break;
				}
			}

			stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId) ;
		}

		int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
		if($submitDependentJob)
		{
			string $regionString = stringArrayToString($regionLeftValues,";");
			setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" $regionString;
			$regionString = stringArrayToString($regionTopValues,";");
			setAttr defaultRenderGlobals.deadlineRegionTop -type "string" $regionString;
			$regionString = stringArrayToString($regionRightValues,";");
			setAttr defaultRenderGlobals.deadlineRegionRight -type "string" $regionString;
			$regionString = stringArrayToString($regionBottomValues,";");
			setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" $regionString;
			$submissionCount += SetupDependentTileAnimationAssemblerJob("arnold", $jobIdList, $renderLayer, $camera);
		}

	}
	return $submissionCount;

}

proc string SetupDependentMaxwellJob( string $jobId, string $camera, int $batch, int $coopSeed )
{
	global string $MaxwellOutputScriptListGrp;

	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	string $inputPath = `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp`;
	string $sdkVersion = `maxwell -getSDKVersion`;
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";

	int $separateJobs;
	int $coopRendering = `checkBox -q -v frw_maxwellCooperativeRendering`;
	int $autoMerge = `checkBox -q -v frw_maxwellAutoMergeFiles`;
	int $exportLocal = `checkBox -q -v frw_exportMaxwellLocal`;
	int $animation = `getAttr "defaultRenderGlobals.animation"`;
	int $singleFile = 1;
	int $coopJobs = 1;

	if($animation)
	{
		$singleFile = 0;
	}

	if( $coopRendering )
	{
		$coopJobs = `intField -q -v frw_maxwellNumCoopRenders`;
		$separateJobs = `checkBox -q -v frw_maxwellCoopSeparateJobs`;

		if( $animation )
		{
			$separateJobs = true;
		}
	}

	string $submitFilename = CheckSlashes( $tempDir + "/maxwell_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
	{
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
	}

	fprint $fileId ( "Plugin=Maxwell\n" );

	$jobName = $jobName + " - Render";

	if($camera != "")
	{
		$jobName = $jobName + " - "+$camera;
	}

	if( $coopRendering )
	{
		if( $separateJobs )
		{
			$jobName = $jobName + " - Cooperative Job " + $coopSeed + " of " + $coopJobs;
		}
		else
		{
			$jobName = $jobName + " - Single Cooperative Job";
		}
	}

	fprint $fileId ( "Name=" + $jobName + "\n" );

	if( !$exportLocal || $batch || $separateJobs || $autoMerge )
	{
		fprint $fileId ( "BatchName=" + $batchName + "\n" );
	}

	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineMaxwellPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineMaxwellSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_MaxwellJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_MaxwellOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_MaxwellSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_MaxwellMinSlaveTimeout` + "\n" );
	fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_MaxwellAutoTaskTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_MaxwellConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_MaxwellGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_MaxwellLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_MaxwellLimitGroups` + "\n" );
	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=true\n" ); // this can be enabled because Maxwell export jobs can be done across multiple machines

	if( $separateJobs )
	{
		int $framesPerTask = `intSliderGrp -q -v frw_FrameGroup`;

		fprint $fileId ( "Frames=" + $frameList + "\n" );
		fprint $fileId ( "ChunkSize=" +  $framesPerTask + "\n" );
	}
	else
	{
		fprint $fileId ( "Frames=1-" + $coopJobs + "\n" );
		fprint $fileId ( "ChunkSize=1\n" );
	}

	if( `checkBox -q -value frw_MaxwellIsBlacklist` )
	{
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_MaxwellMachineList` + "\n" );
	}
	else
	{
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_MaxwellMachineList` + "\n" );
	}

	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", $camera, "" ) );
	string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );

	fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );

	string $renderFileName = substituteAllString( $outputFilename, "####.", "" );
	string $mxiFileName = substituteAllString( $renderFileName, `fileExtension($renderFileName)`, "mxi" );

	//If user specifies MXI path in Maxwell render options, use that instead of default path above
	if( `getAttr maxwellRenderOptions.specifyMXI` == 1 )
	{
		string $mxiPath = `getAttr maxwellRenderOptions.mxiPath`;

		if( $mxiPath != "" )
		{
			$mxiFileName = $mxiPath;
		}
	}

	if( !( $coopRendering && $autoMerge ) )
	{
		WriteIntegrationSettings( $fileId, 1 );
	}

	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/maxwell_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
	{
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	}

	fprint $fileId ( "Version="+`substring $sdkVersion 1 1`+"\n" );
	fprint $fileId ( "SingleFile=" + $singleFile + "\n" );
	fprint $fileId ( "SeparateFiles=" + $animation + "\n" );
	fprint $fileId ( "MaxwellFile=" + $inputPath + "\n" );
	fprint $fileId ( "OutputFile=" + $renderFileName + "\n" );
	fprint $fileId ( "MxiFile=" + $mxiFileName + "\n" );
	fprint $fileId ( "LocalRendering=False\n" );

	if( `checkBox -q -v frw_maxwellMXIResume` )
	{
		fprint $fileId ( "ResumeFromMxiFile=True\n" );
	}
	else
	{
		fprint $fileId ( "ResumeFromMxiFile=False\n" );
	}

	fprint $fileId ( "Build=None\n" );
	fprint $fileId ( "RenderThreads=" + `intSliderGrp -q -v frw_maxwellThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_maxwellArgs` + "\n" );
	fprint $fileId ( "Build=None\n" );
	fprint $fileId ( "OverrideTime=False\n" );
	fprint $fileId ( "OverrideTimeValue=10.0\n" );
	fprint $fileId ( "OverrideSampling=False\n" );
	fprint $fileId ( "OverrideSamplingValue=10.0\n" );
	fprint $fileId ( "OverrideExtraSampling=False\n" );
	fprint $fileId ( "ExtraSamplingEnabled=False\n" );
	fprint $fileId ( "ExtraSamplingLevel=10.0\n" );
	fprint $fileId ( "ExtraSamplingMask=Alpha\n" );
	fprint $fileId ( "ExtraSamplingCustomAlphaName=\n" );
	fprint $fileId ( "ExtraSamplingBitmapFile=\n" );
	fprint $fileId ( "ExtraSamplingInvertMask=False\n" );
	fprint $fileId ( "Verbosity=All\n" );
	fprint $fileId ( "MergeJob=False\n" );
	fprint $fileId ( "Camera=" + $camera + "\n" );
	fprint $fileId ( "AppendFrame=" + $animation +"\n" );

	int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
	fprint $fileId ( "AnimationPadding=" + $paddingSize +"\n" );

	if( $coopRendering )
	{
		fprint $fileId ( "CoopRendering=True\n" );
		fprint $fileId ( "CoopJobs=" + $coopJobs + "\n" );

		if( $separateJobs )
		{
			fprint $fileId ( "CoopSeed=" + $coopSeed + "\n" );
		}
		else
		{
			fprint $fileId ( "SingleCoopJob=True\n" );
		}
	}

	fclose $fileId;

	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;

	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results if not doing a co-op render, or if not auto-merging results from separate co-op render jobs
	if( !$coopRendering || ( !$autoMerge && !$separateJobs ) )
	{
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	}

	//Get job ID from submitted results
	string $dependantJobId = "";
	string $resultArray[];
	$resultArray = stringToStringArray( $submitResults, "\n" );
	for( $n = 0; $n < size($resultArray); $n++ )
	{
		if( startsWith( $resultArray[$n], "JobID=" ) )
		{
			$dependantJobId = substituteAllString( $resultArray[$n], "JobID=", "" );
			break;
		}
	}

	return $dependantJobId;
}

proc SetupAutoMergeMaxwellJob( string $jobId, string $camera )
{
	global string $MaxwellOutputScriptListGrp;

	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	string $inputPath = `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp`;
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", $camera, "" ) );
	string $outputFilename = CheckSlashes( $outputFilePath + "/" + $outputPrefix );
	string $renderFileName = substituteAllString( $outputFilename, "####.", "" );
	string $mxiFileName = substituteAllString( $renderFileName, `fileExtension($renderFileName)`, "mxi" );
	string $sdkVersion = `maxwell -getSDKVersion`;

	int $singleFile = 1;
	int $coopJobs = `intField -q -v frw_maxwellNumCoopRenders`;
	int $deleteFiles = `checkBox -q -v frw_maxwellDeleteIntermediate`;
	int $failOnMissingFiles = `checkBox -q -v frw_maxwellMissingIntermediate`;

	//If user specifies MXI path in Maxwell render options, use that instead of default path above
	if( `getAttr maxwellRenderOptions.specifyMXI` == 1 )
	{
		string $mxiPath = `getAttr maxwellRenderOptions.mxiPath`;

		if( $mxiPath != "" )
		{
			$mxiFileName = $mxiPath;
		}
	}

	//Trim the last two chars off the string
	$jobId = `substring $jobId 1 ( size( $jobId ) - 1 )`;

	if( IsAnimatedOn() )
	{
		$singleFile = 0;
	}

	string $submitFilename = CheckSlashes( $tempDir + "/maxwell_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
	{
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
	}

	fprint $fileId ( "Plugin=Maxwell\n" );
	fprint $fileId ( "Name=" + $jobName + " - Merge Job\n" );
	fprint $fileId ( "BatchName=" + $jobName + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineMaxwellPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineMaxwellSecondaryPool` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_MaxwellGroup` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_MaxwellJobPriority` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_MaxwellConcurrentTasks` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_MaxwellLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_MaxwellLimitGroups` + "\n" );
	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_MaxwellOnComplete` + "\n" );
	fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );

	WriteIntegrationSettings( $fileId, 1 );

	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/maxwell_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
	{
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	}

	fprint $fileId ( "Version="+`substring $sdkVersion 1 1`+"\n" );
	fprint $fileId ( "SingleFile=" + $singleFile + "\n" );
	fprint $fileId ( "MaxwellFile=" + $inputPath + "\n" );
	fprint $fileId ( "OutputFile=" + $renderFileName + "\n" );
	fprint $fileId ( "MxiFile=" + $mxiFileName + "\n" );

	if( `checkBox -q -v frw_maxwellMXIResume` )
	{
		fprint $fileId ( "ResumeFromMxiFile=True\n" );
	}
	else
	{
		fprint $fileId ( "ResumeFromMxiFile=False\n" );
	}

	fprint $fileId ( "Build=None\n" );
	fprint $fileId ( "CoopRendering=True\n" );
	fprint $fileId ( "CoopJobs=" + $coopJobs + "\n" );
	fprint $fileId ( "DeleteFiles=" + $deleteFiles + "\n" );
	fprint $fileId ( "FailOnMissingFiles=" + $failOnMissingFiles + "\n" );
	fprint $fileId ( "MergeJob=True\n" );

	fclose $fileId;

	string $submissionCommand = "\"" + $submitFilename + "\" \"" + $jobFilename + "\"";
	string $submitResults = CallDeadlineCommand( $submissionCommand, true );
}

proc int CreateDependentMaxwellJob( string $jobId, string $camera, int $batch )
{
	int $submitCounter = 0;
	int $coopRendering = `checkBox -q -v frw_maxwellCooperativeRendering`;
	int $autoMerge = `checkBox -q -v frw_maxwellAutoMergeFiles`;
	int $separateJobs = `checkBox -q -v frw_maxwellCoopSeparateJobs`;
	int $coopJobs = 1;

	if( $coopRendering )
	{
		$coopJobs = `intField -q -v frw_maxwellNumCoopRenders`;
	}

	string $jobDependencies = "";

	for( $coopSeed = 1; $coopSeed <= $coopJobs; $coopSeed++ )
	{
		$dependentJobId = SetupDependentMaxwellJob( $jobId, $camera, $batch, $coopSeed );
		$jobDependencies = $jobDependencies + $dependentJobId + ",";
		$submitCounter++;

		//Only loop once if co-op jobs are combined into one
		if( !$separateJobs && $coopRendering )
		{
			break;
		}
	}

	if( $coopRendering && $autoMerge )
	{
		SetupAutoMergeMaxwellJob( $jobDependencies, $camera );
		$submitCounter++;
	}

	return $submitCounter;
}

proc SetupArnoldKickJob(string $jobId, string $camera, string $renderLayer)
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $projectPath = `textFieldGrp -q -text frw_projectPath`;
	string $assExportFolder = `workspace -fre "ASS"`;
	if( $assExportFolder == "" )
		$assExportFolder = "data";
	string $assFileName = GetStrippedSceneFileName();

	int $exportLocal = `checkBox -q -v frw_exportArnoldLocal`;

	// Append camera name to the job
	if( $camera != "" )
		$jobName = $jobName + " - " + $camera;

	// Append render layer name to the job
	if( $renderLayer != "" )
		$jobName += " - " + $renderLayer;

	int $ignoreOutFormatControl = false;
	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
		string $padding = "";
		while( size($padding) < $paddingSize )
			$padding = "0" + $padding;

		int $periodInExt = `getAttr "defaultRenderGlobals.periodInExt"`;
		int $putFrameBeforeExt = `getAttr "defaultRenderGlobals.putFrameBeforeExt"`;

		if( $periodInExt == 0 ) // name#.ext
		{
			$assFileName += $padding;
		}
		else if( $periodInExt == 1 )
		{
			if( $putFrameBeforeExt ) // name.# or name.#.ext
			{
				$assFileName += "." + $padding;
			}
			else // name.ext.#
			{
				$assFileName += ".ass." + $padding;
				$ignoreOutFormatControl = true;
			}
		}
		else if( $periodInExt == 2 ) // name_#.ext
		{
			$assFileName += "_" + $padding;
		}
	}

	if( !$ignoreOutFormatControl && `getAttr "defaultRenderGlobals.outFormatControl"` == 0 )
		$assFileName += ".ass";

	string $inputPath = $projectPath + "/" + $assExportFolder + "/";

	if ( IsRenderLayersOn() ) // swap default to master
	{
		$renderLayer = GetRenderLayerDisplayName( $renderLayer );

		$inputPath = $inputPath + $renderLayer + "/";
	}

	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	if ( $multipleRenderableCams )
		$inputPath = $inputPath + $camera + "/";

	$inputPath = $inputPath + CheckSlashes( $assFileName );

	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";

	string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=Arnold\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );

	if( !$exportLocal )
		fprint $fileId ( "BatchName=" + $batchName + "\n" );

	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineArnoldPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineArnoldSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_ArnoldJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_ArnoldOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_ArnoldSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_ArnoldMinSlaveTimeout` + "\n" );
	fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_ArnoldAutoTaskTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ArnoldConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_ArnoldGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_ArnoldLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_ArnoldLimitGroups` + "\n" );

	string $elements[] = getArnoldElementNames();
	int $counter = 0;
	for($element in $elements)
	{
		string $outputPrefix = "";
		$outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, $renderLayer, $camera, $element ) );
		$outputPrefix = swapDeepExr( $outputPrefix );
		fprint $fileId ( "OutputFilename" + $counter + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix ) + "\n" );
		$counter += 1;
	}

	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=true\n" ); // this can be enabled because arnold export jobs can be done across multiple machines
	fprint $fileId ( "Frames=" + $frameList + "\n" );
	fprint $fileId ( "ChunkSize=1\n" );

	if( `checkBox -q -value frw_ArnoldIsBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );

	WriteIntegrationSettings( $fileId, 1 );

	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/arnold_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

	fprint $fileId ( "InputFile=" + $inputPath + "\n" );
	fprint $fileId ( "DisableFrameInterpretation=" + !IsAnimatedOn() + "\n" );
	fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_arnoldThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
	fprint $fileId ( "Verbose=4\n" );
	fclose $fileId;

	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;

	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
}

proc int SetupMaxwellExportJob( string $renderer )
{
	global int $MaxwellExportJobType;
	global string $MaxwellOutputScriptListGrp;

	int $submitCounter = 0;
	int $submitDependentJob = `checkBox -q -v frw_submitMaxwellJob`;
	int $exportLocal = `checkBox -q -v frw_exportMaxwellLocal`;
	int $coopRendering = `checkBox -q -v frw_maxwellCooperativeRendering`;
	int $renderableCameras = 0;

	string $camera = "";
	string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
	string $cameraNames[] = `listTransforms -cameras`;
	string $outputScript = `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp`;
	string $jobId = "";

	for( $cameraName in $cameraNames )
	{
		if( $selectedCamera != "" && $cameraName == $selectedCamera )
		{
			$camera = $selectedCamera;
			break;
		}

		if( IsCameraRenderable( $cameraName ) )
		{
			$renderableCameras = $renderableCameras + 1;
		}
	}

	if(!$exportLocal || !$submitDependentJob)
	{
		$jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $MaxwellExportJobType, "" );
		$submitCounter++;
	}
	else
	{
		int $start = 0;
		int $end = 0;
		int $exportOnly = 0;
		string $mxsPath = "";
		int $persistentMxs = 0;
		string $cmdLine = "";

		if( `objExists maxwellRenderOptions` == 0 )
		{
			print( "Error in Deadline Submission Script: Maxwell is not available.\n" );
			return 0;
		}

		$exportOnly = `getAttr maxwellRenderOptions.exportOnly`;
		$cmdLine = `getAttr maxwellRenderOptions.cmdLine`;
		$persistentMxs = `getAttr maxwellRenderOptions.persistentMXS`;
		$mxsPath = `getAttr maxwellRenderOptions.mxsPath`;

		removeRenderLayerAdjustmentAndUnlock maxwellRenderOptions.exportOnly;
		catch(`setAttr maxwellRenderOptions.exportOnly 1`);

		setAttr -type "string" maxwellRenderOptions.cmdLine "-node";
		maxwellUnlockAndSet maxwellRenderOptions.persistentMXS 1;
		setAttr -type "string" maxwellRenderOptions.mxsPath $outputScript;

		removeRenderLayerAdjustmentAndUnlock maxwellRenderOptions.exportOnly;
		catch(`setAttr maxwellRenderOptions.exportOnly 1`);

		string $maxwellVersion = `pluginInfo -q -version "maxwell"`;

		string $maxwellVersionTokens[];
		tokenize($maxwellVersion, ".", $maxwellVersionTokens);
		int $majorVersion = $maxwellVersionTokens[0];
		int $minorVersion = $maxwellVersionTokens[1];
		if( $majorVersion > 2 || ( $majorVersion == 2 && $minorVersion >= 5 ) )
		{
			maxwellBatchRender("");
		}
		else
		{
			maxwell -batchRender;
		}

		setAttr maxwellRenderOptions.exportOnly $exportOnly;
		setAttr -type "string" maxwellRenderOptions.cmdLine $cmdLine;
		setAttr maxwellRenderOptions.persistentMXS $persistentMxs;
		setAttr -type "string" maxwellRenderOptions.mxsPath $mxsPath;
	}

	if( $submitDependentJob || $coopRendering )
	{
		if( $camera == "" && $renderableCameras > 1 )
		{
			string $cameraNames[] = deadlineGetRenderableCameras( false );
			for( $cameraName in $cameraNames )
			{
				//Create a job for each camera
				$submitCounter = $submitCounter + CreateDependentMaxwellJob( $jobId, $cameraName, 1 );
			}
		}
		else
		{
			$submitCounter = $submitCounter + CreateDependentMaxwellJob( $jobId, $camera, 0 );
		}
	}

	return $submitCounter;
}

proc int SetupArnoldExportJob( string $renderer )
{
	global int $ArnoldExportJobType;

	int $submitCounter = 0;
	int $regionRendering = `checkBox -q -value frw_regionRendering`;
	int $submitDependentJob = `checkBox -q -v frw_submitArnoldJob`;
	int $exportLocal = `checkBox -q -v frw_exportArnoldLocal`;
	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	int $singleRegionRendering = `checkBox -q -v frw_submitTileSingleJob`;

	if($submitDependentJob == 0)
	{
		$regionRendering = 0;
	}
	string $jobId = "";
	if(!$exportLocal || !$submitDependentJob)
	{
		$jobId = WriteJobFilesAndSubmit( $renderer, 0, $regionRendering, $ArnoldExportJobType, "" );
		$submitCounter++;
	}
	else
	{
		removeRenderLayerAdjustmentAndUnlock defaultArnoldRenderOptions.renderType;
		catch(`setAttr defaultArnoldRenderOptions.renderType 1`);
		setMayaSoftwareLayers("", "");
		setImageSizePercent(-1.);

		// If a project and output directory are set in the submitter then we need to switch to those projects so the setttings are set properly when doing a local export.
		string $oldProjectPath = `workspace -fullName`;
		string $oldImagePath = `workspace -q -fre images`;
		string $newProjectPath = CheckSlashes( `textFieldGrp -q -text frw_projectPath` );
		string $newImagePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
		if( $newProjectPath != "" )
		{
			setProject $newProjectPath;
		}
		if( $newImagePath != "" )
		{
			workspace -fr images $newImagePath;
		}

		int $start = 0;
		int $end = 0;

		if( $regionRendering && $singleRegionRendering )
		{
			$start = `getAttr defaultRenderGlobals.startFrame`;
			$end = `getAttr defaultRenderGlobals.endFrame`;

			int $singleRegionFrame = `intSliderGrp -q -v frw_tileSingleFrame`;
			setAttr defaultRenderGlobals.startFrame $singleRegionFrame;
			setAttr defaultRenderGlobals.endFrame $singleRegionFrame;
		}

		mayaBatchRenderProcedure(0, "", "", "arnold", "");

		if( $regionRendering && $singleRegionRendering )
		{
			setAttr defaultRenderGlobals.startFrame $start;
			setAttr defaultRenderGlobals.endFrame $end;
		}

		if( $newProjectPath != "" )
		{
			setProject $oldProjectPath;
		}
		if( $newImagePath != "" )
		{
			workspace -fr images $oldImagePath;
		}

	}


	if( $submitDependentJob )
	{
		// Figure out the camera to use (if specified).
		string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
		string $cameraNames[] = {};
		string $renderLayers[] = {""};
		if( $selectedCamera != " " )
		{
			stringArrayInsertAtIndex(0, $cameraNames, $selectedCamera );
		}
		else
		{
			$cameraNames  = deadlineGetRenderableCameras( false );
		}
		if( IsRenderLayersOn() )
		{
			$renderLayers = getRenderableRenderLayers();
		}

		for( $renderLayer in $renderLayers )
		{
			//if ( $renderLayer == "defaultRenderLayer" )
			//$renderLayer = "masterLayer";
			for( $cameraName in $cameraNames )
			{
				if( !$regionRendering )
				{
					SetupArnoldKickJob($jobId, $cameraName, $renderLayer );
					$submitCounter++;
				}
				else
				{
					$submitCounter += SetupArnoldKickRegionJob($jobId, $cameraName, $renderLayer );
				}
			}
		}
	}

	return $submitCounter;
}

proc SetupRenderManJob( string $jobId, string $renderLayer )
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	if( $renderLayer != "" )
		$jobName = $jobName + " - " + $renderLayer;

	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;

	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );

	string $projectPath = `textFieldGrp -q -text frw_projectPath`;

	string $inputPath = "";
	if( $renderLayer == "" )
		$inputPath = CheckSlashes( $projectPath + "/renderman/" + GetStrippedSceneFileName() + "/rib/0000/0000.rib\n" );
	else
		$inputPath = CheckSlashes( $projectPath + "/renderman/" + GetStrippedSceneFileName() + "/rib/0000/0000_" + $renderLayer + ".rib\n" );

	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";

	string $submitFilename = CheckSlashes( $tempDir + "/renderman_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=RenderMan\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	fprint $fileId ( "BatchName=" + $batchName + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineRendermanPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineRendermanSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_RendermanJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_RendermanOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_RendermanSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_RendermanMinSlaveTimeout` + "\n" );
	fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_RendermanAutoTaskTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_RendermanConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_RendermanGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_RendermanLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_RendermanLimitGroups` + "\n" );

	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $outputCount = 0;
	for( $camera in $renderableCameras )
	{
		$outputPrefix = GetOutputPrefix( 0, 0, $renderLayer, $camera, "" );
		fprint $fileId ( "OutputFilename" + $outputCount + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix)  + "\n" );
		$outputCount++;
	}

	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=" + `checkBox -q -v frw_renderManFrameDependent` + "\n" ); // this can be enabled because renderman export jobs can be done across multiple machines
	fprint $fileId ( "Frames=" + $frameList + "\n" );
	fprint $fileId ( "ChunkSize=1\n" );

	if( `checkBox -q -value frw_RendermanIsBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_RendermanMachineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_RendermanMachineList` + "\n" );

	WriteIntegrationSettings( $fileId, 1 );

	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/renderman_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

	fprint $fileId ( "RibFile=" + $inputPath + "\n" );
	fprint $fileId ( "WorkingDirectory=" + CheckSlashes( $projectPath ) + "\n" );
	fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_rendermanThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_rendermanArgs` + "\n" );
	fclose $fileId;

	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;

	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
}

proc int SetupRendermanExportJob( string $renderer )
{
	global int $RendermanExportJobType;

	int $submitCounter = 0;

	string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $RendermanExportJobType, "" );

	$submitCounter++;

	int $submitDependentJob = `checkBox -q -v frw_submitRenderManJob`;
	if( $submitDependentJob )
	{
		if (!IsRenderLayersOn())
		{
			SetupRenderManJob( $jobId, "" );
			$submitCounter++;
		}
		else
		{

			// Loop through the render layers
			string $renderLayerList[] = getRenderableRenderLayers();
			for( $i = 0; $i < size( $renderLayerList ); $i++ )
			{
				string $renderLayer = GetRenderLayerDisplayName( $renderLayerList[$i] );

				SetupRenderManJob( $jobId, $renderLayer );
				$submitCounter++;
			}
		}
	}

	return $submitCounter;
}

proc SetupRedshiftJob( string $jobId, string $renderLayer )
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;

	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );

	string $projectPath = `textFieldGrp -q -text frw_projectPath`;

	string $redShiftFileName = GetStrippedSceneFileName();
	int $ignoreOutFormatControl = false;
	int $exportLocal = `checkBox -q -v frw_exportRedshiftLocal`;
	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		int $paddingSize = 4; // Redshift export always sets up a padding size of 4
		string $padding = "";
		while( size($padding) < $paddingSize )
			$padding = "0" + $padding;

		int $periodInExt = `getAttr "defaultRenderGlobals.periodInExt"`;
		int $putFrameBeforeExt = `getAttr "defaultRenderGlobals.putFrameBeforeExt"`;

		if( $periodInExt == 0 ) // name#.ext
		{
			$redShiftFileName += $padding;
		}
		else if( $periodInExt == 1 )
		{
			if( $putFrameBeforeExt ) // name.# or name.#.ext
			{
				$redShiftFileName += "." + $padding;
			}
			else // name.ext.#
			{
				$redShiftFileName += ".rs." + $padding;
				$ignoreOutFormatControl = true;
			}
		}
		else if( $periodInExt == 2 ) // name_#.ext
		{
			$redShiftFileName += "_" + $padding;
		}
	}

	if( !$ignoreOutFormatControl && `getAttr "defaultRenderGlobals.outFormatControl"` == 0 )
		$redShiftFileName += ".rs";


	string $inputPath = CheckSlashes( $projectPath + "/redshift/" );
	if(size($renderLayer))
	{
		$inputPath += $renderLayer + "/";
	}
	$inputPath += $redShiftFileName;

	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";

	string $submitFilename = CheckSlashes( $tempDir + "/redshift_deadline_info.job" );

	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	if( size($renderLayer) )
	{
		$jobName += " - " + $renderLayer;
	}

	fprint $fileId ( "Plugin=Redshift\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );

	if( !$exportLocal || size($renderLayer) )
	{
		fprint $fileId ( "BatchName=" + $batchName + "\n" );
	}

	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineRedshiftPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineRedshiftSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_RedshiftJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_RedshiftOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_RedshiftSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_RedshiftMinSlaveTimeout` + "\n" );
	fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_RedshiftAutoTaskTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_RedshiftConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_RedshiftGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_RedshiftLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_RedshiftLimitGroups` + "\n" );

	$outputPrefix = GetOutputPrefix( 0, 0, $renderLayer, "", "" );
	fprint $fileId ( "OutputFilename0=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix )  + "\n" );

	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=" + `checkBox -q -v frw_redshiftFrameDependent` + "\n" ); // this can be enabled because redshift export jobs can be done across multiple machines
	fprint $fileId ( "Frames=" + $frameList + "\n" );
	fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -value frw_FrameGroup` + "\n" );

	if( `checkBox -q -value frw_RedshiftIsBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_RedshiftMachineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_RedshiftMachineList` + "\n" );

	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/redshift_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

	fprint $fileId ( "SceneFile=" + $inputPath + "\n" );
	fprint $fileId ( "WorkingDirectory=" + CheckSlashes( $projectPath ) + "\n" );
	fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_redshiftThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_redshiftArgs` + "\n" );
	fclose $fileId;

	// Submit the job to Deadline
	string $submissionCommand = "\"" + $submitFilename + "\" \"" + $jobFilename + "\"";
	string $submitResults = CallDeadlineCommand( $submissionCommand, true );

	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
}

proc int SetupRedshiftExportJob( string $renderer, string $layer )
{
	global int $RedshiftExportJobType;

	int $submitCounter = 0;

	string $jobId = "";

	int $submitDependentJob = `checkBox -q -v frw_submitRedshiftJob`;
	int $exportLocal = `checkBox -q -v frw_exportRedshiftLocal`;

	if( !$exportLocal || !$submitDependentJob )
	{
		$jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $RedshiftExportJobType, "" );
		$submitCounter++;
	}
	else
	{
		print("Running local Redshift export...\n");

		string $resultFile = `textFieldGrp -q -text frw_projectPath` + "/redshift/";

		if(size($layer)) // A render layer has been specified
		{
			$resultFile += $layer + "/";
		}

		if(!`file -q -exists $resultFile`)
		{
			sysFile -makeDir $resultFile;
		}

		$resultFile = CheckSlashes($resultFile + basenameEx(`file -q -sceneName`));

		if(!IsAnimatedOn())
		{
			$resultFile += ".rs";
			rsProxy -fp $resultFile;
		}
		else
		{
			string $frameList = `textFieldGrp -q -text frw_FrameList`;
			string $frameListParsed = CallDeadlineCommand( "-ParseFrameList " + $frameList + " False", false );
			string $frameListArray[];

			tokenize $frameListParsed "," $frameListArray;

			string $currFile; int $frameNum; string $paddedFrame;
			for($frame in $frameListArray)
			{
				$paddedFrame = $frame;
				while( size($paddedFrame) < 4 )
				{
					$paddedFrame = "0" + $paddedFrame;
				}

				$currFile = $resultFile + "." + $paddedFrame + ".rs";
				$frameNum = $frame;
				rsProxy -fp $currFile -s $frameNum -e $frameNum -b 1;
			}
		}
	}

	if( $submitDependentJob )
	{
		SetupRedshiftJob( $jobId, $layer );
		$submitCounter++;
	}

	return $submitCounter;
}

global proc SetupSubmission()
{
	global string $DeadlineSubmitterWindow;
	global string $StartupScriptPathGrp;
	global int $MayaRenderJobType;
	global int $MentalRayExportJobType;
	global int $VRayExportJobType;
	global int $RendermanExportJobType;
	global int $ArnoldExportJobType;
	global int $MaxwellExportJobType;
	global int $BifrostSimulationJobType;
	global int $AlembicExportJobType;
	global int $MayaScriptJobType;
	global int $GeometryCachingJobType;
	global int $FluidCachingJobType;
	global int $RedshiftExportJobType;

	SavePersistentDeadlineOptions();
	print( "Submitting job to Deadline...\n" );

	// Get the current renderer
	string $renderer = GetCurrentRenderer();

	// Check if we are doing a mental ray export
	int $jobType = `optionMenuGrp -q -select frw_mayaJobType`;

	/*
	// Check that if the renderer is Gelato that we are using MayaBatch
	if( $renderer == "gelato" && `getAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin` != 1)
	{
		string $errorMessage = "The Maya plugin does not support the Gelato renderer.  Please select the checkbox to use the MayaBatch plugin.\n\n";
		string $result = `confirmDialog -title "Submission Error" -message ( $errorMessage ) -button "OK" -defaultButton "OK"`;
		return;
	}
	*/

	/*
	// Ensure that the scene is animated
	if( !IsAnimatedOn() )
	{
		string $errorMessage = "";
		if ( $renderer == "vray" )
		{
			if( IsOldVray() )
				$errorMessage = "Animation checkbox under Image File Output is not checked. Deadline requires that animation be enabled.\n\n";
			else
				$errorMessage = "Frame/Animation Ext in render globals is set for a single frame. Deadline requires that animation be enabled.\n\n";
		}
		else
			$errorMessage = "Frame/Animation Ext in render globals is set for a single frame. Deadline requires that animation be enabled.\n\n";

		string $result = `confirmDialog -title "Submission Error" -message ( $errorMessage ) -button "OK" -defaultButton "OK"`;
		return;
	}
	*/

	// Check all the paths for problems, and warn the user if any are found
	string $projectPath = CheckSlashes( `textFieldGrp -q -text frw_projectPath` );
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $sceneFilePath = CheckSlashes( `file -q -sceneName` );
	string $mentalRayFilename = CheckSlashes( `textFieldGrp -q -text frw_mentalRayFilePath` );
	string $vrayFilename = CheckSlashes( `textFieldGrp -q -text frw_vrayFilePath` );
	string $maxwellExportFilename = CheckSlashes( `textFieldGrp -q -text frw_maxwellScriptName` );

	int $submitMayaSceneFile = `checkBox -q -value frw_submitMayaScene`;

	string $message = "";
	if( !$submitMayaSceneFile && IsLocalDrive( $sceneFilePath ) )
		$message = $message + "Maya Scene file, \"" + $sceneFilePath + "\" is on a local drive and is not being submitted.\nSlaves will not be able to access the scene file.\n\n";

	if( IsLocalDrive( $projectPath ) )
		$message = $message + "Project path, \"" + $projectPath + "\" is on a local drive.\nParticle caching and other Maya features will not be available.\n\n";

	int $exportDependentJob = false;
	if( $jobType == $MentalRayExportJobType )
	{
		$binary = false;
		if( catch( $binary = `radioButton -query -select MayatomrExport_Binary` ) )
		{
			string $result = `confirmDialog -parent $DeadlineSubmitterWindow -title "Error Reading Export Options" -message "Could not read in Mental Ray Export settings. Please ensure that the Mental Ray Export settings dialog is open when submitting the job to Deadline." -button "Export Settings..." -button "Cancel" -defaultButton "Export Settings..." -cancelButton "Cancel" `;
			if( $result == "Export Settings..." )
				OpenExportSettings();
			return;
		}

		string $mentalRayPath = dirname( $mentalRayFilename );
		if( ! `filetest -d $mentalRayPath` )
			$message = $message + "Mental Ray output path \"" + $mentalRayPath + "\" does not exist!  Your Mental Ray files will be lost!\n\n";
		else if( IsLocalDrive( $mentalRayFilename ) )
			$message = $message + "Mental Ray output file \"" + $mentalRayFilename + "\" is on a local drive.\nSlaves will not be able to copy the Mental Ray files to this drive.\n\n";
		else if( size( $mentalRayFilename ) == 0 )
			$message = $message + "Mental Ray output file is blank! Your Mental Ray files will be lost!\n\n";

		$exportDependentJob = `checkBox -q -v frw_submitMentalRayJob`;
	}
	else if( $jobType == $VRayExportJobType )
	{
		string $vrayPath = dirname( $vrayFilename );
		if( ! `filetest -d $vrayPath` )
			$message = $message + "VRay export path \"" + $vrayPath + "\" does not exist!  Your VRay files will be lost!\n\n";
		else if( IsLocalDrive( $vrayFilename ) )
			$message = $message + "VRay output file \"" + $vrayFilename + "\" is on a local drive.\nSlaves will not be able to copy the exported VRay files to this drive.\n\n";
		else if( size( $vrayFilename ) == 0 )
			$message = $message + "VRay output file is blank! Your exported VRay files will be lost!\n\n";

		int $submitDependentJob = `checkBox -q -v frw_submitVRayJob`;
		if( $submitDependentJob && `getAttr( "vraySettings.misc_separateFiles" )` )
			$message = $message + "Dependent VRay standalone job option is not compatible with the 'Separate Files' option in the VRay Translator settings. No dependent jobs will be submitted.\n\n";

		if( `checkBox -q -v frw_submitVrimg2ExrJob` && $submitDependentJob )
		{
			string $vrimgOutputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", "", "" ) );
			string $vrimgOutputFilename = CheckSlashes( $outputFilePath  + "/" + $vrimgOutputPrefix );

			if( fileExtension( $vrimgOutputFilename ) != "vrimg" )
				$message = $message + "Dependent Vrimg2Exr job is enabled, but the output format is not vrimg!\n\n";
		}

		$exportDependentJob = `checkBox -q -v frw_submitVRayJob`;
	}
	else if( $jobType == $RendermanExportJobType )
	{
		$exportDependentJob = `checkBox -q -v frw_submitRenderManJob`;
	}
	else if( $jobType == $ArnoldExportJobType )
	{
		$exportDependentJob = `checkBox -q -v frw_submitArnoldJob`;
	}
	else if( $jobType == $MaxwellExportJobType )
	{
		string $maxwellExportDirectory = dirname( $maxwellExportFilename );
		if( size( $maxwellExportFilename ) == 0 )
			$message = $message + "Maxwell script name is blank! No maxwell script will be exported!\n\n";
		else if( !`filetest -d $maxwellExportDirectory` )
			$message = $message + "Maxwell export directory \"" + $maxwellExportDirectory + "\" does not exist!  No maxwell script will be exported!\n\n";
		else if( IsLocalDrive( $maxwellExportDirectory ) )
			$message = $message + "Maxwell export directory \"" + $maxwellExportDirectory + "\" is on a local drive.\nSlaves will not be able to copy the exported Maxwell Files to this drive.\n\n";
	}
	else if( $jobType == $RedshiftExportJobType )
	{
		$exportDependentJob = `checkBox -q -v frw_submitRedshiftJob`;
	}

	// If not an export job, or it is an export job with a dependent job, warn about the output.
	if( $jobType == $MayaRenderJobType || $exportDependentJob )
	{
		if( size( $outputFilePath ) == 0 )
			$message = $message + "Image Output Path is blank! Your final images will be lost!\n\n";

		if( ! `filetest -d $outputFilePath`  )
		{
			if( ! `filetest -d ( $projectPath + "/" + $outputFilePath)`  )
			{
				$message = $message + "Image Output Path \"" + $outputFilePath + "\" does not exist! Your final images will be lost!\n\n";
			}
			else if( IsLocalDrive( ( $projectPath + "/" + $outputFilePath) ) )
			{
				$message = $message + "Image Output Path \"" + ( $projectPath + "/" + $outputFilePath) + "\" is on a local drive.\nSlaves will not be able to copy images to this drive.\n\n";
			}
		}
		else
		{
			if( IsLocalDrive( $outputFilePath ) )
			{
				$message = $message + "Image Output Path \"" + $outputFilePath + "\" is on a local drive.\nSlaves will not be able to copy images to this drive.\n\n";
			}
		}
	}

	// If there is a startup script, make sure it exists and that it isn't local.
	if( `checkBox -q -v frw_useMayaBatchPlugin` )
	{
		string $startupScript = `textFieldButtonGrp -q -text $StartupScriptPathGrp`;
		$startupScript = `strip $startupScript`;
		if( $startupScript != "" )
		{
			if( ! `filetest -e $startupScript` )
				$message = $message + "Startup Script \"" + $startupScript + "\" does not exist!\n\n";
			else if( IsLocalDrive( $startupScript ) )
				$message = $message + "Startup Script \"" + $startupScript + "\" is on a local drive.\nSlaves will not be able to access it at render time.\n\n";
		}
	}

	int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;

	int $regionRendering = `checkBox -q -value frw_regionRendering`;
	if( $regionRendering )
	{
		string $extension = fileExtension( GetOutputPrefix( 0, 0, "", "", "" ) );
		$extension = tolower( $extension );
		if( $extension != "bmp" && $extension != "dds" && $extension != "exr" && $extension != "jpg" && $extension != "png" && $extension != "sgi" && $extension != "tga" && $extension != "tif" )
			$message = $message + "The image format used is not compatible with the Tile Assembler, so you will have to assemble the final image manually.\nThe following formats are currently supported: bmp, dds, exr, jpg, png, sgi, tga, tif.\n\n";
	}

	if( $jobType == $GeometryCachingJobType )
	{
		string $geos[] = `listTransforms -geometry`;
		string $sels[] = `ls -sl`;

		string $selectedGeos[] = IntersectTwoStringArray($geos, $sels); // This is all of the selected Geometry

		if( !size( $selectedGeos ) )
		{
			confirmDialog -parent $DeadlineSubmitterWindow -title "No Selected Geometry Found" -message "No Geometry from this scene were selected. Make sure to select at least one Geometry before submitting a Geometry cache job." -button "OK";
			return;
		}

		string $geoDir = `textFieldButtonGrp -q -text frw_GeometricCacheOutputDir`;
		if( ! `filetest -d $geoDir` )
		{
			$message = $message + "No output directory has been specified. The results of this Geometry caching job may not be saved.\n\n";
		}

	}

	if( $jobType == $MayaScriptJobType ) // Make sure script file exists
	{
		string $mayaFile = `textFieldButtonGrp -q -text frw_mayaScriptJob`;
		if( ! `filetest -e $mayaFile` )
		{
			$message = $message + "The Script file specified does not exist. This script job may produce unexpected results.\n\n";
		}
	}

	if( $jobType == $AlembicExportJobType) // Make sure a file name has been specified
	{
		if( ! size(`ls -sl`) && `radioButtonGrp -q -select frw_AlembicExportSelection` == 2) // Chose to submit a custom selection, but nothing was selected
		{
			confirmDialog -parent $DeadlineSubmitterWindow -title "No Selected Items Found" -message "Nothing in this scene has been selected. Please select at least one item or change the Export option to \"All\" " -button "OK";
			return;
		}

		string $alembicFile = `textFieldButtonGrp -q -text frw_alembicExportFile`;
		if( ! `filetest -e $alembicFile` )
		{
			$message = $message + "No file has been set for Alembic export. The file must be saved or the job may produce unexpected results.\n\n";
		}
	}

	if( $jobType == $BifrostSimulationJobType ) // Make sure directory exists
	{
		string $biFrostDir = `textFieldButtonGrp -q -text frw_bifrostCacheDir`;
		if( ! `filetest -d $biFrostDir` )
		{
			$message = $message + "No output directory has been specified. The results of this Bifrost caching job may not be saved.\n\n";
		}
	}

	if( $jobType == $FluidCachingJobType ) // Make sure directory exists
	{
		string $fluids[] = `listTransforms "-type fluidShape"`;
		string $sels[] = `ls -sl`;

		print(size($fluids) + " " + size($sels) + " " + size(IntersectTwoStringArray($fluids, $sels) ) );

		if( !size( IntersectTwoStringArray( $fluids, $sels ) ) )
		{
			confirmDialog -parent $DeadlineSubmitterWindow -title "No Selected Fluids Found" -message "No Fluids from this scene were selected. Make sure to select at least one Fluid before submitting a Fluid cache job." -button "OK";
			return;
		}

		string $fluidDir = `textFieldButtonGrp -q -text frw_FluidCacheOutputDir`;
		if( ! `filetest -d $fluidDir` )
		{
			$message = $message + "No output directory has been specified. The results of this Fluid caching job may not be saved.\n\n";
		}
	}



	// Display any warning messages
	if( size( $message ) > 0 )
	{
		$message = $message + "\nAre you sure you want to submit this job?";
		string $result = `confirmDialog -parent $DeadlineSubmitterWindow -title "Confirm" -message ( $message ) -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
		if( $result == "No" )
			return;
	}

	// Save scene, if necessary
	if( `file -q -modified` )
	{
		print( "Maya scene has been modified, saving file\n" );
		file -save;
	}
	else
		print( "Maya scene has not been modified, skipping save\n" );

	// umedia
	string $currentPrefix = `getAttr defaultRenderGlobals.imageFilePrefix`;
	if( startsWith($currentPrefix, "<Scene>/") )
	{
		// Create the scene directory and save a copy of the work scene there for publish
		string $currentScene = `file -q -sceneName`;
		string $imageDir = $outputFilePath+GetStrippedSceneFileName();
		string $makedir = "import os;os.makedirs('"+$imageDir+"')";
		python($makedir);
		string $copy = "import shutil;shutil.copy2('"+$currentScene+"','"+$imageDir+"')";
		python($copy);
	}

	int $overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings` && $submitEachRenderLayer && $jobType == $MayaRenderJobType;
	string $originalLayerList[] = getRenderableRenderLayers();
	if( $overrideLayerSettings )
	{
		string $fullLayerList[] = `listConnections renderLayerManager.renderLayerId`;
		for( $renderLayerName in $fullLayerList )
		{

			int $submitOverride = `checkBox -q -value ( "frw_SubmitLayer_" + $renderLayerName )`;
			setAttr( $renderLayerName + ".renderable" ) $submitOverride;
		}
	}

	// If this is not a mental ray export job, check if we need to submit each layer as a separate job.
	if( $jobType == $MayaRenderJobType && IsRenderLayersOn() && $submitEachRenderLayer )
	{
		int $submitCounter = 0;

		// Store the currently selected render layer
		string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
		string $renderLayerList[] = getRenderableRenderLayers();

		// Loop through the render layer if the checkbox is on
		for( $renderLayerName in $renderLayerList )
		{
			// Select the render layer to make sure the render settings are updated
			if( !catch(`editRenderLayerGlobals -currentRenderLayer $renderLayerName`) )
			{
				$renderer = GetCurrentRenderer();

				// Check if we're submitting each camera as a separate job.
				if( `checkBox -q -v frw_submitEachCamera` )
				{
					int $ignoreDefaultCameras = `checkBox -q -v frw_ignoreDefaultCameras`;

					string $cameraNames[] = deadlineGetRenderableCameras( $ignoreDefaultCameras );;
					if( size($cameraNames) == 0 )
					{
						confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message "The scene contains no renderable non-default cameras." -button "Close";
						return;
					}
					for( $cameraName in $cameraNames )
					{
						// Set up a tile rendering job if necessary.
						if( $regionRendering && SupportsRegionRendering( $renderer ) )
							$submitCounter += SetupRegionRenderingJob( $renderer, $cameraName );
						else
						{
							WriteJobFilesAndSubmit( $renderer, 0, 0, $jobType, $cameraName );
							$submitCounter++;
						}
					}
				}
				else
				{
					// Set up a tile rendering job if necessary.
					if( $regionRendering && SupportsRegionRendering( $renderer ) )
						$submitCounter += SetupRegionRenderingJob( $renderer, "" );
					else
					{
						WriteJobFilesAndSubmit( $renderer, 0, 0, $jobType, "" );
						$submitCounter++;
					}
				}
			}
		}

		// Reselect the current render layer
		editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;

		string $submitsResults = "Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.";
		confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message $submitsResults -button "Close";
	}
	else
	{
		if( $jobType == $MentalRayExportJobType )
		{
			int $submitCounter = SetupMentalRayExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $VRayExportJobType )
		{
			int $submitCounter = SetupVRayExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $RendermanExportJobType )
		{
			int $submitCounter = SetupRendermanExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $ArnoldExportJobType )
		{
			int $submitCounter = SetupArnoldExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $MaxwellExportJobType )
		{
			int $submitCounter = SetupMaxwellExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $RedshiftExportJobType )
		{
			// Render current layer or walk all layers
			int $submitCounter = 0;
			if( `checkBox -q -v frw_redshiftLayerSubmission` )
			{
				string $origLayer = `editRenderLayerGlobals -q -crl`;
				for( $layer in `ls -type renderLayer`)
				{
					editRenderLayerGlobals -crl $layer;
					$submitCounter += SetupRedshiftExportJob( $renderer, $layer );
				}
				editRenderLayerGlobals -crl $origLayer;
			}
			else
			{
				$submitCounter = SetupRedshiftExportJob( $renderer, "" );
			}
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else
		{
			// Check if we're submitting each camera as a separate job.
			if( `checkBox -q -v frw_submitEachCamera` )
			{
				int $submitCounter = 0;
				int $ignoreDefaultCameras = `checkBox -q -v frw_ignoreDefaultCameras`;

				string $cameraNames[] = deadlineGetRenderableCameras( $ignoreDefaultCameras );
				if( size($cameraNames) == 0 )
				{
					confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message "The scene contains no renderable non-default cameras." -button "Close";
					return;
				}
				for( $cameraName in $cameraNames )
				{
					// Only setup a tile rendering job if it is enabled.
					if( $regionRendering && SupportsRegionRendering( $renderer ) )
						$submitCounter += SetupRegionRenderingJob( $renderer, $cameraName );
					else
					{
						WriteJobFilesAndSubmit( $renderer, 0, 0, $jobType, $cameraName );
						$submitCounter++;
					}
				}

				string $submitsResults = "Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.";
				confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message $submitsResults -button "Close";
			}
			else
			{
				// Only setup a tile rendering job if it is enabled.
				if( $regionRendering && SupportsRegionRendering( $renderer ) )
				{
					int $submitCounter = SetupRegionRenderingJob( $renderer, "" );
					confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
				}
				else
				{
					string $jobId = WriteJobFilesAndSubmit( $renderer, 1, 0, $jobType, "" );
				}
			}
		}
	}


	if( $overrideLayerSettings )
	{
		string $fullLayerList[] = `listConnections renderLayerManager.renderLayerId`;
		for( $renderLayerName in $fullLayerList )
		{
			int $wasRenderable = stringArrayContains( $renderLayerName, $originalLayerList);
			setAttr( $renderLayerName + ".renderable" ) $wasRenderable;
		}

	}

	if( `getAttr defaultRenderGlobals.deadlineCloseOnSubmission` )
	{
		deleteUI -window DeadlineSubmitWindow;
	}

}

global proc setDefaultFrameRange( string $layerName )
{
	string $fieldName = "frw_FrameList_" + $layerName;
	string $frameRange = `textFieldGrp -q -text frw_FrameList`;
	textFieldGrp -edit -text $frameRange $fieldName;
}

global proc LayerSettingsDialog()
{
	string $renderLayerList[] = `listConnections renderLayerManager.renderLayerId`;
	int $chunkSize = `intSliderGrp -q -v frw_FrameGroup`;
	string $jobName = `attributeExists deadlineJobName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobName` : GetStrippedSceneFileName();

	// Add controls to the submission dialog.
	int $windowWidth = 470;
	int $windowHeight = 500;

	int $labelWidth = 110;
	int $controlWidth = 320;

	// Get the dialog's formLayout.
	//
	string $form = `setParent -q`;
	formLayout -e -width ($windowWidth+8) -height $windowHeight $form;

	string $window = `formLayout -q -p $form`;
	print ($form + "\n");

	scrollLayout -width $windowWidth -horizontalScrollBarThickness 0 mainScrollLayout;
		columnLayout -adjustableColumn true -columnAttach "both" 0;

			// Store the currently selected render layer
			string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;

			for( $layer in $renderLayerList )
			{
				if( !catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
				{
					string $frameRange = `textFieldGrp -q -text frw_FrameList`;
					int $frameRangeEnabled = IsAnimatedOn();

					if( $frameRangeEnabled )
					{
						$frameRange = `getAttr defaultRenderGlobals.startFrame` + "-" + `getAttr defaultRenderGlobals.endFrame`;
					}

					frameLayout -label $layer -labelVisible true -borderVisible false -collapsable true;
						columnLayout -adj true -columnAttach "both" 0 -rowSpacing 4;

							$layerJobName = $jobName + " - " + $layer;

							$FieldName = "frw_JobName_" + $layer;
							textFieldGrp -label "Job Name" -cl2 "left" "left" -cw2 $labelWidth 320 -text $layerJobName -changeCommand SavePersistentDeadlineOptions -annotation "The name of the job" $FieldName;

							$FieldName = "frw_FrameList_" + $layer;
							textFieldGrp -label "Frame List" -en $frameRangeEnabled -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "Enter a list of frames to render, separated by commas for separate frames, or dashes for continuous sequences of frames. e.g. 1, 5-10, 100" -text $frameRange $FieldName;

							rowLayout -numberOfColumns 4 -cw 1 290 -ct1 "right";
								$FieldName = "frw_SubmitLayer_" + $layer;
								checkBox -label "Submit Layer" -v ( getAttr( $layer + ".renderable" ) ) -annotation "Whether or not the layer should be submitted." $FieldName;

								text -label "";
								$FieldName = "frw_DefaultFramesButton_" + $layer;
								button -label "Use Default Frame Range" -c ("setDefaultFrameRange(\"" + $layer + "\")");
							setParent ..;

							$FieldName = "frw_FrameGroup_" + $layer;
							intSliderGrp -label "Task Size" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v $chunkSize -changeCommand SavePersistentDeadlineOptions -annotation "Each task for the job will consist of this many frames" $FieldName;

						setParent ..;
					setParent ..;
				}
			}

			// Reselect the current render layer
			editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;

		setParent ..;
	setParent ..;

	columnLayout -adj true -columnAttach "both" 2 -rowSpacing 4 buttonColumnLayout;
		rowLayout -numberOfColumns 2 -cw2 ($windowWidth / 2) ($windowWidth / 2);
			button -label "Submit Job" -width ($windowWidth / 2 - 4) -height 26 -annotation "Submits this job to Deadline" -align "center" -c SetupSubmission;
			button -label "Close" -width ($windowWidth / 2 - 4)  -height 26 -annotation "Closes this window" -align "center" -c DismissLayoutDialog;
		setParent ..;
	setParent ..;

	formLayout -e
		-af buttonColumnLayout bottom 0
		-af buttonColumnLayout right 0
		-af buttonColumnLayout left 0
		-ac mainScrollLayout bottom 0 buttonColumnLayout
		-af mainScrollLayout top 0
		-af mainScrollLayout left 3
	$form;
}

//---------------------------------------------------------
// Event handler functions.
//---------------------------------------------------------

global proc OpenJigsawWindow()
{
	if(catchQuiet(`python("jigsawThread.isAlive()")`))
	{
		string $path = CheckSlashes( GetMayaRepoPath() + "MayaJigsaw.py" );
		python("execfile(\""+$path+"\")");
	}
	else
	{
		if(`python("jigsawThread.isAlive()")`)
		{
			confirmDialog -title "Jigsaw Rendering" -message "The Jigsaw window is already open." -button "OK" -defaultButton "OK";
			return;
		}
		else
		{
			string $path = CheckSlashes( GetMayaRepoPath() + "MayaJigsaw.py" );
			python("execfile(\""+$path+"\")");
		}
	}
}

// Event when Submit Job button is pressed
global proc DeadlineSubmitterOnOk()
{
	global string $DeadlineSubmitterWindow;
	global int $MayaRenderJobType;

	// Source a CustomSanityChecks.mel file, if it exists. This file can be used to set some of the defaults
	// for the properties below if necessary.
	string $sanityScriptPath = CheckSlashes( GetMayaRepoPath() + "CustomPostSanityChecks.mel" );
	if( `file -q -exists $sanityScriptPath` )
	{

		print( "sourcing custom post sanity check file: " + $sanityScriptPath + "\n" );
		eval( "source \"" + $sanityScriptPath + "\";" );
		if( !CustomPostSanityCheck() )
			return;
	}

	// Check if we are doing a mental ray export
	int $jobType = `optionMenuGrp -q -select frw_mayaJobType`;
	if( `checkBox -q -v frw_submitEachRenderLayer` && `checkBox -q -v frw_overrideLayerSettings` && $jobType == $MayaRenderJobType )
		layoutDialog -parent $DeadlineSubmitterWindow -title "Override Layer Job Settings" -ui "LayerSettingsDialog";
	else
		SetupSubmission();
}

global proc DismissLayoutDialog()
{
	layoutDialog -dismiss "";
}

global proc OnExit()
{
	python("jigThreadExists = True");
	python("try:\n\tjigThreadExists = jigsawThread.isAlive()\nexcept:\n\tjigThreadExists = False");
	int $exists = `python("jigThreadExists")`;
	if($exists)
	{
		python("jigsawThread.closeJigsaw()");
	}
}

//Fills the given key/value arrays with info retrieved by running the given script
global proc GetIntegrationInfo( string $scriptPath, string $additionalArgs, string $keyArray[], string $valueArray[] )
{

	$pmResults = CallDeadlineCommand( "-ExecuteScript \"" + $scriptPath + "\" Maya "+ $additionalArgs, false );

	string $tempInfo[];
	$tempInfo = stringToStringArray( $pmResults, "\n" );

	if( size($tempInfo) > 0 )
	{
		int $keyCount = 0;

		$cleared = false;

		for ( $i = 0; $i < size( $tempInfo ); $i++ )
		{
			if ( match( ".+=", $tempInfo[ $i ] ) != "" )
			{
				if ( !$cleared )
				{
					//Only clear lists once we're sure we have valid output
					clear $keyArray;
					clear $valueArray;
					$cleared = true;
				}

				string $tokens[];
				string $value = "";

				if ( tokenize( $tempInfo[ $i ], "=", $tokens ) > 1 )
					$value = $tokens[1];

				string $key = $tokens[0];

				$keyCount++;
				stringArrayInsertAtIndex( $keyCount, $keyArray, $key );
				stringArrayInsertAtIndex( $keyCount, $valueArray, $value );
			}
		}
	}
}

// The extraKVPIndex is initialized to 0. Hence, the content of the integration settings file must be written to the job info file before any other extra KVP, if any.
global proc OpenIntegrationWindow()
{
	string $scriptPath = CheckSlashes( CallDeadlineCommand( "-getrepositorypath submission/Integration/Main/", false) + "\IntegrationUIStandAlone.py" );
	string $IntegrationExtraKVPIndex = 0;
	string $integrationOptions = "Draft Shotgun FTrack NIM " + $IntegrationExtraKVPIndex;
	string $appName = "Maya";

	global string $IntegrationInfoKeys[];
	global string $IntegrationInfoValues[];
	GetIntegrationInfo( $scriptPath, $appName + " " + $integrationOptions, $IntegrationInfoKeys, $IntegrationInfoValues );
}

// ===============================================================================================================
// The main function called by the Maya proxy script
// ===============================================================================================================

global proc SubmitJobToDeadline()
{
	global string $DeadlineSubmitterWindow;
	global string $ImageOutputPathGrp;
	global string $StartupScriptPathGrp;
	global string $ProjectPathGrp;
	global string $MentalRayFilenameGrp;
	global string $CompositeNamePathGrp;
	global string $VRayFilenameGrp;
	global string $LimitGroupGrp;
	global string $DependenciesGrp;
	global string $MachineListGrp;
	global string $JobNameGrp;

	global string $MayaRenderOptionsRollout;
	global string $MayaRenderOptionsArnoldRollout;
	global string $MayaRenderOptionsMentalRayRollout;
	global string $MayaRenderOptionsRedshiftRollout;
	global string $MayaRenderOptionsIRayRollout;
	global string $MayaRenderOptionsVRayRollout;
	global string $MayaRenderOptionsTileRollout;
	global string $MayaRenderOptionsJigsawRollout;
	global string $MentalRayExportRollout;
	global string $MentalRayExportRenderJobRollout;
	global string $VrayExportRollout;
	global string $VrayExportRenderJobRollout;
	global string $VrayExportVrimgJobRollout;
	global string $RendermanExportRollout;
	global string $RendermanExportRenderJobRollout;
	global string $ArnoldExportRollout;
	global string $ArnoldExportRenderJobRollout;
	global string $BifrostSimulationJobRollout;
	global string $AlembicExportJobRollout;
	global string $AlembicAdvancedOptionsJobRollout;
	global string $MayaScriptJobRollout;
	global string $FluidCachingJobRollout;
	global string $GeometryCachingJobRollout;
	global string $RedshiftExportRollout;
	global string $RedshiftExportRenderJobRollout;

	global string $MaxwellExportRollout;
	global string $MaxwellExportRenderJobRollout;
	global string $MaxwellExportCoopOptionsRollout;

	global string $openJigsawBtn;

	global int $PreviousImageCompType;
	global int $SelectedImageCompType;

	global string $VrayLimitGroupGrp;
	global string $VrayMachineListGrp;

	global string $MentalLimitGroupGrp;
	global string $MentalMachineListGrp;

	global string $RendermanLimitGroupGrp;
	global string $RendermanMachineListGrp;

	global string $ArnoldLimitGroupGrp;
	global string $ArnoldMachineListGrp;

	global string $MaxwellLimitGroupGrp;
	global string $MaxwellMachineListGrp;
	global string $MaxwellOutputScriptListGrp;

	global string $BifrostDirectoryButtonGrp;
	global string $BifrostFileButtonGrp;

	global string $MayaScriptButtonGrp;

	global string $AlembicFileButtonGrp;

	global string $GeometryCachingDirButtonGrp;
	global string $FluidCachingDirButtonGrp;


	// This is a workaround for what seems like a bug in Maya vector rendering. Without it, the
	// renderer would spit out "Error: No object matches name: defaultRenderGlobals.imageNamePrefix".
	AddStringAttribute( "imageNamePrefix" );

	// Source a CustomSanityChecks.mel file, if it exists. This file can be used to set some of the defaults
	// for the properties below if necessary.
	//string $root = CallDeadlineCommand( "-getrepositoryroot" );
	//string $sanityScriptPath = CheckSlashes( $root + "/submission/Maya/Main/CustomSanityChecks.mel" );
	string $sanityScriptPath = CheckSlashes( GetMayaRepoPath() + "\CustomSanityChecks.mel" );
	if( `file -q -exists $sanityScriptPath` )
	{
		print( "sourcing custom sanity check file: " + $sanityScriptPath + "\n" );
		eval( "source \"" + $sanityScriptPath + "\";" );
	}

	// Get the renderer.
	string $renderer = GetCurrentRenderer();
	// Get the initial property values.
	string $jobName = `attributeExists deadlineJobName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobName` : GetStrippedSceneFileName();
	string $jobComment =  `attributeExists deadlineJobComment defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobComment` : "";
	string $department = `attributeExists deadlineDepartment defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDepartment` : "";
	string $savedGroup = `attributeExists deadlineGroup defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineGroup` : "none";

	string $savedJobPool = `attributeExists deadlineJobPool defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobPool` : "none";
	string $savedJobSecondaryPool = `attributeExists deadlineJobSecondaryPool defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobSecondaryPool` : "";
	//int $useOnlyPool = `attributeExists deadlineUseOnlyPool defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUseOnlyPool` : false;
	int $priority = `attributeExists deadlineJobPriority defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobPriority` : 50;
	int $limitCount = `attributeExists deadlineLimitCount defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineLimitCount` : 0;
	int $concurrentTasks = `attributeExists deadlineConcurrentTasks defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineConcurrentTasks` : 1;
	int $SlaveTimeout = `attributeExists deadlineSlaveTimeout defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSlaveTimeout` : 0;
	int $MinSlaveTimeout = `attributeExists deadlineMinSlaveTimeout defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMinSlaveTimeout` : 0;
	int $AutoTaskTimeout = `attributeExists deadlineAutoTaskTimeout defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineAutoTaskTimeout` : false;
	string $limitGroups = `attributeExists deadlineLimitGroups defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineLimitGroups` : "";
	string $dependencies = "";
	int $submitAsSuspended = `attributeExists deadlineSubmitAsSuspended defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitAsSuspended` : false;
	int $closeOnSubmission = `attributeExists deadlineCloseOnSubmission defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineCloseOnSubmission` : false;

	//int $deleteOnComplete = `attributeExists deadlineDeleteOnComplete defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDeleteOnComplete` : false;

	string $machineList = `attributeExists deadlineMachineList defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMachineList` : "";
	int $isBlacklist = `attributeExists deadlineIsBlacklist defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIsBlacklist` : false;

	int $chunkSize = `attributeExists deadlineChunkSize defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineChunkSize` : 1;
	int $submitMayaScene = `attributeExists deadlineSubmitMayaScene defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitMayaScene` : false;
	//int $cpus = `attributeExists deadlineNumCPUs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineNumCPUs` : 2;
	int $submitEachRenderLayer = `attributeExists deadlineSubmitEachRenderLayer defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitEachRenderLayer` : true;
	int $overrideGlobalRange = `attributeExists deadlineOverrideGlobalRange defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineOverrideGlobalRange` : false;
	int $overrideLayerSettings = `attributeExists deadlineOverrideLayerSettings defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineOverrideLayerSettings` : false;
	int $submitEachCamera = `attributeExists deadlineSubmitEachCamera defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitEachCamera` : false;
	int $ignoreDefaultCameras = `attributeExists deadlineIgnoreDefaultCameras defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIgnoreDefaultCameras` : false;
	int $useMayaBatchPlugin = `attributeExists deadlineUseMayaBatchPlugin defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin` : true;
	int $useLocalAssetCaching = `attributeExists deadlineUseLocalAssetCaching defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUseLocalAssetCaching` : false;
	int $localRendering = `attributeExists deadlineLocalRendering defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineLocalRendering` : false;
	int $strictErrorChecking = `attributeExists deadlineStrictErrorChecking defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineStrictErrorChecking` : true;
	string $startupScript = `attributeExists deadlineStartupScript defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineStartupScript` : "";
	string $mayaArgs = `attributeExists deadlineMayaArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMayaArgs` : "";

	int $submitMentalRayJob = `attributeExists deadlineSubmitMentalRayJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitMentalRayJob` : false;
	int $mentalRayThreads = `attributeExists deadlineMentalRayThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayThreads` : 0;
	int $mentalRayOffset = `attributeExists deadlineMentalRayOffset defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayOffset` : 0;
	int $mentalRayLocalRendering = `attributeExists deadlineMentalRayLocalRendering defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayLocalRendering` : false;
	string $mentalRayArgs = `attributeExists deadlineMentalRayArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayArgs` : "";

	//string $savedOutputFilePath = `attributeExists deadlineOutputFilePath defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineOutputFilePath` : GetImageDirectory();
	//string $projectPath = `attributeExists deadlineProjectPathOverride defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineProjectPathOverride` : `workspace -q -fullName`;
	string $savedOutputFilePath = GetImageDirectory();
	string $projectPath = `workspace -q -fullName`;

	string $pmIntegration = `attributeExists deadlineProjectManagement defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineProjectManagement` : "Shotgun";

	int $overrideGlobalRangeEnable = false;
	int $overrideLayerSettingsEnable = false;
	int $tileRenderingEnable = true;
	int $jigsawRenderingEnable = true;
	int $regionRendering = false;
	int $tilesInX = `attributeExists deadlineTilesInX defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTilesInX` : 2;
	int $tilesInY = `attributeExists deadlineTilesInY defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTilesInY` : 2;
	int $tileSingleJob = `attributeExists deadlineTileSingleJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileSingleJob` : true;
	int $tileDependentJob = `attributeExists deadlineTileDependentJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileDependentJob` : true;
	int $tileCompositeOver = `attributeExists deadlineTileCompositeOver defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileCompositeOver` : false;
	string $tileCompositeOverName = `attributeExists deadlineTileCompositeOverName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileCompositeOverName` : "";
	int $tileCleanupJob = `attributeExists deadlineTileCleanupJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileCleanupJob` : false;

	int $tileErrorOnMissing = `attributeExists tileErrorOnMissing defaultRenderGlobals` ? `getAttr defaultRenderGlobals.tileErrorOnMissing` : true;
	int $tileMissingBackground = `attributeExists tileMissingBackground defaultRenderGlobals` ? `getAttr defaultRenderGlobals.tileMissingBackground` : true;

	int $deadlineGPUsPerTask = `attributeExists deadlineGPUsPerTask defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineGPUsPerTask` : 0;
	string $deadlineGPUsSelectDevices = `attributeExists deadlineGPUsSelectDevices defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineGPUsSelectDevices` : "";

	int $irayUseCPUs = `attributeExists deadlineIRayUseCPUs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIRayUseCPUs` : 1;
	float $irayCPULoad = `attributeExists deadlineIRayCPULoad defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIRayCPULoad` : 4.0;


	int $mentalRayAutoMemoryLimit = `attributeExists deadlineMentalRayAutoMemoryLimit defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayAutoMemoryLimit` : true;
	int $mentalRayMemoryLimit = `attributeExists deadlineMentalRayMemoryLimit defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayMemoryLimit` : 0;
	int $vrayAutoMemoryEnabled = `attributeExists deadlineVrayAutoMemoryEnabled defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVrayAutoMemoryEnabled` : false;
	int $vrayAutoMemoryBuffer = `attributeExists deadlineVrayAutoMemoryBuffer defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVrayAutoMemoryBuffer` : 500;

	string $mentalRayFilename = `attributeExists deadlineMentalRayFilename defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayFilename` : "";

	string $vrayFilename = `attributeExists deadlineVRayFilename defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVRayFilename` : "";
	int $submitVRayJob = `attributeExists deadlineSubmitVRayJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitVRayJob` : false;
	int $vrayThreads = `attributeExists deadlineVRayThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVRayThreads` : 0;

	int $submitVrimg2ExrJob = `attributeExists deadlineSubmitVrimg2ExrJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitVrimg2ExrJob` : false;
	int $deleteVrimgFiles = `attributeExists deadlineDeleteVrimgFiles defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDeleteVrimgFiles` : false;

	int $exportRenderManThreads = `attributeExists deadlineExportRenderManThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportRenderManThreads` : 0;
	int $renderRenderManWithRis = `attributeExists deadlineRenderRenderManWithRis defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderRenderManWithRis` : true;
	int $submitRenderManJob = `attributeExists deadlineSubmitRenderManJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitRenderManJob` : false;
	int $renderManFrameDependent = `attributeExists deadlineRenderManFrameDependent defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderManFrameDependent` : true;
	int $rendermanThreads = `attributeExists deadlineRenderManThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderManThreads` : 0;
	string $rendermanArgs = `attributeExists deadlineRenderManArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderManArgs` : "";

	int $maxwellAutoMergeFiles = true;

	int $submitArnoldJob = `attributeExists deadlineSubmitArnoldJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitArnoldJob` : false;
	int $exportArnoldLocal = `attributeExists deadlineExportArnoldLocal defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportArnoldLocal` : false;
	int $arnoldThreads = `attributeExists deadlineArnoldThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineArnoldThreads` : 0;
	string $arnoldArgs = `attributeExists deadlineArnoldArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineArnoldArgs` : "";

	int $submitMaxwellJob = `attributeExists deadlineSubmitMaxwellJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitMaxwellJob` : false;
	int $exportMaxwellLocal = `attributeExists deadlineExportMaxwellLocal defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportMaxwellLocal` : false;
	int $maxwellThreads = `attributeExists deadlineMaxwellThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMaxwellThreads` : 0;
	string $maxwellArgs = `attributeExists deadlineMaxwellArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMaxwellArgs` : "";

	int $submitRedshiftJob = `attributeExists deadlineSubmitRedshiftJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitRedshiftJob` : false;
	int $exportRedshiftLocal = `attributeExists deadlineExportRedshiftLocal defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportRedshiftLocal` : false;
	int $redshiftFrameDependent = `attributeExists deadlineRedshiftFrameDependent defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftFrameDependent` : false;
	int $redshiftLayerSubmission = `attributeExists deadlineRedshiftLayerSubmission defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftLayerSubmission` : false;
	int $redshiftThreads = `attributeExists deadlineRedshiftThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftThreads` : 0;
	string $redshiftArgs = `attributeExists deadlineRedshiftArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftArgs` : "";

	// Read in maximum priority.
	string $priorityQuery = CallDeadlineCommand( "-getmaximumpriority", false );
	int $maximumPriority = (int) $priorityQuery;
	if( $maximumPriority == 0 )
		$maximumPriority = 100;

	if( $priority > $maximumPriority )
		$priority = ($maximumPriority / 2);

	// Read in the pools.
	string $deadlinePools[];
	string $poolsQuery = CallDeadlineCommand( "-pools", false );
	tokenize $poolsQuery "\n" $deadlinePools;

	// Read in the groups.
	string $deadlineGroups[];
	string $groupQuery = CallDeadlineCommand( "-groups", false );
	tokenize $groupQuery "\n" $deadlineGroups;

	// Get the frame range.
	int $range[] = GetFrameRange();
	int $fromFrame = $range[0];
	int $toFrame = $range[1];
	int $byFrame = $range[2];

	int $currTime = `currentTime -query`;

	string $frameRange = $fromFrame + "-" + $toFrame;
	if( $byFrame > 1 )
		$frameRange = $frameRange + "x" + $byFrame;

	int $renderHalfFrames = false;
	if( $byFrame == 0.5 )
		$renderHalfFrames = true;

	// Get the CPU count
	int $cpuEnabled = EnableCpuOption( $renderer );
	int $cpus = 0;
	if( $cpuEnabled )
		$cpus = GetCpuSetting( $renderer );

	// Get if layers are enabled
	$renderLayerEnabled = IsRenderLayersOn();

	// Delete any previous windows.
	if( `window -exists DeadlineSubmitWindow` )
		deleteUI -window DeadlineSubmitWindow;

	// Create a new submission dialog window.
	string $window = `window DeadlineSubmitWindow`;
	if( `windowPref -exists DeadlineSubmitWindow` )
		windowPref -remove DeadlineSubmitWindow; // reset preference

	// Get the location of the main window.
	global string $gMainWindow;
	int $mainTopLeft[] = `window -q -tlc $gMainWindow`;

	// Add controls to the submission dialog.
	int $windowWidth = 530;
	int $windowHeight = 780;

	int $labelWidth = 160;
	int $controlWidth = 330;

	string $maxwellScript = "";
	if( `attributeExists mxsPath maxwellRenderOptions` )
	{
		$maxwellScript = `getAttr maxwellRenderOptions.mxsPath`;
	}
	if( $maxwellScript == "" )
	{
		string $exportDir = `workspace -q -fre "translatorData"`;
		string $sceneName = GetStrippedSceneFileName();

		$maxwellScript = $projectPath +"/" + $exportDir + "/"+$sceneName + ".mxs";

	}

	$DeadlineSubmitterWindow = `window -e -resizeToFitChildren true -sizeable true -title "Submit Job To Deadline" -widthHeight ($windowWidth+24) $windowHeight -tlc ($mainTopLeft[0] + 50) ($mainTopLeft[1] + 50) DeadlineSubmitWindow`;
	formLayout -width ($windowWidth+16) -nd 100 mainFormLayout;

	//This is the main scrollable element for the dialog
	scrollLayout -width ($windowWidth+16) -horizontalScrollBarThickness 0 mainScrollLayout;

		//
			columnLayout -adj true -columnAttach "both" 4 mayaTabLayout;

				frameLayout -label "Job Description" -labelVisible true -borderVisible false -collapsable true;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
						$JobNameGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Job Name" -buttonLabel "<" -text $jobName -changeCommand SavePersistentDeadlineOptions -annotation "The name of the job (press '<' button to use the scene file name)" frw_JobName`;
						textFieldButtonGrp -e -bc SetJobName $JobNameGrp;

						textFieldGrp -label "Comment" -cl2 "left" "left" -cw2 $labelWidth 320 -text $jobComment -changeCommand SavePersistentDeadlineOptions -annotation "A brief comment about the job" frw_JobComment;
						textFieldGrp -label "Department" -cl2 "left" "left" -cw2 $labelWidth 320 -text $department -changeCommand SavePersistentDeadlineOptions -annotation "The department the job (or the job's user) belongs to" frw_Department;
					setParent ..;
				setParent ..;

				frameLayout -label "Job Scheduling" -labelVisible true -borderVisible false -collapsable true;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
						string $poolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlinePool`;
						for( $i = 0; $i < size($deadlinePools); ++$i )
						{
							menuItem -label $deadlinePools[$i];
							if( $deadlinePools[$i] == $savedJobPool )
								optionMenuGrp -e -select ($i+1) $poolsBox;
						}

						string $secondaryPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineSecondaryPool`;
						menuItem -label "";
						if( "" == $savedJobSecondaryPool )
							optionMenuGrp -e -select 1 $secondaryPoolsBox;

						for( $i = 0; $i < size($deadlinePools); ++$i )
						{
							menuItem -label $deadlinePools[$i];
							if( $deadlinePools[$i] == $savedJobSecondaryPool )
								optionMenuGrp -e -select ($i+2) $secondaryPoolsBox;
						}

						string $groupsBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_Group`;
						for( $i = 0; $i < size( $deadlineGroups ); ++$i )
						{
							menuItem -label $deadlineGroups[$i];
							if( $deadlineGroups[$i] == $savedGroup )
								optionMenuGrp -e -select ($i+1) $groupsBox;
						}

						intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_JobPriority;
						intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_LimitCount;
						intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_ConcurrentTasks;
						intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_SlaveTimeout;
						intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_MinSlaveTimeout;
						rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
							text -align "left" -label "" frw_dummySubmitSuspendedLabel;
							checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_AutoTaskTimeout;
						setParent ..;

						$LimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text $limitGroups -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_limitGroups`;
						textFieldButtonGrp -e -bc SetLimitGroups $LimitGroupGrp;

						$DependenciesGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Dependencies" -buttonLabel "..." -text $dependencies -changeCommand SavePersistentDeadlineOptions -annotation "The jobs that this job is dependent on." frw_dependencies`;
						textFieldButtonGrp -e -bc SetDependencies $DependenciesGrp;

						$MachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text $machineList -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_machineList`;
						textFieldButtonGrp -e -bc SetMachineList $MachineListGrp;
						print("Machine list is "+$MachineListGrp);

						rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
							string $onCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_onComplete`;
							menuItem -label "Nothing";
							menuItem -label "Archive";
							menuItem -label "Delete";
							optionMenuGrp -e -select (1) $onCompleteBox;

							checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_isBlacklist;
						setParent ..;

						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "" frw_dummySubmitSuspendedLabel;
							checkBox -label "Submit As Suspended" -v $submitAsSuspended -changeCommand SavePersistentDeadlineOptions -annotation "If checked, this job will be submitted in the suspended state" frw_submitAsSuspended;
							checkBox -label "Close on Submission" -v $closeOnSubmission -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the submitter will close after job submission is completed" frw_closeOnSubmission;
						setParent ..;

					setParent ..;
				setParent ..;

				frameLayout -label "Render Options" -labelVisible true -borderVisible false -collapsable true;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
						int $framesEnabled = true;
						if( $renderLayerEnabled && $submitEachRenderLayer )
							$framesEnabled = $overrideLayerSettings;
						$framesEnabled = $framesEnabled && IsAnimatedOn();

						textFieldGrp -label "Frame List" -en $framesEnabled -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "Enter a list of frames to render, separated by commas for separate frames, or dashes for continuous sequences of frames. e.g. 1, 5-10, 100" -text $frameRange frw_FrameList;
						intSliderGrp -label "Frames Per Task" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v $chunkSize -changeCommand SavePersistentDeadlineOptions -annotation "Each task for the job will consist of this many frames" frw_FrameGroup;

						frameLayout -label "Additional Frame Options" -labelVisible true -borderVisible false -collapsable true -collapse true;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;

								string $renderPreviewJobFirstBox = `checkBox -en $framesEnabled -label "Render Preview Job First" -changeCommand SavePersistentDeadlineOptions -annotation "When checked, two jobs will be submitted - a PREVIEW job with a fraction of the frames, and a REST job with all other frames.\n\nThe PREVIEW job can be submitted with slightly higher priority and will provide a glimpse into the final result.\n\nIf its output looks incorrect, you can suspend the REST job before wasting render time rendering a wrong submission." frw_renderPreviewJobFirst`;
								intSliderGrp -label "Priority Offset" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue $maximumPriority -v 5 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the Priority Increase for the PREVIEW job.\n\nFor example if the Job Priority is set to 50 and this value is +5, the PREVIEW job will be submitted with Priority of 55 and the REST job with 50." frw_PreviewPriority;
								intSliderGrp -label "Number of Preview Frames" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v 5 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the number of frames to be submitted as a PREVIEW job.\n\nThe frames will be taken at equal intervals, for example a value of 2 will send the first and last frames, a value of 3 will send first, middle and last and so on." frw_PreviewFrames;
								checkBox -en $framesEnabled -label "Submit Dependent Job With Remaining Frames" -changeCommand SavePersistentDeadlineOptions -annotation "When checked, the [REST OF FRAMES] Job will be made dependent on the [PREVIEW FRAMES] Job.\n\nWhen unchecked, the [REST OF FRAMES] Job will use the same dependencies (none or custom) as the [PREVIEW FRAMES] Job." frw_dependent;

								rowLayout -numberOfColumns 1 -cw1 $labelWidth -ct1 "left";
									string $outOfOrderBox = `optionMenuGrp -label "Task Order" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the Order in which the Task List will be processed." frw_taskOrder`;
									menuItem -label "First To Last (Forward)";
									menuItem -label "Every Nth, Then Forward";
									menuItem -label "Every Nth - Block Fill";
									menuItem -label "Every Nth - Half Raster Refine";
									menuItem -label "Last To First (Reverse)";
									menuItem -label "First And Last Frames First";
									menuItem -label "From Both Ends";
									menuItem -label "From Center";
									menuItem -label "From Both Ends And From Center";
									menuItem -label "Random";
									optionMenuGrp -e -select (1) $outOfOrderBox;
								setParent ..;

								intSliderGrp -label "Out Of Order Step" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v 2 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the Nth frame step to use for the Task List Order settings." frw_taskOrderStep;

							setParent..;
						setParent..;

						rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
							string $camerasBox = `optionMenuGrp -label "Camera" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "Leave blank to render using the default camera settings." frw_camera`;
							//string $cameraList[] = `ls -cameras`;
							menuItem -label " ";
							//int $i; for( $i = 0; $i < size($cameraList); ++$i )
							//	menuItem -label $cameraList[$i];

							string $cameraNames[] = `listTransforms -cameras`;
							for( $cameraName in $cameraNames )
								menuItem -label $cameraName;

							optionMenuGrp -e -select (1) $camerasBox;
						setParent ..;

						$ProjectPathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Project Path" -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "Use this Maya project path to load the Maya scene" frw_projectPath`;
						textFieldButtonGrp -e -bc SetProjectDir $ProjectPathGrp;

						$ImageOutputPathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Output Path" -buttonLabel "..." -text $savedOutputFilePath -changeCommand SavePersistentDeadlineOptions -annotation "The path to which the output files will be sent. Must be network accessible." frw_outputFilePath`;
						textFieldButtonGrp -e -bc SetImageDir $ImageOutputPathGrp;

						$mayaBuildEnabled = true;
						rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
							string $mayaBuildBox = `optionMenuGrp -en $mayaBuildEnabled -label "Maya Build" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Force Deadline to render using the specified build of Maya" frw_mayaBuild`;
							menuItem -label "None";
							menuItem -label "32bit";
							menuItem -label "64bit";
							if( $mayaBuildEnabled )
							{
								if( `about -macOS` )
									optionMenuGrp -e -select (1) $mayaBuildBox;
								else
								{
									if( `about -is64` )
										optionMenuGrp -e -select (3) $mayaBuildBox;
									else
										optionMenuGrp -e -select (2) $mayaBuildBox;
								}
							}
							else
								optionMenuGrp -e -select (1) $mayaBuildBox;

							string $submitMayaSceneBox = `checkBox -label "Submit Maya Scene File" -v $submitMayaScene -changeCommand SavePersistentDeadlineOptions -annotation "If unchecked, the Maya scene file should be network accessible. If checked, XGen files in the scene's directory will also be submitted." frw_submitMayaScene`;
						setParent ..;

						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "" frw_dummyMayaBatchLabel;
							checkBox -label "Use MayaBatch Plugin" -align "left" -v $useMayaBatchPlugin -changeCommand SavePersistentDeadlineOptions -annotation "The MayaBatch plugin is a new Maya plugin which keeps the scene loaded between frames" frw_useMayaBatchPlugin;
							checkBox -enable (!$useMayaBatchPlugin) -label "Ignore Error Code 211" -align "left" -v 0 -annotation "Does not fail and requeue the render on an Exit Code of 211. Useful if the render actually succeeds and is still throwing this error." frw_ignoreError211;
						setParent ..;

						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "" frw_dummyLocalAssetCachingLabel;
							checkBox -label "Strict Error Checking" -align "left" -v $strictErrorChecking -changeCommand SavePersistentDeadlineOptions -annotation "If checked, Deadline will fail the render job if any error message is detected" frw_strictErrorChecking;
							checkBox -enable ($useMayaBatchPlugin) -label "Use Local Asset Caching" -align "left" -v $useLocalAssetCaching -changeCommand SavePersistentDeadlineOptions -annotation "If enabled, slaves for this job will attempt to copy all network assets* to their local cache* and\nremap those assets in the scene file to point to the local cache (file structure is preserved).\n\n*Options specified at the repository level" frw_useLocalAssetCaching;
						setParent ..;

						$StartupScriptPathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Startup Script" -buttonLabel "..." -text $startupScript -changeCommand SavePersistentDeadlineOptions -annotation "Maya will source the specified script file on startup" frw_startupScript`;
						textFieldButtonGrp -e -bc SetStartupScriptPath $StartupScriptPathGrp;

						textFieldGrp -enable (!$useMayaBatchPlugin) -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $mayaArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Maya" frw_mayaArgs;

						string $mayaJobTypeBox = `optionMenuGrp -label "Deadline Job Type" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand UpdateJobType -annotation "Select the type of job that you want to submit to Deadline" frw_mayaJobType`;
						menuItem -label "Maya Render Job";
						menuItem -label "Mental Ray Export Job";
						menuItem -label "VRay Export Job";
						menuItem -label "RenderMan Export Job";
						menuItem -label "Arnold Export Job";
						menuItem -label "Maxwell Export Job";
						menuItem -label "Bifrost Simulation Job";
						menuItem -label "Alembic Export Job";
						menuItem -label "Maya Script Job";
						menuItem -label "Fluid Caching Job";
						menuItem -label "Geometry Caching Job";
						menuItem -label "Redshift Export Job";

						optionMenuGrp -e -select (1) $mayaJobTypeBox;

						$MayaRenderOptionsRollout = `frameLayout -label "Maya Render Job" -labelVisible true -borderVisible false -collapsable true`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Renders a normal Maya job using the current Maya renderer." frw_tileLabel;
								setParent ..;

								intSliderGrp -en $cpuEnabled -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 64 -v $cpus -changeCommand SavePersistentDeadlineOptions -annotation  "The number of processors to use during rendering (specify 0 to use all processors available)" frw_MaxCPUs;

								int $frameNumberOffsetEnabled = IsAnimatedOn();
								intSliderGrp -label "Frame Number Offset" -en $frameNumberOffsetEnabled -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10000 -maxValue 10000 -v 0 -changeCommand SavePersistentDeadlineOptions -annotation  "Uses Maya's frame renumbering option to offset the frames that are rendered" frw_frameNumberOffset;

								if( $renderLayerEnabled )
								{
									$tileRenderingEnable = $submitEachRenderLayer; // use to submit as separate job value for the tile rendering enable
									$overrideGlobalRangeEnable = $submitEachRenderLayer;
									$overrideLayerSettingsEnable = $submitEachRenderLayer;
									if( !$submitEachRenderLayer )
										$regionRendering = false;
								}

								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									string $submitEachRenderLayerBox = `checkBox -en $renderLayerEnabled -label "Submit Render Layers As Separate Jobs" -v $submitEachRenderLayer -changeCommand SavePersistentDeadlineOptions -annotation "Check this to submit each renderable Render Layer as a separate Deadline job. Note that the frame range will be pulled from the render globals for each layer." frw_submitEachRenderLayer`;
									checkBox -enable $overrideLayerSettingsEnable -label "Override Layer Job Settings" -v $overrideLayerSettings -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the job name, frame range, and task size can be set for each render layer when submitting a separate job for each layer" frw_overrideLayerSettings;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -label "Submit Cameras As Separate Jobs" -align "left" -v $submitEachCamera -changeCommand SavePersistentDeadlineOptions -annotation "Check this to submit each renderable Camera as a separate Deadline job." frw_submitEachCamera;
									checkBox -enable ($submitEachCamera) -label "Ignore Default Cameras" -align "left" -v $ignoreDefaultCameras -changeCommand SavePersistentDeadlineOptions -annotation "Check this to ignore default cameras (persp, top, etc) when submitting each renderable Camera as a separate Deadline job." frw_ignoreDefaultCameras;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -label "Enable Local Rendering" -align "left" -v $localRendering -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the slaves will render locally, and then copy the images to the network output directory on completion" frw_localRendering;
									$halfFramesEnabled = ShowHalfFramesOption( $renderer );
									checkBox -en $halfFramesEnabled -label "Render Half Frames" -v $renderHalfFrames -changeCommand SavePersistentDeadlineOptions -annotation "If checked, frames will be split into two using a step of 0.5" frw_renderHalfFrames;
								setParent ..;
							setParent ..;
						setParent ..;

						$MayaRenderOptionsArnoldRollout = `frameLayout -label "Arnold Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "arnold")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;

								$arnoldVerboseEnabled = ( $renderer == "arnold" );
								string $arnoldVerboseBox = `optionMenuGrp -en $arnoldVerboseEnabled -label "Arnold Verbosity" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Set the verbosity level for Arnold renders" frw_arnoldVerbose`;
								menuItem -label "0";
								menuItem -label "1";
								menuItem -label "2";
								if( $arnoldVerboseEnabled )
									optionMenuGrp -e -select (2) $arnoldVerboseBox;
							setParent ..;
						setParent ..;

						$MayaRenderOptionsMentalRayRollout = `frameLayout -label "Mental Ray Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "mentalRay")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;

								$mentalRayVerboseEnabled = ( $renderer == "mentalRay" );
								string $mentalRayVerboseBox = `optionMenuGrp -en $mentalRayVerboseEnabled -label "Mental Ray Verbosity" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Set the verbosity level for Mental Ray renders" frw_mentalRayVerbose`;
								menuItem -label "No Messages";
								menuItem -label "Fatal Messages Only";
								menuItem -label "Error Messages";
								menuItem -label "Warning Messages";
								menuItem -label "Info Messages";
								menuItem -label "Progress Messages";
								menuItem -label "Detailed Messages (Debug)";
								if( $mentalRayVerboseEnabled )
									optionMenuGrp -e -select (6) $mentalRayVerboseBox;

								checkBox -label "Auto Memory Limit" -align "left" -v $mentalRayAutoMemoryLimit -changeCommand SavePersistentDeadlineOptions -annotation "If checked, Mental Ray will automatically detect the optimal memory limit when rendering" frw_autoMemoryLimit;

								intSliderGrp -enable (!$mentalRayAutoMemoryLimit) -label "Memory Limit (MB)" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 100000 -v $mentalRayMemoryLimit -changeCommand SavePersistentDeadlineOptions -annotation  "Soft limit (in MB) for the memory used by Mental Ray (specify 0 for unlimited memory)" frw_memoryLimit;

							setParent ..;
						setParent ..;

						$MayaRenderOptionsRedshiftRollout = `frameLayout -label "Redshift Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "redshift")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								$redshiftVerboseEnabled = ( $renderer == "redshift" );
								string $redshiftVerboseBox = `optionMenuGrp -en $redshiftVerboseEnabled -label "Redshift Verbosity" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Set the verbosity level for Redshift renders" frw_redshiftVerbose`;
								menuItem -label "Errors and Warnings";
								menuItem -label "Detailed Info";
								menuItem -label "Debug";
								if( $redshiftVerboseEnabled )
									optionMenuGrp -e -select (3) $redshiftVerboseBox;
							setParent ..;
						setParent ..;

						$MayaRenderOptionsIRayRollout = `frameLayout -label "IRay Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "ifmIrayPhotoreal")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Render Using CPUs" -v $irayUseCPUs -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, then the CPUs will be used as part of the render." frw_irayUseCPUs;
								floatSliderGrp -enable ( $irayUseCPUs ) -label "CPU Load" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1.0 -maxValue 8.0 -v $irayCPULoad -changeCommand SavePersistentDeadlineOptions -annotation  "The maximum CPU load each task can use." frw_irayCPULoad;

							setParent ..;
						setParent ..;

						$MayaRenderOptionsVRayRollout = `frameLayout -label "VRay Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "vray")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -enable $useMayaBatchPlugin -label "Auto Memory Limit Detection (Requires the MayaBatch Plugin)" -align "left" -v $vrayAutoMemoryEnabled -changeCommand SavePersistentDeadlineOptions -annotation "If checked, Deadline will automatically detect the dynamic memory limit for VRay prior to rendering." frw_vrayAutoMemoryEnabled;

								intSliderGrp -enable ($useMayaBatchPlugin && $vrayAutoMemoryEnabled) -label "Memory Buffer (MB)" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 100000 -v $vrayAutoMemoryBuffer -changeCommand SavePersistentDeadlineOptions -annotation  "Deadline subtracts this value from the system's unused memory to determine the dynamic memory limit for VRay." frw_vrayAutoMemoryBuffer;

							setParent ..;
						setParent ..;

						$MentalRayExportRollout = `frameLayout -label "Mental Ray Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Mental Ray to export mi files instead of rendering." frw_tileLabel;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw2 $labelWidth 320 -ct2 "left" "right";
									$MentalRayFilenameGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Output File" -buttonLabel "..." -text $mentalRayFilename -changeCommand SavePersistentDeadlineOptions -annotation "The full filename of the Mental Ray files that will be exported (padding is handled automatically by the exporter)" frw_mentalRayFilePath`;
									textFieldButtonGrp -e -bc SetMentalRayFilename $MentalRayFilenameGrp;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw2 110 290 -ct2 "left" "left";
									button -label "Export Settings..." -width 100 -c OpenExportSettings -height 26 -annotation "Opens the Export Settings dialog";
									text -label "(This dialog must be open when submitting the job)";
								setParent ..;
							setParent ..;
						setParent ..;

						$MentalRayExportRenderJobRollout = `frameLayout -label "Mental Ray Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Mental Ray Standalone Render Job" -align "left" -v $submitMentalRayJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a Mental Ray Standalone job that is dependent on the export job will also be submitted" frw_submitMentalRayJob;

								string $mentalPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineMentalPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $mentalPoolsBox;
								}

								string $secondaryMentalPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineMentalSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryMentalPoolsBox;

								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryMentalPoolsBox;
								}

								string $groupsMentalBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_MentalGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsMentalBox;
								}

								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_MentalJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_MentalLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_MentalConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_MentalSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_MentalMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_MentalAutoTaskTimeout;
								setParent ..;

								$MentalLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_MentalLimitGroups`;
								textFieldButtonGrp -e -bc SetMentalLimitGroups $MentalLimitGroupGrp;

								$MentalMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_MentalMachineList`;
								textFieldButtonGrp -e -bc SetMentalMachineList $MentalMachineListGrp;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $MentalOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_MentalOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $MentalOnCompleteBox;

									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_MentalIsBlacklist;
								setParent ..;

								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $mentalRayThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_mentalRayThreads;

								intSliderGrp -label "Frame Offset" -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10000 -maxValue 10000 -v $mentalRayOffset -changeCommand SavePersistentDeadlineOptions -annotation  "The value to offset the frame numbers by when rendering separate mi files per frame" frw_mentalRayOffset;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $mentalRayBuildBox = `optionMenuGrp -label "Mental Ray Build" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Force Deadline to render using the specified build of Maya" frw_mentalRayBuild`;
									menuItem -label "None";
									menuItem -label "32bit";
									menuItem -label "64bit";
									if( $mayaBuildEnabled )
									{
										if( `about -is64` )
											optionMenuGrp -e -select (3) $mentalRayBuildBox;
										else
											optionMenuGrp -e -select (2) $mentalRayBuildBox;
									}
									else
										optionMenuGrp -e -select (1) $mentalRayBuildBox;

									checkBox -label "Enable Local Rendering" -v $mentalRayLocalRendering -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the slaves will render locally, and then copy the images to the network output directory on completion" frw_mentalRayLocalRendering;
								setParent ..;

								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $mentalRayArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to mental ray" frw_mentalRayArgs;
							setParent ..;
						setParent ..;

						$VrayExportRollout = `frameLayout -label "VRay Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses VRay to export vrscene files instead of rendering." frw_tileLabel;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw2 $labelWidth 320 -ct2 "left" "right";
									$VRayFilenameGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Output File" -buttonLabel "..." -text $vrayFilename -changeCommand SavePersistentDeadlineOptions -annotation "The full filename of the VRay files that will be exported (padding is handled automatically by the exporter)" frw_vrayFilePath`;
									textFieldButtonGrp -e -bc SetVRayFilename $VRayFilenameGrp;
								setParent ..;
							setParent ..;
						setParent ..;

						$VrayExportRenderJobRollout = `frameLayout -label "VRay Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent VRay Standalone Render Job" -align "left" -v $submitVRayJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a VRay Standalone job that is dependent on the export job will also be submitted" frw_submitVRayJob;
								string $vrayPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineVrayPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $vrayPoolsBox;
								}

								string $secondaryVrayPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineVraySecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryVrayPoolsBox;

								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryVrayPoolsBox;
								}

								string $groupsVrayBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_VrayGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsVrayBox;
								}

								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_VrayJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_VrayLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_VrayConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_VraySlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_VrayMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_VrayTaskTimeout;
								setParent ..;


								$VrayLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_VrayLimitGroups`;
								textFieldButtonGrp -e -bc SetVrayLimitGroups $VrayLimitGroupGrp;

								$VrayMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_VrayMachineList`;
								textFieldButtonGrp -e -bc SetVrayMachineList $VrayMachineListGrp;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $VrayOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_VrayOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $VrayOnCompleteBox;

									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_VrayIsBlacklist;
								setParent ..;

								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $vrayThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_vrayThreads;

							setParent ..;
						setParent ..;

						$MayaRenderOptionsGPURollout = `frameLayout -label "GPU Affinity Overrides" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "redshift" || $renderer == "ifmIrayPhotoreal" || $renderer == "OctaneRender" )`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								intSliderGrp -enable (strcmp($deadlineGPUsSelectDevices, "") == 0) -label "GPUs Per Task" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 16 -v $deadlineGPUsPerTask -changeCommand SavePersistentDeadlineOptions -annotation  "The number of GPUs to use per task. If set to 0, the default number of GPUs will be used." frw_deadlineGPUsPerTask;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									textFieldGrp -enable ($deadlineGPUsPerTask == 0) -label "Select GPU Devices" -cl2 "left" "left" -cw2 $labelWidth 320 -text $deadlineGPUsSelectDevices -textChangedCommand SavePersistentDeadlineOptions -annotation "A comma separated list of the GPU devices to use specified by device Id. 'GPUs Per Task' will be ignored." frw_deadlineGPUsSelectDevices;

									// the "placeholderText" parameter did not exist until Maya 2013 Extension Pack
									if ( getApplicationVersionAsFloat() > 2013)
									{
										textFieldGrp -e -placeholderText "Enter Valid GPU Device Id(s): 0 or 1 or 0,2 or 0,3,4 etc" frw_deadlineGPUsSelectDevices;
									}
								setParent ..;
							setParent ..;
						setParent ..;

						int $vrimg2ExrEnabled = $submitVRayJob;
						$VrayExportVrimgJobRollout = `frameLayout -label "Vrimg2Exr Conversion Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -enable $vrimg2ExrEnabled -label "Convert vrimg Files To exr With Dependent Job" -align "left" -v $submitVrimg2ExrJob -changeCommand SavePersistentDeadlineOptions -annotation "Enable this option to submit a dependent job that converts the vrimg output files to exr files" frw_submitVrimg2ExrJob;
								checkBox -enable $vrimg2ExrEnabled -label "Delete Input vrimg Files After Conversion" -align "left" -v $deleteVrimgFiles -changeCommand SavePersistentDeadlineOptions -annotation "Enable this option to delete the input vrimg file after the conversion has finished." frw_deleteVrimgFiles;
							setParent ..;
						setParent ..;

						$RendermanExportRollout = `frameLayout -label "RenderMan Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses RenderMan to export rib files instead of rendering." frw_exportRenderManLabel;
								setParent ..;

								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $exportRenderManThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during exporting (specify 0 to use all processors available)" frw_exportRenderManThreads;

								rowLayout -numberOfColumns 2 -cw2 $labelWidth 158 -ct2 "left" "left";
									text -align "left" -label "" frw_dummyRenderWithRisLabel;
									checkBox -label "Render With RIS" -v $renderRenderManWithRis -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the exported RIB files will have RIS set as the renderer instead of REYES" frw_renderRenderManWithRis;
								setParent ..;
							setParent ..;
						setParent ..;

						$RendermanExportRenderJobRollout = `frameLayout -label "RenderMan Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent RenderMan Standalone Render Job" -align "left" -v $submitRenderManJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a RenderMan Standalone job that is dependent on the export job will also be submitted" frw_submitRenderManJob;
								checkBox -label "Enable RenderMan Frame Dependencies" -align "left" -v $renderManFrameDependent -changeCommand SavePersistentDeadlineOptions -annotation "If Checked, the RenderMan Job will have Frame Dependencies. If your scene contains static content, do not use!" frw_renderManFrameDependent;
								string $rendermanPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineRendermanPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $rendermanPoolsBox;
								}

								string $secondaryRendermanPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineRendermanSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryRendermanPoolsBox;

								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryRendermanPoolsBox;
								}

								string $groupsRendermanBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_RendermanGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsRendermanBox;
								}

								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_RendermanJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_RendermanLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_RendermanConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_RendermanSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_RendermanMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_RendermanAutoTaskTimeout;
								setParent ..;

								$RendermanLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_RendermanLimitGroups`;
								textFieldButtonGrp -e -bc SetRendermanLimitGroups $RendermanLimitGroupGrp;

								$RendermanMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_RendermanMachineList`;
								textFieldButtonGrp -e -bc SetRendermanMachineList $RendermanMachineListGrp;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $RendermanOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_RendermanOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $RendermanOnCompleteBox;

									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_RendermanIsBlacklist;
								setParent ..;


								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $rendermanThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_rendermanThreads;

								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $rendermanArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to RenderMan" frw_rendermanArgs;
							setParent ..;
						setParent ..;

						$ArnoldExportRollout = `frameLayout -label "Arnold Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Arnold to export ass files instead of rendering." frw_exportArnoldLabel;
								setParent ..;
							setParent ..;
						setParent ..;

						$ArnoldExportRenderJobRollout = `frameLayout -label "Arnold Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Arnold Standalone Render Job" -align "left" -v $submitArnoldJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, an Arnold Standalone job that is dependent on the export job will also be submitted" frw_submitArnoldJob;
								checkBox -label "Local Export to Arnold" -align "left" -v $exportArnoldLocal -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the arnold ass file will be exported locally" frw_exportArnoldLocal;

								string $arnoldPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineArnoldPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $arnoldPoolsBox;
								}

								string $secondaryArnoldPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineArnoldSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryArnoldPoolsBox;

								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryArnoldPoolsBox;
								}

								string $groupsArnoldBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_ArnoldGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsArnoldBox;
								}

								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_ArnoldJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_ArnoldLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_ArnoldConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_ArnoldSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_ArnoldMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_ArnoldAutoTaskTimeout;
								setParent ..;

								$ArnoldLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_ArnoldLimitGroups`;
								textFieldButtonGrp -e -bc SetArnoldLimitGroups $ArnoldLimitGroupGrp;

								$ArnoldMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_ArnoldMachineList`;
								textFieldButtonGrp -e -bc SetArnoldMachineList $ArnoldMachineListGrp;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $ArnoldOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_ArnoldOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $ArnoldOnCompleteBox;

									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_ArnoldIsBlacklist;
								setParent ..;

								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $arnoldThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_arnoldThreads;

								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $arnoldArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Arnold" frw_arnoldArgs;
							setParent ..;
						setParent ..;

						$MaxwellExportRollout = `frameLayout -label "Maxwell Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Maxwell to export MXS files instead of rendering." frw_exportMaxwellLabel;
								setParent ..;
								$MaxwellOutputScriptListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Maxwell Script Name" -buttonLabel "..." -text $maxwellScript -annotation "The Maxwell scene file to export to." frw_maxwellScriptName`;
								textFieldButtonGrp -e -bc SetMaxwellOutputScript $MaxwellOutputScriptListGrp;
								checkBox -label "Resume From MXI File If It Exists  (requires Maxwell 2.5.1 or later)" -changeCommand SavePersistentDeadlineOptions -v false -annotation "Requires Maxwell 2.5.1. If enabled, Maxwell will use the specified MXI file to resume the render if it exists. If you suspend the job in Deadline, it will pick up from where it left off when it resumes." frw_maxwellMXIResume;
							setParent ..;
						setParent ..;

						$MaxwellExportRenderJobRollout = `frameLayout -label "Maxwell Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Maxwell Standalone Render Job" -align "left" -v $submitMaxwellJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a Maxwell Standalone job that is dependent on the export job will also be submitted" frw_submitMaxwellJob;
								checkBox -label "Local Export to Maxwell" -align "left" -v $exportMaxwellLocal -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the Maxwell mxs file will be exported locally" frw_exportMaxwellLocal;

								string $maxwellPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineMaxwellPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $maxwellPoolsBox;
								}

								string $secondaryMaxwellPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineMaxwellSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryMaxwellPoolsBox;

								for( $i = 0; $i < size($deadlinePools); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryMaxwellPoolsBox;
								}

								string $groupsMaxwellBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_MaxwellGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsMaxwellBox;
								}

								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_MaxwellJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_MaxwellLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_MaxwellConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_MaxwellSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_MaxwellMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_MaxwellAutoTaskTimeout;
								setParent ..;

								$MaxwellLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_MaxwellLimitGroups`;
								textFieldButtonGrp -e -bc SetMaxwellLimitGroups $MaxwellLimitGroupGrp;

								$MaxwellMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_MaxwellMachineList`;
								textFieldButtonGrp -e -bc SetMaxwellMachineList $MaxwellMachineListGrp;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $MaxwellOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_MaxwellOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $MaxwellOnCompleteBox;

									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_MaxwellIsBlacklist;
								setParent ..;

								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $maxwellThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_maxwellThreads;

								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $maxwellArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Maxwell" frw_maxwellArgs;
							setParent ..;
						setParent ..;

						$MaxwellExportCoopOptionsRollout = `frameLayout - label "Maxwell Cooperative Rendering" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								int $frameRangeEnabled = !IsAnimatedOn();

								rowLayout -numberOfColumns 2 -cw 1 200 -ct1 "left";
									checkBox -label "Cooperative Rendering" -changeCommand SavePersistentDeadlineOptions -v true -annotation "If enabled, multiple jobs will be submitted to Deadline, each with a different seed. You can then use Maxwell to combine the resulting output after rendering has completed." frw_maxwellCooperativeRendering;
									checkBox -en $frameRangeEnabled -label "Split Co-op Renders Into Separate Jobs" -changeCommand SavePersistentDeadlineOptions -v true -annotation "If enabled, co-op renders will be split up into separate jobs. This is required if rendering an animation instead of a single Maxwell file." frw_maxwellCoopSeparateJobs;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw 1 200 -ct1 "left";
									text -label "Number Of Co-op Renders" frw_maxwellNumCoopRendersLabel;
									intField -changeCommand SavePersistentDeadlineOptions -minValue 2 -maxValue 1000000 -v 2 -annotation "The number of co-op renders to submit to Deadline." frw_maxwellNumCoopRenders;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw 1 200 -ct1 "left";
									checkBox -label "Auto-Merge Files" -changeCommand SavePersistentDeadlineOptions -v $maxwellAutoMergeFiles -annotation "Enable if you want Deadline to use Maxwell to merge the results from the co-op jobs." frw_maxwellAutoMergeFiles;
									checkBox -en $maxwellAutoMergeFiles -label "Fail On Missing Intermediate Files" -changeCommand SavePersistentDeadlineOptions -v true -annotation "Enable to have the merge job fail if there are co-op job results that are missing." frw_maxwellMissingIntermediate;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw 1 200 -ct1 "right";
									text -label "";
									checkBox -en $maxwellAutoMergeFiles -label "Delete Intermediate Files" -changeCommand SavePersistentDeadlineOptions -v false -annotation "Enable to have Deadline delete the individual co-op job results after merging the final result." frw_maxwellDeleteIntermediate;
								setParent ..;
							setParent ..;
						setParent ..;

						$MayaRenderOptionsTileRollout = `frameLayout -label "Region Rendering" -labelVisible true -borderVisible false -collapsable true -collapse true`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "For arnold, mayaSoftware, mentalRay, redshift, renderMan, finalRender, turtle, vray, and arnold export\njobs only. If you have multiple layers, this only works if you submit each layer as a separate job." frw_tileLabel;
								setParent ..;

								string $regionRenderTypeTypeBox = `optionMenuGrp -label "Region Render Type" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand UpdateRegionRenderType -annotation "Select the method of region rendering" frw_regionRenderType`;
								menuItem -label "Jigsaw Rendering";
								menuItem -label "Tile Rendering";
								optionMenuGrp -e -select (1) $regionRenderTypeTypeBox;

								rowLayout -numberOfColumns 1 -cw 1 $labelWidth -ct1 "left";
									checkBox -enable $tileRenderingEnable -label "Enable Region Rendering" -changeCommand SavePersistentDeadlineOptions -v $regionRendering -annotation "Tile rendering splits up a frame between multiple machines (the assembly is done automatically for bmp, exr, jpg, png, tga, and tif)" frw_regionRendering;
								setParent ..;

								columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4 frw_tileRenderLayout;
									rowLayout -numberOfColumns 1 -cw 1 (310 + $labelWidth) -ct1 "right";
										intSliderGrp -enable $regionRendering -label "Tiles In X" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 200 -v $tilesInX -changeCommand SavePersistentDeadlineOptions -annotation "The number of tiles in the X direction" frw_tilesInX;
									setParent ..;

									rowLayout -numberOfColumns 1 -cw 1 (310 + $labelWidth) -ct1 "right";
										intSliderGrp -enable $regionRendering -label "Tiles In Y" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 200 -v $tilesInY -changeCommand SavePersistentDeadlineOptions -annotation "The number of tiles in the Y direction" frw_tilesInY;
									setParent ..;
								setParent ..;
								string $tileRenderingSingleJob = `checkBox -en $regionRendering -align "left" -label "Submit All Tiles As A Single Job" -v $tileSingleJob -changeCommand SavePersistentDeadlineOptions -annotation "Check this to combine all tiles into a single job." frw_submitTileSingleJob`;

								rowLayout -numberOfColumns 1 -cw 1 (320 + $labelWidth) -ct1 "right";
									intSliderGrp -enable $regionRendering -label "Single Job Frame" -cal 1 "left" -cw 1 $labelWidth -field true -minValue -100000 -maxValue 100000 -v $currTime -changeCommand SavePersistentDeadlineOptions -annotation "The single frame to render." frw_tileSingleFrame;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw2 $labelWidth 260 -ct2 "left" "left" frw_jigsawRenderLayout;
									$OpenJigsawBtn = `button -label "Open Jigsaw Panel" -width 105 -height 26 -annotation "Opens the Jigsaw panel" -c OpenJigsawWindow frw_openJigsaw`;
									text -align "left" -label "Jigsaw Panel must be open during submission." frw_jigsawLabel;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -en $regionRendering -align "left" -label "Submit Dependent Assembly Job" -v $tileDependentJob -changeCommand SavePersistentDeadlineOptions -annotation "Check this submit an assembly job that is dependent on the first job." frw_submitTileDependentJob;
									checkBox -en $regionRendering -align "left" -label "Error on Missing Tiles" -v $tileErrorOnMissing -changeCommand SavePersistentDeadlineOptions -annotation "Check this force the render to fail on a missing tile" frw_submitTileErrorOnMissing;
									setParent ..;
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -en $regionRendering -align "left" -label "Cleanup Tiles After Assembly" -v $tileCleanupJob -changeCommand SavePersistentDeadlineOptions -annotation "Check this to delete all tiles after the assembly job completes." frw_submitTileCleanupJob;
								setParent ..;
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									string $compositeTypeBox = `optionMenuGrp -label "Assemble over" -cl2 "left" "left" -cw2 $labelWidth 130 -changeCommand UpdateCompositeType -annotation "Select the image to composite over" frw_compositeType`;
									menuItem -label "Blank Image";
									menuItem -label "Previous Output";
									menuItem -label "Selected Image";
									optionMenuGrp -e -select (1) $compositeTypeBox;
								setParent ..;
								rowLayout -numberOfColumns 1 -cw2 260 160 -ct2 "left" "left" frw_compLayout;
									$CompositeNamePathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Background Image File" -buttonLabel "..." -text $tileCompositeOverName -changeCommand SavePersistentDeadlineOptions -annotation "The name of the file to Assemble over" frw_submitTileCompositeOverName`;
									print $CompositeNamePathGrp;
									textFieldButtonGrp -e -bc SetCompositeOverPath $CompositeNamePathGrp;
								setParent ..;
								rowLayout -numberOfColumns 1 -cw2 260 160 -ct2 "left" "left";
									checkBox -en $regionRendering -align "left" -label "Error on Missing Background" -v $tileMissingBackground -changeCommand SavePersistentDeadlineOptions -annotation "Check this to have the assemble fail if the background file is missing." frw_submitTileErrorOnMissingBackground;
								setParent ..;

							setParent ..;
						setParent ..;

						$BifrostSimulationJobRollout = `frameLayout -label "Bifrost Simulation Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Caches all bifrost containers.";
								setParent..;

								$BifrostDirectoryButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Bifrost Cache Directory" -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "The directory where the Bifrost cache will be sent." frw_bifrostCacheDir`;
								textFieldButtonGrp -e -bc SetBifrostCacheDirectory $BifrostDirectoryButtonGrp;

								if(IntMayaVersion() >= 2016) // Maya 2016 and beyond: Add options for format and compression index
								{
									optionMenuGrp -label "Compression Format" -cl2 "left" "left" -cw2 $labelWidth 160 -annotation "Select the Compression Format to use" frw_biFrostCompressionFormat;
									menuItem -label "Simple (lossless, least compression)";
									menuItem -label "Float (lossless)";
									menuItem -label "Quantization (lossy)";

								}
							setParent ..;
						setParent ..;

						$AlembicExportJobRollout = `frameLayout -label "Alembic Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Export scene or selection to Alembic format (.abc).";
								setParent ..;

								$AlembicFileButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Alembic Output File" -buttonLabel "..." -changeCommand SavePersistentDeadlineOptions -annotation "The file that Alembic will write to." frw_alembicExportFile`;
								textFieldButtonGrp -e -bc SetAlembicCacheFile $AlembicFileButtonGrp;
								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "Export:" -labelArray2 "All" "Selection" -cw3 $labelWidth 160 160 -select 1 frw_AlembicExportSelection;

							setParent ..;
						setParent ..;

						$AlembicAdvancedOptionsJobRollout = `frameLayout -label "Advanced Options" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
								setParent ..;

								checkBox -label "Subframe Samples" -align "left" -changeCommand SavePersistentDeadlineOptions frw_abcSubFrameCheck;
								floatSliderGrp -label "Low" -enable false -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10 -maxValue 10 -v -0.2 -changeCommand SavePersistentDeadlineOptions frw_abcLowSubFrameCheck;
								floatSliderGrp -label "High" -enable false -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10 -maxValue 10 -v 0.2 -changeCommand SavePersistentDeadlineOptions frw_abcHighSubFrameCheck;

								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -annotation "The list of geometric attributes to write out. Separated by commas." -label "Attributes: " frw_abcDynamicAttributes;
								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -annotation "The list of Prefix filter for determining which geometric attributes to write out. Separated by commas." -label "Attribute Prefixes: " frw_abcDynamicAttributePrefix;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Verbose" -align "left" -changeCommand SavePersistentDeadlineOptions frw_verboseCheck;
									checkBox -label "No Normals" -align "left" -changeCommand SavePersistentDeadlineOptions frw_noNormalsCheck;
									checkBox -label "Renderable Only" -changeCommand SavePersistentDeadlineOptions frw_renderableOnlyCheck;
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Strip Namespaces" -align "left" -changeCommand SavePersistentDeadlineOptions frw_stripNamespacesCheck;
									checkBox -label "UV Write" -align "left" -changeCommand SavePersistentDeadlineOptions frw_uvWriteCheck;
									checkBox -label "Write Color Sets" -changeCommand SavePersistentDeadlineOptions frw_writeColorSetsCheck;
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Write Face Sets" -align "left" -changeCommand SavePersistentDeadlineOptions frw_writeFaceSetsCheck;
									checkBox -label "Whole Frame Geo" -align "left" -changeCommand SavePersistentDeadlineOptions frw_wholeFrameGeoCheck;
									checkBox -label "World Space" -changeCommand SavePersistentDeadlineOptions frw_worldSpaceCheck;
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Write Visibility" -align "left" -changeCommand SavePersistentDeadlineOptions frw_writeVisibilityCheck;
									checkBox -label "Filter Euler Rotations" -align "left" -changeCommand SavePersistentDeadlineOptions frw_filterEulerRotationsCheck;
									checkBox -label "Write Creases" -changeCommand SavePersistentDeadlineOptions frw_writeCreasesCheck;
								setParent ..;
								optionMenuGrp -label "Alembic Format" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions frw_alembicFormat;
								menuItem -label "HDF5 - Maya 2014 Extension 1 and Legacy";
								menuItem -label "Ogawa - Maya 2014 Extension 1";

							setParent ..;
						setParent ..;



						$MayaScriptJobRollout = `frameLayout -label "Maya Script Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Python or Melscript to run a custom Maya script.";
								setParent ..;
								$MayaScriptButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Script File Name" -buttonLabel "..." -annotation "The custom script to run." frw_mayaScriptJob`;
								textFieldButtonGrp -e -bc SetMayaOutputScript $MayaScriptButtonGrp;
							setParent ..;
						setParent ..;

						$FluidCachingJobRollout = `frameLayout -label "Fluid Caching Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Runs a Fluid Caching Job on selected fluids.";
								setParent ..;

								$FluidCachingDirButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Cache Output Directory: " -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "The folder that the cache will be saved in." frw_FluidCacheOutputDir`;
								textFieldButtonGrp -e -bc SetFluidCacheDirectory $FluidCachingDirButtonGrp;
								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -label "Cache Prefix Name: " frw_FluidCacheFileName;
								optionMenuGrp -label "Cache Format: " -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions frw_FluidCacheFormat;
								menuItem -label "mcc";
								menuItem -label "mcx";

								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "File Distribution:" -labelArray2 "One File Per Frame" "Only One File" -cw3 $labelWidth 160 160 -select 1 -vr frw_FluidCacheFileDistRadio;
								checkBox -label "One Cache Per Fluid" -changeCommand SavePersistentDeadlineOptions frw_FluidCacheSplitCheck;

							setParent ..;
						setParent ..;

						$GeometryCachingJobRollout = `frameLayout -label "Geometry Caching Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Runs a Geometry caching job on selected geometry.";
								setParent ..;

								$GeometryCachingDirButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Cache Output Directory: " -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "The folder that the cache will be saved in." frw_GeometricCacheOutputDir`;
								textFieldButtonGrp -e -bc SetGeometricCacheDirectory $GeometryCachingDirButtonGrp;

								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -label "Cache Prefix Name: " frw_GeoCacheFileName;

								optionMenuGrp -label "Cache Format: " -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions frw_GeoCacheFormat;
								menuItem -label "mcc";
								menuItem -label "mcx";

								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "File Distribution:" -labelArray2 "One File Per Frame" "Only One File" -cw3 $labelWidth 160 160 -select 1 -vr frw_GeometricCacheFileDistRadio;
								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "Store Points As:" -labelArray2 "Double" "Float" -cw3 $labelWidth 160 160 -select 1 -vr frw_GeometricCacheDblOrFltRadio;
								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "Store Points In:" -labelArray2 "Local" "World" -cw3 $labelWidth 160 160 -select 1 -vr frw_GeometricCacheLocOrWldRadio;
								checkBox -label "One Cache Per Geometry" -changeCommand SavePersistentDeadlineOptions frw_GeometricCacheSplitCheck;
							setParent ..;
						setParent ..;

						$RedshiftExportRollout = `frameLayout -label "Redshift Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Redshift to export .rs files instead of rendering." frw_exportRedshiftLabel;
								setParent ..;
							setParent ..;
						setParent ..;

						$RedshiftExportRenderJobRollout = `frameLayout -label "Redshift Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								int $layersOn = IsRenderLayersOn();
								checkBox -label "Submit Dependent Redshift Standalone Render Job" -align "left" -v $submitRedshiftJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a Redshift Standalone job that is dependent on the export job will also be submitted" frw_submitRedshiftJob;
								checkBox -label "Local Export to Redshift" -align "left" -v $exportRedshiftLocal -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the redshift rs file will be exported locally" frw_exportRedshiftLocal;
								checkBox -label "Enable Redshift Frame Dependencies" -align "left" -v $redshiftFrameDependent -changeCommand SavePersistentDeadlineOptions -annotation "If Checked, the Redshift Job will have Frame Dependencies. If your scene contains static content, do not use!" frw_redshiftFrameDependent;
								checkBox -en $layersOn -label "Submit Render Layers As Separate Jobs" -align "left" -v $redshiftLayerSubmission -changeCommand SavePersistentDeadlineOptions -annotation "Check this to submit each renderable Render Layer as a separate Deadline job. Note that the frame range will be pulled from the render globals for each layer." frw_redshiftLayerSubmission;

								string $redshiftPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineRedshiftPool`;
								for( $i = 0; $i < size( $deadlinePools ); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $redshiftPoolsBox;
								}

								string $secondaryRedshiftPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineRedshiftSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryRedshiftPoolsBox;

								for( $i = 0; $i < size( $deadlinePools ); ++$i )
								{
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryRedshiftPoolsBox;
								}

								string $groupsRedshiftBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_RedshiftGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsRedshiftBox;
								}

								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_RedshiftJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_RedshiftLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_RedshiftConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_RedshiftSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_RedshiftMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_RedshiftAutoTaskTimeout;
								setParent ..;

								$RedshiftLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_RedshiftLimitGroups`;
								textFieldButtonGrp -e -bc SetRedshiftLimitGroups $RedshiftLimitGroupGrp;

								$RedshiftMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_RedshiftMachineList`;
								textFieldButtonGrp -e -bc SetRedshiftMachineList $RedshiftMachineListGrp;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $RedshiftOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_RedshiftOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $RedshiftOnCompleteBox;

									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_RedshiftIsBlacklist;
								setParent ..;

								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $redshiftThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_redshiftThreads;

								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $redshiftArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Redshift" frw_redshiftArgs;
							setParent ..;
						setParent ..;
					setParent ..;
				setParent ..;
			setParent ..;
		//
	setParent ..;

	//bottom buttons
	columnLayout -adj true -columnAttach "both" 0 -rowSpacing 2 buttonColumnLayout;
		separator -width 525;
		rowLayout -numberOfColumns 3 -cw3 150 30 295; //ADDS to 525??
			columnLayout -adj true -columnAttach "both" 4 -rowSpacing 2;
				button -label "Render Globals" -width 150 -height 15 -c unifiedRenderGlobalsWindow -annotation "Opens the Maya Render Globals Dialog";
				button -label "Edit Project" -width 150 -height 15 -c ProjectWindow -annotation "Opens the Maya Edit Project Dialog";
				button -label "Online Help" -width 150 -c OnlineHelp -height 15 -annotation "Opens the Online Help page in the Default Web Browser";
			setParent ..;
			text -label "";
			columnLayout -adj true -columnAttach "both" 4 -rowSpacing 2;
				rowLayout -numberOfColumns 2 -cw2 105 230;
					button -label "Pipeline Tools" -width 100 -height 30 -annotation "Opens the Pipeline Tools Dialog" -c OpenIntegrationWindow;
					button -label "Submit Job" -width 230 -height 30 -annotation "Submits this job to Deadline" -c DeadlineSubmitterOnOk;
				setParent ..;
				progressBar -width 210 -height 15 -minValue 0 -maxValue 100 -annotation "Deadline Submission Progress" frw_progBar;
			setParent ..;
		setParent ..;
	setParent ..;

	//this ties the scroll layout and the bottom buttons together
	formLayout -e
		-af buttonColumnLayout bottom 5
		-af buttonColumnLayout left 5
		-ac mainScrollLayout bottom 5 buttonColumnLayout
		-af mainScrollLayout top 5
		-af mainScrollLayout left 5
	mainFormLayout;

	UpdateRegionRenderType();
	UpdateCompositeType();

	scriptJob -uiDeleted $DeadlineSubmitterWindow OnExit;
	scriptJob -e "quitApplication" OnExit;
	// Show the submission dialog window.
	showWindow DeadlineSubmitWindow;
}
